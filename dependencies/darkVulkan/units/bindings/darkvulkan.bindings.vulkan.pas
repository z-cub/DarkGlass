{
  Copyright (c) 2015-2018 The Khronos Group Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

---- Exceptions to the Apache 2.0 License: ----

As an exception, if you use this Software to generate code and portions of
this Software are embedded into the generated code as a result, you may
redistribute such product without providing attribution as would otherwise
be required by Sections 4(a), 4(b) and 4(d) of the License.

In addition, if you combine or link code generated by this Software with
software that is licensed under the GPLv2 or the LGPL v2.0 or 2.1
("`Combined Software`") and if a court of competent jurisdiction determines
that the patent provision (Section 3), the indemnity provision (Section 9)
or other Section of the License conflicts with the conditions of the
applicable GPL or LGPL license, you may retroactively and prospectively
choose to deem waived or otherwise exclude such Section(s) of the License,
but only in their entirety and only with respect to the Combined Software.
}

{
  This file, vk.xml, is the Vulkan API Registry. It is a critically important
and normative part of the Vulkan Specification, including a canonical
machine-readable definition of the API, parameter and member validation
language incorporated into the Specification and reference pages, and other
material which is registered by Khronos, such as tags used by extension and
layer authors. The authoritative public version of vk.xml is maintained in
the master branch of the Khronos Vulkan GitHub project. The authoritative
private version is maintained in the master branch of the member gitlab
server.
}

{$Z4}
unit darkvulkan.bindings.vulkan;

interface

{$ifdef LINUX}{$define VK_USE_PLATFORM_XLIB_KHR}{$endif}
{$ifdef ANDROID}{$define VK_USE_PLATFORM_ANDROID_KHR}{$endif}
{$ifdef MSWINDOWS}{$define VK_USE_PLATFORM_WIN32_KHR}{$endif}
{$ifdef IOS}{$define VK_USE_PLATFORM_IOS_MVK}{$endif}
{$ifdef MACOS}{$ifndef IOS}{$define VK_USE_PLATFORM_MACOS_MVK}{$endif}{$endif}

uses
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}
  darkplatform.linux.binding.x,
  darkplatform.linux.binding.xlib,
  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  AndroidAPI.NativeWindow,
  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  Windows,
  {$endif}
  sysutils,
  darkDynlib;

function VK_MAKE_VERSION( VersionMajor: int32; VersionMinor: int32; VersionPatch: int32 ): int32;
function VK_VERSION_MAJOR( Version: int32 ): int32;
function VK_VERSION_MINOR( Version: int32 ): int32;
function VK_VERSION_PATCH( Version: int32 ): int32;

const
  VK_API_VERSION_1_0 = (1 shl 22) or (1 shl 12) or 1;
  VK_API_VERSION_1_1 = (1 shl 22) or (1 shl 12) or 1;
  VK_HEADER_VERSION = 83;
  VK_NULL_HANDLE = 0;


type
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  ANativeWindow = record
  end;

  {$endif}
  AHardwareBuffer = record
  end;


{
  Aliases for c-types
}


type
  uint8_t = uint8;
  uint32_t = uint32;
  uint64_t = uint64;
  int8_t = int8;
  int32_t = int32;
  int64_t = int64;
  float = single;
  TChar = uint8;
  pTChar = ^TChar;
  VkSampleMask = uint32_t;
  VkBool32 = uint32_t;
  VkFlags = uint32_t;
  VkDeviceSize = uint64_t;
  VkFramebufferCreateFlags = VkFlags;
  VkQueryPoolCreateFlags = VkFlags;
  VkRenderPassCreateFlags = VkFlags;
  VkSamplerCreateFlags = VkFlags;
  VkPipelineLayoutCreateFlags = VkFlags;
  VkPipelineCacheCreateFlags = VkFlags;
  VkPipelineDepthStencilStateCreateFlags = VkFlags;
  VkPipelineDynamicStateCreateFlags = VkFlags;
  VkPipelineColorBlendStateCreateFlags = VkFlags;
  VkPipelineMultisampleStateCreateFlags = VkFlags;
  VkPipelineRasterizationStateCreateFlags = VkFlags;
  VkPipelineViewportStateCreateFlags = VkFlags;
  VkPipelineTessellationStateCreateFlags = VkFlags;
  VkPipelineInputAssemblyStateCreateFlags = VkFlags;
  VkPipelineVertexInputStateCreateFlags = VkFlags;
  VkPipelineShaderStageCreateFlags = VkFlags;
  VkDescriptorSetLayoutCreateFlags = VkFlags;
  VkBufferViewCreateFlags = VkFlags;
  VkInstanceCreateFlags = VkFlags;
  VkDeviceCreateFlags = VkFlags;
  VkDeviceQueueCreateFlags = VkFlags;
  VkQueueFlags = VkFlags;
  VkMemoryPropertyFlags = VkFlags;
  VkMemoryHeapFlags = VkFlags;
  VkAccessFlags = VkFlags;
  VkBufferUsageFlags = VkFlags;
  VkBufferCreateFlags = VkFlags;
  VkShaderStageFlags = VkFlags;
  VkImageUsageFlags = VkFlags;
  VkImageCreateFlags = VkFlags;
  VkImageViewCreateFlags = VkFlags;
  VkPipelineCreateFlags = VkFlags;
  VkColorComponentFlags = VkFlags;
  VkFenceCreateFlags = VkFlags;
  VkSemaphoreCreateFlags = VkFlags;
  VkFormatFeatureFlags = VkFlags;
  VkQueryControlFlags = VkFlags;
  VkQueryResultFlags = VkFlags;
  VkShaderModuleCreateFlags = VkFlags;
  VkEventCreateFlags = VkFlags;
  VkCommandPoolCreateFlags = VkFlags;
  VkCommandPoolResetFlags = VkFlags;
  VkCommandBufferResetFlags = VkFlags;
  VkCommandBufferUsageFlags = VkFlags;
  VkQueryPipelineStatisticFlags = VkFlags;
  VkMemoryMapFlags = VkFlags;
  VkImageAspectFlags = VkFlags;
  VkSparseMemoryBindFlags = VkFlags;
  VkSparseImageFormatFlags = VkFlags;
  VkSubpassDescriptionFlags = VkFlags;
  VkPipelineStageFlags = VkFlags;
  VkSampleCountFlags = VkFlags;
  VkAttachmentDescriptionFlags = VkFlags;
  VkStencilFaceFlags = VkFlags;
  VkCullModeFlags = VkFlags;
  VkDescriptorPoolCreateFlags = VkFlags;
  VkDescriptorPoolResetFlags = VkFlags;
  VkDependencyFlags = VkFlags;
  VkSubgroupFeatureFlags = VkFlags;
  VkIndirectCommandsLayoutUsageFlagsNVX = VkFlags;
  VkObjectEntryUsageFlagsNVX = VkFlags;
  VkDescriptorUpdateTemplateCreateFlags = VkFlags;
  VkDescriptorUpdateTemplateCreateFlagsKHR = VkDescriptorUpdateTemplateCreateFlags;
  VkCompositeAlphaFlagsKHR = VkFlags;
  VkDisplayPlaneAlphaFlagsKHR = VkFlags;
  VkSurfaceTransformFlagsKHR = VkFlags;
  VkSwapchainCreateFlagsKHR = VkFlags;
  VkDisplayModeCreateFlagsKHR = VkFlags;
  VkDisplaySurfaceCreateFlagsKHR = VkFlags;
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  VkAndroidSurfaceCreateFlagsKHR = VkFlags;
  {$endif}
  {$ifdef VK_USE_PLATFORM_MIR_KHR}
  VkMirSurfaceCreateFlagsKHR = VkFlags;
  {$endif}
  {$ifdef VK_USE_PLATFORM_VI_NN}
  VkViSurfaceCreateFlagsNN = VkFlags;
  {$endif}
  {$ifdef VK_USE_PLATFORM_WAYLAND_KHR}
  VkWaylandSurfaceCreateFlagsKHR = VkFlags;
  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkWin32SurfaceCreateFlagsKHR = VkFlags;
  {$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}
  VkXlibSurfaceCreateFlagsKHR = VkFlags;
  {$endif}
  {$ifdef VK_USE_PLATFORM_XCB_KHR}
  VkXcbSurfaceCreateFlagsKHR = VkFlags;
  {$endif}
  {$ifdef VK_USE_PLATFORM_IOS_MVK}
  VkIOSSurfaceCreateFlagsMVK = VkFlags;
  {$endif}
  {$ifdef VK_USE_PLATFORM_MACOS_MVK}
  VkMacOSSurfaceCreateFlagsMVK = VkFlags;
  {$endif}
  VkPeerMemoryFeatureFlags = VkFlags;
  VkPeerMemoryFeatureFlagsKHR = VkPeerMemoryFeatureFlags;
  VkMemoryAllocateFlags = VkFlags;
  VkMemoryAllocateFlagsKHR = VkMemoryAllocateFlags;
  VkDeviceGroupPresentModeFlagsKHR = VkFlags;
  VkDebugReportFlagsEXT = VkFlags;
  VkCommandPoolTrimFlags = VkFlags;
  VkCommandPoolTrimFlagsKHR = VkCommandPoolTrimFlags;
  VkExternalMemoryHandleTypeFlagsNV = VkFlags;
  VkExternalMemoryFeatureFlagsNV = VkFlags;
  VkExternalMemoryHandleTypeFlags = VkFlags;
  VkExternalMemoryHandleTypeFlagsKHR = VkExternalMemoryHandleTypeFlags;
  VkExternalMemoryFeatureFlags = VkFlags;
  VkExternalMemoryFeatureFlagsKHR = VkExternalMemoryFeatureFlags;
  VkExternalSemaphoreHandleTypeFlags = VkFlags;
  VkExternalSemaphoreHandleTypeFlagsKHR = VkExternalSemaphoreHandleTypeFlags;
  VkExternalSemaphoreFeatureFlags = VkFlags;
  VkExternalSemaphoreFeatureFlagsKHR = VkExternalSemaphoreFeatureFlags;
  VkSemaphoreImportFlags = VkFlags;
  VkSemaphoreImportFlagsKHR = VkSemaphoreImportFlags;
  VkExternalFenceHandleTypeFlags = VkFlags;
  VkExternalFenceHandleTypeFlagsKHR = VkExternalFenceHandleTypeFlags;
  VkExternalFenceFeatureFlags = VkFlags;
  VkExternalFenceFeatureFlagsKHR = VkExternalFenceFeatureFlags;
  VkFenceImportFlags = VkFlags;
  VkFenceImportFlagsKHR = VkFenceImportFlags;
  VkSurfaceCounterFlagsEXT = VkFlags;
  VkPipelineViewportSwizzleStateCreateFlagsNV = VkFlags;
  VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;
  VkPipelineCoverageToColorStateCreateFlagsNV = VkFlags;
  VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;
  VkValidationCacheCreateFlagsEXT = VkFlags;
  VkDebugUtilsMessageSeverityFlagsEXT = VkFlags;
  VkDebugUtilsMessageTypeFlagsEXT = VkFlags;
  VkDebugUtilsMessengerCreateFlagsEXT = VkFlags;
  VkDebugUtilsMessengerCallbackDataFlagsEXT = VkFlags;
  VkPipelineRasterizationConservativeStateCreateFlagsEXT = VkFlags;
  VkDescriptorBindingFlagsEXT = VkFlags;
  VkConditionalRenderingFlagsEXT = VkFlags;
  VkInstance = nativeuint;
  VkPhysicalDevice = nativeuint;
  VkDevice = nativeuint;
  VkQueue = nativeuint;
  VkCommandBuffer = nativeuint;
  VkDeviceMemory = nativeuint;
  VkCommandPool = nativeuint;
  VkBuffer = nativeuint;
  VkBufferView = nativeuint;
  VkImage = nativeuint;
  VkImageView = nativeuint;
  VkShaderModule = nativeuint;
  VkPipeline = nativeuint;
  VkPipelineLayout = nativeuint;
  VkSampler = nativeuint;
  VkDescriptorSet = nativeuint;
  VkDescriptorSetLayout = nativeuint;
  VkDescriptorPool = nativeuint;
  VkFence = nativeuint;
  VkSemaphore = nativeuint;
  VkEvent = nativeuint;
  VkQueryPool = nativeuint;
  VkFramebuffer = nativeuint;
  VkRenderPass = nativeuint;
  VkPipelineCache = nativeuint;
  VkObjectTableNVX = nativeuint;
  VkIndirectCommandsLayoutNVX = nativeuint;
  VkDescriptorUpdateTemplate = nativeuint;
  VkDescriptorUpdateTemplateKHR = VkDescriptorUpdateTemplate;
  VkSamplerYcbcrConversion = nativeuint;
  VkSamplerYcbcrConversionKHR = VkSamplerYcbcrConversion;
  VkValidationCacheEXT = nativeuint;
  VkDisplayKHR = nativeuint;
  VkDisplayModeKHR = nativeuint;
  VkSurfaceKHR = nativeuint;
  VkSwapchainKHR = nativeuint;
  VkDebugReportCallbackEXT = nativeuint;
  VkDebugUtilsMessengerEXT = nativeuint;
  VkAttachmentLoadOp = (
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2
  );
  VkAttachmentStoreOp = (
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1
  );
  VkBlendFactor = (
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18
  );
  VkBlendOp = (
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_ZERO_EXT = 1000148000,
    VK_BLEND_OP_SRC_EXT = 1000148001,
    VK_BLEND_OP_DST_EXT = 1000148002,
    VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
    VK_BLEND_OP_DST_OVER_EXT = 1000148004,
    VK_BLEND_OP_SRC_IN_EXT = 1000148005,
    VK_BLEND_OP_DST_IN_EXT = 1000148006,
    VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
    VK_BLEND_OP_DST_OUT_EXT = 1000148008,
    VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
    VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
    VK_BLEND_OP_XOR_EXT = 1000148011,
    VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
    VK_BLEND_OP_SCREEN_EXT = 1000148013,
    VK_BLEND_OP_OVERLAY_EXT = 1000148014,
    VK_BLEND_OP_DARKEN_EXT = 1000148015,
    VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
    VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
    VK_BLEND_OP_COLORBURN_EXT = 1000148018,
    VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
    VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
    VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
    VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
    VK_BLEND_OP_INVERT_EXT = 1000148023,
    VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
    VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
    VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
    VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
    VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
    VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
    VK_BLEND_OP_HARDMIX_EXT = 1000148030,
    VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
    VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
    VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
    VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
    VK_BLEND_OP_PLUS_EXT = 1000148035,
    VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
    VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
    VK_BLEND_OP_MINUS_EXT = 1000148039,
    VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
    VK_BLEND_OP_CONTRAST_EXT = 1000148041,
    VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
    VK_BLEND_OP_RED_EXT = 1000148043,
    VK_BLEND_OP_GREEN_EXT = 1000148044,
    VK_BLEND_OP_BLUE_EXT = 1000148045
  );
  VkBorderColor = (
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5
  );
  //  VkFramebufferCreateFlagBits = ();
  //  VkQueryPoolCreateFlagBits = ();
  //  VkRenderPassCreateFlagBits = ();
  //  VkSamplerCreateFlagBits = ();
  VkPipelineCacheHeaderVersion = (
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1
  );
  //  VkPipelineLayoutCreateFlagBits = ();
  //  VkPipelineCacheCreateFlagBits = ();
  //  VkPipelineDepthStencilStateCreateFlagBits = ();
  //  VkPipelineDynamicStateCreateFlagBits = ();
  //  VkPipelineColorBlendStateCreateFlagBits = ();
  //  VkPipelineMultisampleStateCreateFlagBits = ();
  //  VkPipelineRasterizationStateCreateFlagBits = ();
  //  VkPipelineViewportStateCreateFlagBits = ();
  //  VkPipelineTessellationStateCreateFlagBits = ();
  //  VkPipelineInputAssemblyStateCreateFlagBits = ();
  //  VkPipelineVertexInputStateCreateFlagBits = ();
  //  VkPipelineShaderStageCreateFlagBits = ();
  VkDescriptorSetLayoutCreateFlagBits = (
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 10,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT_EXT = 1 shl 1
  );
  //  VkBufferViewCreateFlagBits = ();
  //  VkInstanceCreateFlagBits = ();
  VkDeviceQueueCreateFlagBits = (
    VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT = 10
  );
  VkBufferCreateFlagBits = (
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 1,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 1 shl 1,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 1 shl 2,
    VK_BUFFER_CREATE_PROTECTED_BIT = 1 shl 3
  );
  VkBufferUsageFlagBits = (
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 1,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 1 shl 1,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 1 shl 2,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 1 shl 3,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 1 shl 4,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 1 shl 5,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 1 shl 6,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 1 shl 7,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 1 shl 8,
    VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT = 1 shl 9,
    VK_BUFFER_USAGE_RESERVED_10_BIT_NV = 1 shl 10
  );
  VkColorComponentFlagBits = (
    VK_COLOR_COMPONENT_R_BIT = 1,
    VK_COLOR_COMPONENT_G_BIT = 1 shl 1,
    VK_COLOR_COMPONENT_B_BIT = 1 shl 2,
    VK_COLOR_COMPONENT_A_BIT = 1 shl 3
  );
  VkComponentSwizzle = (
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6
  );
  VkCommandPoolCreateFlagBits = (
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 1,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 1 shl 1,
    VK_COMMAND_POOL_CREATE_PROTECTED_BIT = 1 shl 2
  );
  VkCommandPoolResetFlagBits = (
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1
  );
  VkCommandBufferResetFlagBits = (
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1
  );
  VkCommandBufferLevel = (
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1
  );
  VkCommandBufferUsageFlagBits = (
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 1 shl 1,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 1 shl 2
  );
  VkCompareOp = (
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7
  );
  VkCullModeFlagBits = (
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 1,
    VK_CULL_MODE_BACK_BIT = 1 shl 1,
    VK_CULL_MODE_FRONT_AND_BACK = $00000003
  );
  VkDescriptorType = (
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10
  );
  //  VkDeviceCreateFlagBits = ();
  VkDynamicState = (
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
    VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT = 1000143000
  );
  VkFenceCreateFlagBits = (
    VK_FENCE_CREATE_SIGNALED_BIT = 1
  );
  VkPolygonMode = (
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000
  );
  VkFormat = (
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_G8B8G8R8_422_UNORM = 1000156000,
    VK_FORMAT_B8G8R8G8_422_UNORM = 1000156001,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM = 1000156002,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM = 1000156003,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM = 1000156004,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM = 1000156005,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM = 1000156006,
    VK_FORMAT_R10X6_UNORM_PACK16 = 1000156007,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16 = 1000156008,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16 = 1000156009,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16 = 1000156010,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16 = 1000156011,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16 = 1000156012,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16 = 1000156013,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16 = 1000156014,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16 = 1000156015,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16 = 1000156016,
    VK_FORMAT_R12X4_UNORM_PACK16 = 1000156017,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16 = 1000156018,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16 = 1000156019,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16 = 1000156020,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16 = 1000156021,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16 = 1000156022,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16 = 1000156023,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16 = 1000156024,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16 = 1000156025,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16 = 1000156026,
    VK_FORMAT_G16B16G16R16_422_UNORM = 1000156027,
    VK_FORMAT_B16G16R16G16_422_UNORM = 1000156028,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM = 1000156029,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM = 1000156030,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM = 1000156031,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM = 1000156032,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM = 1000156033,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    VK_FORMAT_G8B8G8R8_422_UNORM_KHR = VK_FORMAT_G8B8G8R8_422_UNORM,
    VK_FORMAT_B8G8R8G8_422_UNORM_KHR = VK_FORMAT_B8G8R8G8_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_420_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_420_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM,
    VK_FORMAT_G8_B8R8_2PLANE_422_UNORM_KHR = VK_FORMAT_G8_B8R8_2PLANE_422_UNORM,
    VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM_KHR = VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM,
    VK_FORMAT_R10X6_UNORM_PACK16_KHR = VK_FORMAT_R10X6_UNORM_PACK16,
    VK_FORMAT_R10X6G10X6_UNORM_2PACK16_KHR = VK_FORMAT_R10X6G10X6_UNORM_2PACK16,
    VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16_KHR = VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16,
    VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16,
    VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16_KHR = VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_R12X4_UNORM_PACK16_KHR = VK_FORMAT_R12X4_UNORM_PACK16,
    VK_FORMAT_R12X4G12X4_UNORM_2PACK16_KHR = VK_FORMAT_R12X4G12X4_UNORM_2PACK16,
    VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16_KHR = VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16,
    VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16,
    VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16_KHR = VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16,
    VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16_KHR = VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16,
    VK_FORMAT_G16B16G16R16_422_UNORM_KHR = VK_FORMAT_G16B16G16R16_422_UNORM,
    VK_FORMAT_B16G16R16G16_422_UNORM_KHR = VK_FORMAT_B16G16R16G16_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_420_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_420_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM,
    VK_FORMAT_G16_B16R16_2PLANE_422_UNORM_KHR = VK_FORMAT_G16_B16R16_2PLANE_422_UNORM,
    VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM_KHR = VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM
  );
  VkFormatFeatureFlagBits = (
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 1,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 1 shl 1,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 1 shl 2,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 1 shl 3,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 1 shl 4,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 1 shl 5,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 1 shl 6,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 1 shl 7,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 1 shl 8,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 1 shl 9,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 1 shl 10,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 1 shl 11,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 1 shl 12,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT = 1 shl 14,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT = 1 shl 15,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT = 1 shl 17,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT = 1 shl 18,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT = 1 shl 19,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT = 1 shl 20,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT = 1 shl 21,
    VK_FORMAT_FEATURE_DISJOINT_BIT = 1 shl 22,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT = 1 shl 23,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 1 shl 13,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_SRC_BIT,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = VK_FORMAT_FEATURE_TRANSFER_DST_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 1 shl 16,
    VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR = VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT,
    VK_FORMAT_FEATURE_DISJOINT_BIT_KHR = VK_FORMAT_FEATURE_DISJOINT_BIT,
    VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT_KHR = VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT
  );
  VkFrontFace = (
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1
  );
  VkImageAspectFlagBits = (
    VK_IMAGE_ASPECT_COLOR_BIT = 1,
    VK_IMAGE_ASPECT_DEPTH_BIT = 1 shl 1,
    VK_IMAGE_ASPECT_STENCIL_BIT = 1 shl 2,
    VK_IMAGE_ASPECT_METADATA_BIT = 1 shl 3,
    VK_IMAGE_ASPECT_PLANE_0_BIT = 1 shl 4,
    VK_IMAGE_ASPECT_PLANE_1_BIT = 1 shl 5,
    VK_IMAGE_ASPECT_PLANE_2_BIT = 1 shl 6,
    VK_IMAGE_ASPECT_PLANE_0_BIT_KHR = VK_IMAGE_ASPECT_PLANE_0_BIT,
    VK_IMAGE_ASPECT_PLANE_1_BIT_KHR = VK_IMAGE_ASPECT_PLANE_1_BIT,
    VK_IMAGE_ASPECT_PLANE_2_BIT_KHR = VK_IMAGE_ASPECT_PLANE_2_BIT
  );
  VkImageCreateFlagBits = (
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 1,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 1 shl 1,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 1 shl 2,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 1 shl 3,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 1 shl 4,
    VK_IMAGE_CREATE_ALIAS_BIT = 1 shl 10,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT = 1 shl 6,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT = 1 shl 5,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT = 1 shl 7,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT = 1 shl 8,
    VK_IMAGE_CREATE_PROTECTED_BIT = 1 shl 11,
    VK_IMAGE_CREATE_DISJOINT_BIT = 1 shl 9,
    VK_IMAGE_CREATE_RESERVED_13_BIT_NV = 1 shl 13,
    VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT_KHR = VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT,
    VK_IMAGE_CREATE_EXTENDED_USAGE_BIT_KHR = VK_IMAGE_CREATE_EXTENDED_USAGE_BIT,
    VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT = 1 shl 12,
    VK_IMAGE_CREATE_DISJOINT_BIT_KHR = VK_IMAGE_CREATE_DISJOINT_BIT,
    VK_IMAGE_CREATE_ALIAS_BIT_KHR = VK_IMAGE_CREATE_ALIAS_BIT
  );
  VkImageLayout = (
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
    VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL,
    VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL
  );
  VkImageTiling = (
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1
  );
  VkImageType = (
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2
  );
  VkImageUsageFlagBits = (
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 1 shl 1,
    VK_IMAGE_USAGE_SAMPLED_BIT = 1 shl 2,
    VK_IMAGE_USAGE_STORAGE_BIT = 1 shl 3,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 1 shl 4,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 1 shl 5,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 1 shl 6,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 1 shl 7,
    VK_IMAGE_USAGE_RESERVED_8_BIT_NV = 1 shl 8
  );
  VkImageViewType = (
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6
  );
  VkSharingMode = (
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1
  );
  VkIndexType = (
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1
  );
  VkLogicOp = (
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15
  );
  VkMemoryHeapFlagBits = (
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT = 1 shl 1,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHR = VK_MEMORY_HEAP_MULTI_INSTANCE_BIT
  );
  VkAccessFlagBits = (
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1,
    VK_ACCESS_INDEX_READ_BIT = 1 shl 1,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 1 shl 2,
    VK_ACCESS_UNIFORM_READ_BIT = 1 shl 3,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 1 shl 4,
    VK_ACCESS_SHADER_READ_BIT = 1 shl 5,
    VK_ACCESS_SHADER_WRITE_BIT = 1 shl 6,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 1 shl 7,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 1 shl 8,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 1 shl 9,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1 shl 10,
    VK_ACCESS_TRANSFER_READ_BIT = 1 shl 11,
    VK_ACCESS_TRANSFER_WRITE_BIT = 1 shl 12,
    VK_ACCESS_HOST_READ_BIT = 1 shl 13,
    VK_ACCESS_HOST_WRITE_BIT = 1 shl 14,
    VK_ACCESS_MEMORY_READ_BIT = 1 shl 15,
    VK_ACCESS_MEMORY_WRITE_BIT = 1 shl 16,
    VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT = 1 shl 20,
    VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = 1 shl 17,
    VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = 1 shl 18,
    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 1 shl 19,
    VK_ACCESS_RESERVED_23_BIT_NV = 1 shl 23,
    VK_ACCESS_RESERVED_21_BIT_NV = 1 shl 21,
    VK_ACCESS_RESERVED_22_BIT_NV = 1 shl 22
  );
  VkMemoryPropertyFlagBits = (
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 1 shl 1,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 1 shl 2,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 1 shl 3,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 1 shl 4,
    VK_MEMORY_PROPERTY_PROTECTED_BIT = 1 shl 5
  );
  VkPhysicalDeviceType = (
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4
  );
  VkPipelineBindPoint = (
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1
  );
  VkPipelineCreateFlagBits = (
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 1 shl 1,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 1 shl 2,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT = 1 shl 3,
    VK_PIPELINE_CREATE_DISPATCH_BASE = 1 shl 4,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHR = VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT,
    VK_PIPELINE_CREATE_DISPATCH_BASE_KHR = VK_PIPELINE_CREATE_DISPATCH_BASE,
    VK_PIPELINE_CREATE_RESERVED_5_BIT_NV = 1 shl 5
  );
  VkPrimitiveTopology = (
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10
  );
  VkQueryControlFlagBits = (
    VK_QUERY_CONTROL_PRECISE_BIT = 1
  );
  VkQueryPipelineStatisticFlagBits = (
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 1,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 1 shl 1,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 1 shl 2,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 1 shl 3,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 1 shl 4,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 1 shl 5,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 1 shl 6,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 1 shl 7,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 1 shl 8,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 1 shl 9,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 1 shl 10
  );
  VkQueryResultFlagBits = (
    VK_QUERY_RESULT_64_BIT = 1,
    VK_QUERY_RESULT_WAIT_BIT = 1 shl 1,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 1 shl 2,
    VK_QUERY_RESULT_PARTIAL_BIT = 1 shl 3
  );
  VkQueryType = (
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2
  );
  VkQueueFlagBits = (
    VK_QUEUE_GRAPHICS_BIT = 1,
    VK_QUEUE_COMPUTE_BIT = 1 shl 1,
    VK_QUEUE_TRANSFER_BIT = 1 shl 2,
    VK_QUEUE_SPARSE_BINDING_BIT = 1 shl 3,
    VK_QUEUE_PROTECTED_BIT = 1 shl 4
  );
  VkSubpassContents = (
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1
  );
  {
    Return codes (positive values)
}

  {
    Error codes (negative values)
}

  VkResult = (
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
    VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_ERROR_OUT_OF_POOL_MEMORY_KHR = VK_ERROR_OUT_OF_POOL_MEMORY,
    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = VK_ERROR_INVALID_EXTERNAL_HANDLE,
    VK_ERROR_FRAGMENTATION_EXT = -1000161000,
    VK_ERROR_NOT_PERMITTED_EXT = -1000174001
  );
  VkShaderStageFlagBits = (
    VK_SHADER_STAGE_VERTEX_BIT = 1,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 1 shl 1,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 1 shl 2,
    VK_SHADER_STAGE_GEOMETRY_BIT = 1 shl 3,
    VK_SHADER_STAGE_FRAGMENT_BIT = 1 shl 4,
    VK_SHADER_STAGE_COMPUTE_BIT = 1 shl 5,
    VK_SHADER_STAGE_ALL_GRAPHICS = $0000001F,
    VK_SHADER_STAGE_ALL = $7FFFFFFF,
    VK_SHADER_STAGE_RESERVED_8_BIT_NV = 1 shl 8,
    VK_SHADER_STAGE_RESERVED_9_BIT_NV = 1 shl 9,
    VK_SHADER_STAGE_RESERVED_10_BIT_NV = 1 shl 10,
    VK_SHADER_STAGE_RESERVED_11_BIT_NV = 1 shl 11,
    VK_SHADER_STAGE_RESERVED_12_BIT_NV = 1 shl 12,
    VK_SHADER_STAGE_RESERVED_13_BIT_NV = 1 shl 13,
    VK_SHADER_STAGE_RESERVED_6_BIT_NV = 1 shl 6,
    VK_SHADER_STAGE_RESERVED_7_BIT_NV = 1 shl 7
  );
  VkSparseMemoryBindFlagBits = (
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 1
  );
  VkStencilFaceFlagBits = (
    VK_STENCIL_FACE_FRONT_BIT = 1,
    VK_STENCIL_FACE_BACK_BIT = 1 shl 1,
    VK_STENCIL_FRONT_AND_BACK = $00000003
  );
  VkStencilOp = (
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7
  );
  VkStructureType = (
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES = 1000094000,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO = 1000157000,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO = 1000157001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES = 1000083000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS = 1000127000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO = 1000127001,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO = 1000060000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO = 1000060003,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO = 1000060004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO = 1000060005,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO = 1000060006,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO = 1000060013,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO = 1000060014,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES = 1000070000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO = 1000070001,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2 = 1000146000,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2 = 1000146001,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2 = 1000146002,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2 = 1000146003,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2 = 1000146004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2 = 1000059000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2 = 1000059001,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2 = 1000059002,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2 = 1000059003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2 = 1000059004,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2 = 1000059005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2 = 1000059006,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2 = 1000059007,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2 = 1000059008,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES = 1000117000,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO = 1000117001,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO = 1000117002,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO = 1000117003,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO = 1000053000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES = 1000053001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES = 1000053002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES = 1000120000,
    VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO = 1000145000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES = 1000145001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES = 1000145002,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2 = 1000145003,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO = 1000156000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO = 1000156001,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO = 1000156002,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO = 1000156003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES = 1000156004,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES = 1000156005,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO = 1000085000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO = 1000071000,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES = 1000071001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO = 1000071002,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES = 1000071003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES = 1000071004,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO = 1000072000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO = 1000072001,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO = 1000072002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO = 1000112000,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES = 1000112001,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO = 1000113000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO = 1000077000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO = 1000076000,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES = 1000076001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES = 1000168000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT = 1000168001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETER_FEATURES = 1000063000,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR = 1000060007,
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR = 1000060008,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR = 1000060009,
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR = 1000060010,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR = 1000060011,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR = 1000060012,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_NATIVE_BUFFER_ANDROID = 1000010000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CREATE_INFO_EXT = VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD = 1000018000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV = 1000026002,
    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO,
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR = 1000080000,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT = 1000081000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT = 1000081001,
    VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT = 1000081002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES,
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX = 1000086000,
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001,
    VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002,
    VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV = 1000087000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES2_EXT = VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT,
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX = 1000097000,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV = 1000098000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT = 1000099000,
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT = 1000099001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT = 1000101000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT = 1000101001,
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
    VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2_KHR = 1000109000,
    VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2_KHR = 1000109001,
    VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2_KHR = 1000109002,
    VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2_KHR = 1000109003,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2_KHR = 1000109004,
    VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO_KHR = 1000109005,
    VK_STRUCTURE_TYPE_SUBPASS_END_INFO_KHR = 1000109006,
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES,
    VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES,
    VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR = 1000121000,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR = 1000121001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR = 1000121002,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR = 1000121003,
    VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR = 1000121004,
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT = 1000128000,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT = 1000128001,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT = 1000128002,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT = 1000128003,
    VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT = 1000128004,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID = 1000129000,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID = 1000129001,
    VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID = 1000129002,
    VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129003,
    VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID = 1000129004,
    VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID = 1000129005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT = 1000130000,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
    VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT = 1000143000,
    VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT = 1000143001,
    VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT = 1000143002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT = 1000143003,
    VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT = 1000143004,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR = VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO_KHR = 1000147000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT = 1000148000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT = 1000148001,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT = 1000148002,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV = 1000149000,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV = 1000152000,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO_KHR = VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES,
    VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES_KHR = VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHR = VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO,
    VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160000,
    VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT = 1000160001,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO_EXT = 1000161000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES_EXT = 1000161001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES_EXT = 1000161002,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO_EXT = 1000161003,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT_EXT = 1000161004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES_KHR = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT_KHR = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_EXT = 1000174000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES_KHR = 1000177000,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT = 1000178000,
    VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT = 1000178001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT = 1000178002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD = 1000185000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT = 1000190000,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_EXT = 1000190001,
    VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV = 1000206000,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV = 1000206001
  );
  VkSystemAllocationScope = (
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4
  );
  VkInternalAllocationType = (
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0
  );
  {
    value="4" reserved for VK_KHR_sampler_mirror_clamp_to_edge
                enum VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE; do not
                alias!
}

  VkSamplerAddressMode = (
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4
  );
  VkFilter = (
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000
  );
  VkSamplerMipmapMode = (
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1
  );
  VkVertexInputRate = (
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1
  );
  VkPipelineStageFlagBits = (
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 1,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 1 shl 1,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 1 shl 2,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 1 shl 3,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 1 shl 4,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 1 shl 5,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 1 shl 6,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 1 shl 7,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 1 shl 8,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 1 shl 9,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1 shl 10,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 1 shl 11,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 1 shl 12,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 1 shl 13,
    VK_PIPELINE_STAGE_HOST_BIT = 1 shl 14,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 1 shl 15,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 1 shl 16,
    VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT = 1 shl 18,
    VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = 1 shl 17,
    VK_PIPELINE_STAGE_RESERVED_21_BIT_NV = 1 shl 21,
    VK_PIPELINE_STAGE_RESERVED_19_BIT_NV = 1 shl 19,
    VK_PIPELINE_STAGE_RESERVED_20_BIT_NV = 1 shl 20
  );
  VkSparseImageFormatFlagBits = (
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 1,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 1 shl 1,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 1 shl 2
  );
  VkSampleCountFlagBits = (
    VK_SAMPLE_COUNT_1_BIT = 1,
    VK_SAMPLE_COUNT_2_BIT = 1 shl 1,
    VK_SAMPLE_COUNT_4_BIT = 1 shl 2,
    VK_SAMPLE_COUNT_8_BIT = 1 shl 3,
    VK_SAMPLE_COUNT_16_BIT = 1 shl 4,
    VK_SAMPLE_COUNT_32_BIT = 1 shl 5,
    VK_SAMPLE_COUNT_64_BIT = 1 shl 6
  );
  VkAttachmentDescriptionFlagBits = (
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1
  );
  VkDescriptorPoolCreateFlagBits = (
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1,
    VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT_EXT = 1 shl 1
  );
  VkDependencyFlagBits = (
    VK_DEPENDENCY_BY_REGION_BIT = 1,
    VK_DEPENDENCY_DEVICE_GROUP_BIT = 1 shl 2,
    VK_DEPENDENCY_VIEW_LOCAL_BIT = 1 shl 1,
    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHR = VK_DEPENDENCY_VIEW_LOCAL_BIT,
    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHR = VK_DEPENDENCY_DEVICE_GROUP_BIT
  );
  VkObjectType = (
    VK_OBJECT_TYPE_UNKNOWN = 0,
    VK_OBJECT_TYPE_INSTANCE = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
    VK_OBJECT_TYPE_DEVICE = 3,
    VK_OBJECT_TYPE_QUEUE = 4,
    VK_OBJECT_TYPE_SEMAPHORE = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
    VK_OBJECT_TYPE_FENCE = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
    VK_OBJECT_TYPE_BUFFER = 9,
    VK_OBJECT_TYPE_IMAGE = 10,
    VK_OBJECT_TYPE_EVENT = 11,
    VK_OBJECT_TYPE_QUERY_POOL = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
    VK_OBJECT_TYPE_SHADER_MODULE = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
    VK_OBJECT_TYPE_RENDER_PASS = 18,
    VK_OBJECT_TYPE_PIPELINE = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
    VK_OBJECT_TYPE_SAMPLER = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
    VK_OBJECT_TYPE_COMMAND_POOL = 25,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION = 1000156000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE = 1000085000,
    VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
    VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
    VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
    VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE,
    VK_OBJECT_TYPE_OBJECT_TABLE_NVX = 1000086000,
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX = 1000086001,
    VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT = 1000128000,
    VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION,
    VK_OBJECT_TYPE_VALIDATION_CACHE_EXT = 1000160000
  );
  VkDescriptorBindingFlagBitsEXT = (
    VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT_EXT = 1,
    VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT_EXT = 1 shl 1,
    VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT_EXT = 1 shl 2,
    VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT_EXT = 1 shl 3
  );
  VkConditionalRenderingFlagBitsEXT = (
    VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT = 1
  );
  VkIndirectCommandsLayoutUsageFlagBitsNVX = (
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = 1,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = 1 shl 1,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = 1 shl 2,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = 1 shl 3
  );
  VkIndirectCommandsTokenTypeNVX = (
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX = 0,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX = 1,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX = 2,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX = 3,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX = 4,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX = 5,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX = 6,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX = 7
  );
  VkObjectEntryUsageFlagBitsNVX = (
    VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = 1,
    VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = 1 shl 1
  );
  VkObjectEntryTypeNVX = (
    VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX = 0,
    VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX = 1,
    VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX = 2,
    VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX = 3,
    VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX = 4
  );
  VkDescriptorUpdateTemplateType = (
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET = 0,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET
  );
  VkDescriptorUpdateTemplateTypeKHR = VkDescriptorUpdateTemplateType;
  VkViewportCoordinateSwizzleNV = (
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7
  );
  VkDiscardRectangleModeEXT = (
    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1
  );
  VkSubpassDescriptionFlagBits = (
    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 10,
    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 1 shl 1
  );
  VkPointClippingBehavior = (
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES = 0,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY = 1,
    VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES_KHR = VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES,
    VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY_KHR = VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY
  );
  VkPointClippingBehaviorKHR = VkPointClippingBehavior;
  VkCoverageModulationModeNV = (
    VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
    VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
    VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
    VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3
  );
  VkValidationCacheHeaderVersionEXT = (
    VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT = 1
  );
  VkShaderInfoTypeAMD = (
    VK_SHADER_INFO_TYPE_STATISTICS_AMD = 0,
    VK_SHADER_INFO_TYPE_BINARY_AMD = 1,
    VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD = 2
  );
  VkQueueGlobalPriorityEXT = (
    VK_QUEUE_GLOBAL_PRIORITY_LOW_EXT = 128,
    VK_QUEUE_GLOBAL_PRIORITY_MEDIUM_EXT = 256,
    VK_QUEUE_GLOBAL_PRIORITY_HIGH_EXT = 512,
    VK_QUEUE_GLOBAL_PRIORITY_REALTIME_EXT = 1024
  );
  VkConservativeRasterizationModeEXT = (
    VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT = 0,
    VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT = 1,
    VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT = 2
  );
  VkColorSpaceKHR = (
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLORSPACE_SRGB_NONLINEAR_KHR = VK_COLOR_SPACE_SRGB_NONLINEAR_KHR,
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = 1000104003,
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014
  );
  VkCompositeAlphaFlagBitsKHR = (
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 1 shl 1,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 1 shl 2,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 1 shl 3
  );
  VkDisplayPlaneAlphaFlagBitsKHR = (
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 1 shl 1,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 1 shl 2,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 1 shl 3
  );
  VkPresentModeKHR = (
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001
  );
  VkSurfaceTransformFlagBitsKHR = (
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 1 shl 1,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 1 shl 2,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 1 shl 3,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 1 shl 4,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 1 shl 5,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 1 shl 6,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 1 shl 7,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 1 shl 8
  );
  VkDebugReportFlagBitsEXT = (
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 1,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 1 shl 1,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 1 shl 2,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 1 shl 3,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 1 shl 4
  );
  VkDebugReportObjectTypeEXT = (
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
    VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = 31,
    VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT
  );
  VkRasterizationOrderAMD = (
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1
  );
  VkExternalMemoryHandleTypeFlagBitsNV = (
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 1,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 1 shl 1,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 1 shl 2,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 1 shl 3
  );
  VkExternalMemoryFeatureFlagBitsNV = (
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 1,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 1 shl 1,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 1 shl 2
  );
  {
    Placeholder for validation enums to be defined for VK_EXT_Validation_flags extension
}

  VkValidationCheckEXT = (
    VK_VALIDATION_CHECK_ALL_EXT = 0,
    VK_VALIDATION_CHECK_SHADERS_EXT = 1
  );
  VkExternalMemoryHandleTypeFlagBits = (
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1 shl 1,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 1 shl 2,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT = 1 shl 3,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT = 1 shl 4,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT = 1 shl 5,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT = 1 shl 6,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT = 1 shl 9,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID = 1 shl 10,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT = 1 shl 7,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT = 1 shl 8
  );
  VkExternalMemoryHandleTypeFlagBitsKHR = VkExternalMemoryHandleTypeFlagBits;
  VkExternalMemoryFeatureFlagBits = (
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT = 1,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT = 1 shl 1,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT = 1 shl 2,
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT
  );
  VkExternalMemoryFeatureFlagBitsKHR = VkExternalMemoryFeatureFlagBits;
  VkExternalSemaphoreHandleTypeFlagBits = (
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1 shl 1,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 1 shl 2,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT = 1 shl 3,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT = 1 shl 4,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT
  );
  VkExternalSemaphoreHandleTypeFlagBitsKHR = VkExternalSemaphoreHandleTypeFlagBits;
  VkExternalSemaphoreFeatureFlagBits = (
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT = 1,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT = 1 shl 1,
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT
  );
  VkExternalSemaphoreFeatureFlagBitsKHR = VkExternalSemaphoreFeatureFlagBits;
  VkSemaphoreImportFlagBits = (
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT = 1,
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = VK_SEMAPHORE_IMPORT_TEMPORARY_BIT
  );
  VkSemaphoreImportFlagBitsKHR = VkSemaphoreImportFlagBits;
  VkExternalFenceHandleTypeFlagBits = (
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT = 1,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT = 1 shl 1,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT = 1 shl 2,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT = 1 shl 3,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT
  );
  VkExternalFenceHandleTypeFlagBitsKHR = VkExternalFenceHandleTypeFlagBits;
  VkExternalFenceFeatureFlagBits = (
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT = 1,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT = 1 shl 1,
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT
  );
  VkExternalFenceFeatureFlagBitsKHR = VkExternalFenceFeatureFlagBits;
  VkFenceImportFlagBits = (
    VK_FENCE_IMPORT_TEMPORARY_BIT = 1,
    VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = VK_FENCE_IMPORT_TEMPORARY_BIT
  );
  VkFenceImportFlagBitsKHR = VkFenceImportFlagBits;
  VkSurfaceCounterFlagBitsEXT = (
    VK_SURFACE_COUNTER_VBLANK_EXT = 1
  );
  VkDisplayPowerStateEXT = (
    VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
    VK_DISPLAY_POWER_STATE_ON_EXT = 2
  );
  VkDeviceEventTypeEXT = (
    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0
  );
  VkDisplayEventTypeEXT = (
    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0
  );
  VkPeerMemoryFeatureFlagBits = (
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT = 1,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT = 1 shl 1,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT = 1 shl 2,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT = 1 shl 3,
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_COPY_DST_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHR = VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT
  );
  VkPeerMemoryFeatureFlagBitsKHR = VkPeerMemoryFeatureFlagBits;
  VkMemoryAllocateFlagBits = (
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT = 1,
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHR = VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT
  );
  VkMemoryAllocateFlagBitsKHR = VkMemoryAllocateFlagBits;
  VkDeviceGroupPresentModeFlagBitsKHR = (
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR = 1,
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR = 1 shl 1,
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR = 1 shl 2,
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR = 1 shl 3
  );
  VkSwapchainCreateFlagBitsKHR = (
    VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR = 10,
    VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR = 1 shl 1
  );
  VkSubgroupFeatureFlagBits = (
    VK_SUBGROUP_FEATURE_BASIC_BIT = 1,
    VK_SUBGROUP_FEATURE_VOTE_BIT = 1 shl 1,
    VK_SUBGROUP_FEATURE_ARITHMETIC_BIT = 1 shl 2,
    VK_SUBGROUP_FEATURE_BALLOT_BIT = 1 shl 3,
    VK_SUBGROUP_FEATURE_SHUFFLE_BIT = 1 shl 4,
    VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT = 1 shl 5,
    VK_SUBGROUP_FEATURE_CLUSTERED_BIT = 1 shl 6,
    VK_SUBGROUP_FEATURE_QUAD_BIT = 1 shl 7,
    VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = 1 shl 8
  );
  VkTessellationDomainOrigin = (
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT = 0,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT = 1,
    VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT,
    VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT_KHR = VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT
  );
  VkTessellationDomainOriginKHR = VkTessellationDomainOrigin;
  VkSamplerYcbcrModelConversion = (
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY = 0,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY = 1,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709 = 2,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601 = 3,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020 = 4,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601,
    VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020_KHR = VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020
  );
  VkSamplerYcbcrModelConversionKHR = VkSamplerYcbcrModelConversion;
  VkSamplerYcbcrRange = (
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL = 0,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW = 1,
    VK_SAMPLER_YCBCR_RANGE_ITU_FULL_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_FULL,
    VK_SAMPLER_YCBCR_RANGE_ITU_NARROW_KHR = VK_SAMPLER_YCBCR_RANGE_ITU_NARROW
  );
  VkSamplerYcbcrRangeKHR = VkSamplerYcbcrRange;
  VkChromaLocation = (
    VK_CHROMA_LOCATION_COSITED_EVEN = 0,
    VK_CHROMA_LOCATION_MIDPOINT = 1,
    VK_CHROMA_LOCATION_COSITED_EVEN_KHR = VK_CHROMA_LOCATION_COSITED_EVEN,
    VK_CHROMA_LOCATION_MIDPOINT_KHR = VK_CHROMA_LOCATION_MIDPOINT
  );
  VkChromaLocationKHR = VkChromaLocation;
  VkSamplerReductionModeEXT = (
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = 0,
    VK_SAMPLER_REDUCTION_MODE_MIN_EXT = 1,
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT = 2
  );
  VkBlendOverlapEXT = (
    VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
    VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
    VK_BLEND_OVERLAP_CONJOINT_EXT = 2
  );
  VkDebugUtilsMessageSeverityFlagBitsEXT = (
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT = 1,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT = 1 shl 4,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT = 1 shl 8,
    VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT = 1 shl 12
  );
  VkDebugUtilsMessageTypeFlagBitsEXT = (
    VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT = 1,
    VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT = 1 shl 1,
    VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT = 1 shl 2
  );
  {
    Vendor IDs are now represented as enums instead of the old
                 <vendorids> tag, allowing them to be included in the
                 API headers.
}

  VkVendorId = (
    VK_VENDOR_ID_VIV = $10001,
    VK_VENDOR_ID_VSI = $10002,
    VK_VENDOR_ID_KAZAN = $10003
  );


const
  VK_MAX_PHYSICAL_DEVICE_NAME_SIZE = 256;
  VK_UUID_SIZE = 16;
  VK_LUID_SIZE = 8;
  VK_LUID_SIZE_KHR = VK_LUID_SIZE;
  VK_MAX_EXTENSION_NAME_SIZE = 256;
  VK_MAX_DESCRIPTION_SIZE = 256;
  VK_MAX_MEMORY_TYPES = 32;
  VK_MAX_MEMORY_HEAPS = 16;
  VK_LOD_CLAMP_NONE = 1000.0;
  VK_REMAINING_MIP_LEVELS: uint32 = (not uint32(0));
  VK_REMAINING_ARRAY_LAYERS: uint32 = (not uint32(0));
  VK_WHOLE_SIZE: uint64 = (not uint64(0));
  VK_ATTACHMENT_UNUSED: uint32 = (not uint32(0));
  VK_TRUE = 1;
  VK_FALSE = 0;
  VK_QUEUE_FAMILY_IGNORED: uint32 = (not uint32(0));
  VK_QUEUE_FAMILY_EXTERNAL: uint32 = (not uint32(0))-1;
  VK_QUEUE_FAMILY_EXTERNAL_KHR: uint32 = (not uint32(0))-1;
  VK_QUEUE_FAMILY_FOREIGN_EXT: uint32 = (not uint32(0))-2;
  VK_SUBPASS_EXTERNAL: uint32 = (not uint32(0));
  VK_MAX_DEVICE_GROUP_SIZE = 32;
  VK_MAX_DEVICE_GROUP_SIZE_KHR = VK_MAX_DEVICE_GROUP_SIZE;


type
  PFN_vkInternalAllocationNotification = procedure ( pUserData: pointer; size: size_t; allocationType: VkInternalAllocationType; allocationScope: VkSystemAllocationScope );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}

  PFN_vkInternalFreeNotification = procedure ( pUserData: pointer; size: size_t; allocationType: VkInternalAllocationType; allocationScope: VkSystemAllocationScope );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}

  PFN_vkReallocationFunction = function ( pUserData: pointer; pOriginal: pointer; size: size_t; alignment: size_t; allocationScope: VkSystemAllocationScope ):pointer;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}

  PFN_vkAllocationFunction = function ( pUserData: pointer; size: size_t; alignment: size_t; allocationScope: VkSystemAllocationScope ):pointer;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}

  PFN_vkFreeFunction = procedure ( pUserData: pointer; pMemory: pointer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}

  PFN_vkDebugReportCallbackEXT = function ( flags: VkDebugReportFlagsEXT; objectType: VkDebugReportObjectTypeEXT; _object: uint64_t; location: size_t; messageCode: int32_t; pLayerPrefix: pansichar; pMessage: pansichar; pUserData: pointer ):VkBool32;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}

  VkBaseOutStructure = record
    sType: VkStructureType;
    pNext: ^VkBaseOutStructure;
  end;

  VkBaseInStructure = record
    sType: VkStructureType;
    pNext: ^VkBaseInStructure;
  end;

  VkOffset2D = record
    x: int32_t;
    y: int32_t;
  end;

  VkOffset3D = record
    x: int32_t;
    y: int32_t;
    z: int32_t;
  end;

  VkExtent2D = record
    width: uint32_t;
    height: uint32_t;
  end;

  VkExtent3D = record
    width: uint32_t;
    height: uint32_t;
    depth: uint32_t;
  end;

  VkViewport = record
    x: float;
    y: float;
    width: float;
    height: float;
    minDepth: float;
    maxDepth: float;
  end;

  VkRect2D = record
    offset: VkOffset2D;
    extent: VkExtent2D;
  end;

  VkClearRect = record
    rect: VkRect2D;
    baseArrayLayer: uint32_t;
    layerCount: uint32_t;
  end;

  VkComponentMapping = record
    r: VkComponentSwizzle;
    g: VkComponentSwizzle;
    b: VkComponentSwizzle;
    a: VkComponentSwizzle;
  end;

  VkExtensionProperties = record
    extensionName: array [0..VK_MAX_EXTENSION_NAME_SIZE-1] of TChar; // extension name
    specVersion: uint32_t; // version of the extension specification implemented
  end;

  VkLayerProperties = record
    layerName: array [0..VK_MAX_EXTENSION_NAME_SIZE-1] of TChar; // layer name
    specVersion: uint32_t; // version of the layer specification implemented
    implementationVersion: uint32_t; // build or release version of the layer's library
    description: array [0..VK_MAX_DESCRIPTION_SIZE-1] of TChar; // Free-form description of the layer
  end;

  VkApplicationInfo = record
    sType: VkStructureType;
    pNext: pointer;
    pApplicationName: pansichar;
    applicationVersion: uint32_t;
    pEngineName: pansichar;
    engineVersion: uint32_t;
    apiVersion: uint32_t;
  end;

  VkAllocationCallbacks = record
    pUserData: pointer;
    pfnAllocation: PFN_vkAllocationFunction;
    pfnReallocation: PFN_vkReallocationFunction;
    pfnFree: PFN_vkFreeFunction;
    pfnInternalAllocation: PFN_vkInternalAllocationNotification;
    pfnInternalFree: PFN_vkInternalFreeNotification;
  end;

  VkDeviceQueueCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDeviceQueueCreateFlags;
    queueFamilyIndex: uint32_t;
    queueCount: uint32_t;
    pQueuePriorities: ^float;
  end;

  TppEnabledLayerNames = TChar;
  pTppEnabledLayerNames = ^TppEnabledLayerNames;
  pppTppEnabledLayerNames = ^pTppEnabledLayerNames;
  TppEnabledExtensionNames = TChar;
  pTppEnabledExtensionNames = ^TppEnabledExtensionNames;
  pppTppEnabledExtensionNames = ^pTppEnabledExtensionNames;
  VkInstanceCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkInstanceCreateFlags;
    pApplicationInfo: ^VkApplicationInfo;
    enabledLayerCount: uint32_t;
    ppEnabledLayerNames: pppTppEnabledLayerNames; // Ordered list of layer names to be enabled
    enabledExtensionCount: uint32_t;
    ppEnabledExtensionNames: pppTppEnabledExtensionNames; // Extension names to be enabled
  end;

  VkQueueFamilyProperties = record
    queueFlags: VkQueueFlags; // Queue flags
    queueCount: uint32_t;
    timestampValidBits: uint32_t;
    minImageTransferGranularity: VkExtent3D; // Minimum alignment requirement for image transfers
  end;

  VkMemoryAllocateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    allocationSize: VkDeviceSize; // Size of memory allocation
    memoryTypeIndex: uint32_t; // Index of the of the memory type to allocate from
  end;

  VkMemoryRequirements = record
    size: VkDeviceSize; // Specified in bytes
    alignment: VkDeviceSize; // Specified in bytes
    memoryTypeBits: uint32_t; // Bitmask of the allowed memory type indices into memoryTypes[] for this object
  end;

  VkSparseImageFormatProperties = record
    aspectMask: VkImageAspectFlags;
    imageGranularity: VkExtent3D;
    flags: VkSparseImageFormatFlags;
  end;

  VkSparseImageMemoryRequirements = record
    formatProperties: VkSparseImageFormatProperties;
    imageMipTailFirstLod: uint32_t;
    imageMipTailSize: VkDeviceSize; // Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    imageMipTailOffset: VkDeviceSize; // Specified in bytes, must be a multiple of sparse block size in bytes / alignment
    imageMipTailStride: VkDeviceSize; // Specified in bytes, must be a multiple of sparse block size in bytes / alignment
  end;

  VkMemoryType = record
    propertyFlags: VkMemoryPropertyFlags; // Memory properties of this memory type
    heapIndex: uint32_t; // Index of the memory heap allocations of this memory type are taken from
  end;

  VkMemoryHeap = record
    size: VkDeviceSize; // Available memory in the heap
    flags: VkMemoryHeapFlags; // Flags for the heap
  end;

  VkMappedMemoryRange = record
    sType: VkStructureType;
    pNext: pointer;
    memory: VkDeviceMemory; // Mapped memory object
    offset: VkDeviceSize; // Offset within the memory object where the range starts
    size: VkDeviceSize; // Size of the range within the memory object
  end;

  VkFormatProperties = record
    linearTilingFeatures: VkFormatFeatureFlags; // Format features in case of linear tiling
    optimalTilingFeatures: VkFormatFeatureFlags; // Format features in case of optimal tiling
    bufferFeatures: VkFormatFeatureFlags; // Format features supported by buffers
  end;

  VkImageFormatProperties = record
    maxExtent: VkExtent3D; // max image dimensions for this resource type
    maxMipLevels: uint32_t; // max number of mipmap levels for this resource type
    maxArrayLayers: uint32_t; // max array size for this resource type
    sampleCounts: VkSampleCountFlags; // supported sample counts for this resource type
    maxResourceSize: VkDeviceSize; // max size (in bytes) of this resource type
  end;

  VkDescriptorBufferInfo = record
    buffer: VkBuffer; // Buffer used for this descriptor slot.
    offset: VkDeviceSize; // Base offset from buffer start in bytes to update in the descriptor set.
    range: VkDeviceSize; // Size in bytes of the buffer resource for this descriptor update.
  end;

  VkDescriptorImageInfo = record
    sampler: VkSampler; // Sampler to write to the descriptor in case it is a SAMPLER or COMBINED_IMAGE_SAMPLER descriptor. Ignored otherwise.
    imageView: VkImageView; // Image view to write to the descriptor in case it is a SAMPLED_IMAGE, STORAGE_IMAGE, COMBINED_IMAGE_SAMPLER, or INPUT_ATTACHMENT descriptor. Ignored otherwise.
    imageLayout: VkImageLayout; // Layout the image is expected to be in when accessed using this descriptor (only used if imageView is not VK_NULL_HANDLE).
  end;

  VkWriteDescriptorSet = record
    sType: VkStructureType;
    pNext: pointer;
    dstSet: VkDescriptorSet; // Destination descriptor set
    dstBinding: uint32_t; // Binding within the destination descriptor set to write
    dstArrayElement: uint32_t; // Array element within the destination binding to write
    descriptorCount: uint32_t; // Number of descriptors to write (determines the size of the array pointed by pDescriptors)
    descriptorType: VkDescriptorType; // Descriptor type to write (determines which members of the array pointed by pDescriptors are going to be used)
    pImageInfo: ^VkDescriptorImageInfo; // Sampler, image view, and layout for SAMPLER, COMBINED_IMAGE_SAMPLER, {SAMPLED,STORAGE}_IMAGE, and INPUT_ATTACHMENT descriptor types.
    pBufferInfo: ^VkDescriptorBufferInfo; // Raw buffer, size, and offset for {UNIFORM,STORAGE}_BUFFER[_DYNAMIC] descriptor types.
    pTexelBufferView: ^VkBufferView; // Buffer view to write to the descriptor for {UNIFORM,STORAGE}_TEXEL_BUFFER descriptor types.
  end;

  VkCopyDescriptorSet = record
    sType: VkStructureType;
    pNext: pointer;
    srcSet: VkDescriptorSet; // Source descriptor set
    srcBinding: uint32_t; // Binding within the source descriptor set to copy from
    srcArrayElement: uint32_t; // Array element within the source binding to copy from
    dstSet: VkDescriptorSet; // Destination descriptor set
    dstBinding: uint32_t; // Binding within the destination descriptor set to copy to
    dstArrayElement: uint32_t; // Array element within the destination binding to copy to
    descriptorCount: uint32_t; // Number of descriptors to write (determines the size of the array pointed by pDescriptors)
  end;

  VkBufferCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkBufferCreateFlags; // Buffer creation flags
    size: VkDeviceSize; // Specified in bytes
    usage: VkBufferUsageFlags; // Buffer usage flags
    sharingMode: VkSharingMode;
    queueFamilyIndexCount: uint32_t;
    pQueueFamilyIndices: ^uint32_t;
  end;

  VkBufferViewCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkBufferViewCreateFlags;
    buffer: VkBuffer;
    format: VkFormat; // Optionally specifies format of elements
    offset: VkDeviceSize; // Specified in bytes
    range: VkDeviceSize; // View size specified in bytes
  end;

  VkImageSubresource = record
    aspectMask: VkImageAspectFlags;
    mipLevel: uint32_t;
    arrayLayer: uint32_t;
  end;

  VkImageSubresourceLayers = record
    aspectMask: VkImageAspectFlags;
    mipLevel: uint32_t;
    baseArrayLayer: uint32_t;
    layerCount: uint32_t;
  end;

  VkImageSubresourceRange = record
    aspectMask: VkImageAspectFlags;
    baseMipLevel: uint32_t;
    levelCount: uint32_t;
    baseArrayLayer: uint32_t;
    layerCount: uint32_t;
  end;

  VkMemoryBarrier = record
    sType: VkStructureType;
    pNext: pointer;
    srcAccessMask: VkAccessFlags; // Memory accesses from the source of the dependency to synchronize
    dstAccessMask: VkAccessFlags; // Memory accesses from the destination of the dependency to synchronize
  end;

  VkBufferMemoryBarrier = record
    sType: VkStructureType;
    pNext: pointer;
    srcAccessMask: VkAccessFlags; // Memory accesses from the source of the dependency to synchronize
    dstAccessMask: VkAccessFlags; // Memory accesses from the destination of the dependency to synchronize
    srcQueueFamilyIndex: uint32_t; // Queue family to transition ownership from
    dstQueueFamilyIndex: uint32_t; // Queue family to transition ownership to
    buffer: VkBuffer; // Buffer to sync
    offset: VkDeviceSize; // Offset within the buffer to sync
    size: VkDeviceSize; // Amount of bytes to sync
  end;

  VkImageMemoryBarrier = record
    sType: VkStructureType;
    pNext: pointer;
    srcAccessMask: VkAccessFlags; // Memory accesses from the source of the dependency to synchronize
    dstAccessMask: VkAccessFlags; // Memory accesses from the destination of the dependency to synchronize
    oldLayout: VkImageLayout; // Current layout of the image
    newLayout: VkImageLayout; // New layout to transition the image to
    srcQueueFamilyIndex: uint32_t; // Queue family to transition ownership from
    dstQueueFamilyIndex: uint32_t; // Queue family to transition ownership to
    image: VkImage; // Image to sync
    subresourceRange: VkImageSubresourceRange; // Subresource range to sync
  end;

  VkImageCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkImageCreateFlags; // Image creation flags
    imageType: VkImageType;
    format: VkFormat;
    extent: VkExtent3D;
    mipLevels: uint32_t;
    arrayLayers: uint32_t;
    samples: VkSampleCountFlagBits;
    tiling: VkImageTiling;
    usage: VkImageUsageFlags; // Image usage flags
    sharingMode: VkSharingMode; // Cross-queue-family sharing mode
    queueFamilyIndexCount: uint32_t; // Number of queue families to share across
    pQueueFamilyIndices: ^uint32_t; // Array of queue family indices to share across
    initialLayout: VkImageLayout; // Initial image layout for all subresources
  end;

  VkSubresourceLayout = record
    offset: VkDeviceSize; // Specified in bytes
    size: VkDeviceSize; // Specified in bytes
    rowPitch: VkDeviceSize; // Specified in bytes
    arrayPitch: VkDeviceSize; // Specified in bytes
    depthPitch: VkDeviceSize; // Specified in bytes
  end;

  VkImageViewCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkImageViewCreateFlags;
    image: VkImage;
    viewType: VkImageViewType;
    format: VkFormat;
    components: VkComponentMapping;
    subresourceRange: VkImageSubresourceRange;
  end;

  VkBufferCopy = record
    srcOffset: VkDeviceSize; // Specified in bytes
    dstOffset: VkDeviceSize; // Specified in bytes
    size: VkDeviceSize; // Specified in bytes
  end;

  VkSparseMemoryBind = record
    resourceOffset: VkDeviceSize; // Specified in bytes
    size: VkDeviceSize; // Specified in bytes
    memory: VkDeviceMemory;
    memoryOffset: VkDeviceSize; // Specified in bytes
    flags: VkSparseMemoryBindFlags;
  end;

  VkSparseImageMemoryBind = record
    subresource: VkImageSubresource;
    offset: VkOffset3D;
    extent: VkExtent3D;
    memory: VkDeviceMemory;
    memoryOffset: VkDeviceSize; // Specified in bytes
    flags: VkSparseMemoryBindFlags;
  end;

  VkSparseBufferMemoryBindInfo = record
    buffer: VkBuffer;
    bindCount: uint32_t;
    pBinds: ^VkSparseMemoryBind;
  end;

  VkSparseImageOpaqueMemoryBindInfo = record
    image: VkImage;
    bindCount: uint32_t;
    pBinds: ^VkSparseMemoryBind;
  end;

  VkSparseImageMemoryBindInfo = record
    image: VkImage;
    bindCount: uint32_t;
    pBinds: ^VkSparseImageMemoryBind;
  end;

  VkBindSparseInfo = record
    sType: VkStructureType;
    pNext: pointer;
    waitSemaphoreCount: uint32_t;
    pWaitSemaphores: ^VkSemaphore;
    bufferBindCount: uint32_t;
    pBufferBinds: ^VkSparseBufferMemoryBindInfo;
    imageOpaqueBindCount: uint32_t;
    pImageOpaqueBinds: ^VkSparseImageOpaqueMemoryBindInfo;
    imageBindCount: uint32_t;
    pImageBinds: ^VkSparseImageMemoryBindInfo;
    signalSemaphoreCount: uint32_t;
    pSignalSemaphores: ^VkSemaphore;
  end;

  VkImageCopy = record
    srcSubresource: VkImageSubresourceLayers;
    srcOffset: VkOffset3D; // Specified in pixels for both compressed and uncompressed images
    dstSubresource: VkImageSubresourceLayers;
    dstOffset: VkOffset3D; // Specified in pixels for both compressed and uncompressed images
    extent: VkExtent3D; // Specified in pixels for both compressed and uncompressed images
  end;

  VkImageBlit = record
    srcSubresource: VkImageSubresourceLayers;
    srcOffsets: array [0..1] of VkOffset3D; // Specified in pixels for both compressed and uncompressed images
    dstSubresource: VkImageSubresourceLayers;
    dstOffsets: array [0..1] of VkOffset3D; // Specified in pixels for both compressed and uncompressed images
  end;

  VkBufferImageCopy = record
    bufferOffset: VkDeviceSize; // Specified in bytes
    bufferRowLength: uint32_t; // Specified in texels
    bufferImageHeight: uint32_t;
    imageSubresource: VkImageSubresourceLayers;
    imageOffset: VkOffset3D; // Specified in pixels for both compressed and uncompressed images
    imageExtent: VkExtent3D; // Specified in pixels for both compressed and uncompressed images
  end;

  VkImageResolve = record
    srcSubresource: VkImageSubresourceLayers;
    srcOffset: VkOffset3D;
    dstSubresource: VkImageSubresourceLayers;
    dstOffset: VkOffset3D;
    extent: VkExtent3D;
  end;

  VkShaderModuleCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkShaderModuleCreateFlags;
    codeSize: size_t; // Specified in bytes
    pCode: ^uint32_t; // Binary code of size codeSize
  end;

  VkDescriptorSetLayoutBinding = record
    binding: uint32_t; // Binding number for this entry
    descriptorType: VkDescriptorType; // Type of the descriptors in this binding
    descriptorCount: uint32_t; // Number of descriptors in this binding
    stageFlags: VkShaderStageFlags; // Shader stages this binding is visible to
    pImmutableSamplers: ^VkSampler; // Immutable samplers (used if descriptor type is SAMPLER or COMBINED_IMAGE_SAMPLER, is either NULL or contains count number of elements)
  end;

  VkDescriptorSetLayoutCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDescriptorSetLayoutCreateFlags;
    bindingCount: uint32_t; // Number of bindings in the descriptor set layout
    pBindings: ^VkDescriptorSetLayoutBinding; // Array of descriptor set layout bindings
  end;

  VkDescriptorPoolSize = record
    _type: VkDescriptorType;
    descriptorCount: uint32_t;
  end;

  VkDescriptorPoolCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDescriptorPoolCreateFlags;
    maxSets: uint32_t;
    poolSizeCount: uint32_t;
    pPoolSizes: ^VkDescriptorPoolSize;
  end;

  VkDescriptorSetAllocateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    descriptorPool: VkDescriptorPool;
    descriptorSetCount: uint32_t;
    pSetLayouts: ^VkDescriptorSetLayout;
  end;

  VkSpecializationMapEntry = record
    constantID: uint32_t; // The SpecConstant ID specified in the BIL
    offset: uint32_t; // Offset of the value in the data block
    size: size_t; // Size in bytes of the SpecConstant
  end;

  VkSpecializationInfo = record
    mapEntryCount: uint32_t; // Number of entries in the map
    pMapEntries: ^VkSpecializationMapEntry; // Array of map entries
    dataSize: size_t; // Size in bytes of pData
    pData: pointer; // Pointer to SpecConstant data
  end;

  VkPipelineShaderStageCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineShaderStageCreateFlags;
    stage: VkShaderStageFlagBits; // Shader stage
    module: VkShaderModule; // Module containing entry point
    pName: pansichar; // Null-terminated entry point name
    pSpecializationInfo: ^VkSpecializationInfo;
  end;

  VkComputePipelineCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineCreateFlags; // Pipeline creation flags
    stage: VkPipelineShaderStageCreateInfo;
    layout: VkPipelineLayout; // Interface layout of the pipeline
    basePipelineHandle: VkPipeline; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineIndex: int32_t; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
  end;

  VkVertexInputBindingDescription = record
    binding: uint32_t; // Vertex buffer binding id
    stride: uint32_t; // Distance between vertices in bytes (0 = no advancement)
    inputRate: VkVertexInputRate; // The rate at which the vertex data is consumed
  end;

  VkVertexInputAttributeDescription = record
    location: uint32_t; // location of the shader vertex attrib
    binding: uint32_t; // Vertex buffer binding id
    format: VkFormat; // format of source data
    offset: uint32_t; // Offset of first element in bytes from base of vertex
  end;

  VkPipelineVertexInputStateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineVertexInputStateCreateFlags;
    vertexBindingDescriptionCount: uint32_t; // number of bindings
    pVertexBindingDescriptions: ^VkVertexInputBindingDescription;
    vertexAttributeDescriptionCount: uint32_t; // number of attributes
    pVertexAttributeDescriptions: ^VkVertexInputAttributeDescription;
  end;

  VkPipelineInputAssemblyStateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineInputAssemblyStateCreateFlags;
    topology: VkPrimitiveTopology;
    primitiveRestartEnable: VkBool32;
  end;

  VkPipelineTessellationStateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineTessellationStateCreateFlags;
    patchControlPoints: uint32_t;
  end;

  VkPipelineViewportStateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineViewportStateCreateFlags;
    viewportCount: uint32_t;
    pViewports: ^VkViewport;
    scissorCount: uint32_t;
    pScissors: ^VkRect2D;
  end;

  VkPipelineRasterizationStateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineRasterizationStateCreateFlags;
    depthClampEnable: VkBool32;
    rasterizerDiscardEnable: VkBool32;
    polygonMode: VkPolygonMode; // optional (GL45)
    cullMode: VkCullModeFlags;
    frontFace: VkFrontFace;
    depthBiasEnable: VkBool32;
    depthBiasConstantFactor: float;
    depthBiasClamp: float;
    depthBiasSlopeFactor: float;
    lineWidth: float;
  end;

  VkPipelineMultisampleStateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineMultisampleStateCreateFlags;
    rasterizationSamples: VkSampleCountFlagBits; // Number of samples used for rasterization
    sampleShadingEnable: VkBool32; // optional (GL45)
    minSampleShading: float; // optional (GL45)
    pSampleMask: ^VkSampleMask; // Array of sampleMask words
    alphaToCoverageEnable: VkBool32;
    alphaToOneEnable: VkBool32;
  end;

  VkPipelineColorBlendAttachmentState = record
    blendEnable: VkBool32;
    srcColorBlendFactor: VkBlendFactor;
    dstColorBlendFactor: VkBlendFactor;
    colorBlendOp: VkBlendOp;
    srcAlphaBlendFactor: VkBlendFactor;
    dstAlphaBlendFactor: VkBlendFactor;
    alphaBlendOp: VkBlendOp;
    colorWriteMask: VkColorComponentFlags;
  end;

  VkPipelineColorBlendStateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineColorBlendStateCreateFlags;
    logicOpEnable: VkBool32;
    logicOp: VkLogicOp;
    attachmentCount: uint32_t; // # of pAttachments
    pAttachments: ^VkPipelineColorBlendAttachmentState;
    blendConstants: array [0..3] of float;
  end;

  VkPipelineDynamicStateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineDynamicStateCreateFlags;
    dynamicStateCount: uint32_t;
    pDynamicStates: ^VkDynamicState;
  end;

  VkStencilOpState = record
    failOp: VkStencilOp;
    passOp: VkStencilOp;
    depthFailOp: VkStencilOp;
    compareOp: VkCompareOp;
    compareMask: uint32_t;
    writeMask: uint32_t;
    reference: uint32_t;
  end;

  VkPipelineDepthStencilStateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineDepthStencilStateCreateFlags;
    depthTestEnable: VkBool32;
    depthWriteEnable: VkBool32;
    depthCompareOp: VkCompareOp;
    depthBoundsTestEnable: VkBool32; // optional (depth_bounds_test)
    stencilTestEnable: VkBool32;
    front: VkStencilOpState;
    back: VkStencilOpState;
    minDepthBounds: float;
    maxDepthBounds: float;
  end;

  VkGraphicsPipelineCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineCreateFlags; // Pipeline creation flags
    stageCount: uint32_t;
    pStages: ^VkPipelineShaderStageCreateInfo; // One entry for each active shader stage
    pVertexInputState: ^VkPipelineVertexInputStateCreateInfo;
    pInputAssemblyState: ^VkPipelineInputAssemblyStateCreateInfo;
    pTessellationState: ^VkPipelineTessellationStateCreateInfo;
    pViewportState: ^VkPipelineViewportStateCreateInfo;
    pRasterizationState: ^VkPipelineRasterizationStateCreateInfo;
    pMultisampleState: ^VkPipelineMultisampleStateCreateInfo;
    pDepthStencilState: ^VkPipelineDepthStencilStateCreateInfo;
    pColorBlendState: ^VkPipelineColorBlendStateCreateInfo;
    pDynamicState: ^VkPipelineDynamicStateCreateInfo;
    layout: VkPipelineLayout; // Interface layout of the pipeline
    renderPass: VkRenderPass;
    subpass: uint32_t;
    basePipelineHandle: VkPipeline; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is nonzero, it specifies the handle of the base pipeline this is a derivative of
    basePipelineIndex: int32_t; // If VK_PIPELINE_CREATE_DERIVATIVE_BIT is set and this value is not -1, it specifies an index into pCreateInfos of the base pipeline this is a derivative of
  end;

  VkPipelineCacheCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineCacheCreateFlags;
    initialDataSize: size_t; // Size of initial data to populate cache, in bytes
    pInitialData: pointer; // Initial data to populate cache
  end;

  VkPushConstantRange = record
    stageFlags: VkShaderStageFlags; // Which stages use the range
    offset: uint32_t; // Start of the range, in bytes
    size: uint32_t; // Size of the range, in bytes
  end;

  VkPipelineLayoutCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineLayoutCreateFlags;
    setLayoutCount: uint32_t; // Number of descriptor sets interfaced by the pipeline
    pSetLayouts: ^VkDescriptorSetLayout; // Array of setCount number of descriptor set layout objects defining the layout of the
    pushConstantRangeCount: uint32_t; // Number of push-constant ranges used by the pipeline
    pPushConstantRanges: ^VkPushConstantRange; // Array of pushConstantRangeCount number of ranges used by various shader stages
  end;

  VkSamplerCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkSamplerCreateFlags;
    magFilter: VkFilter; // Filter mode for magnification
    minFilter: VkFilter; // Filter mode for minifiation
    mipmapMode: VkSamplerMipmapMode; // Mipmap selection mode
    addressModeU: VkSamplerAddressMode;
    addressModeV: VkSamplerAddressMode;
    addressModeW: VkSamplerAddressMode;
    mipLodBias: float;
    anisotropyEnable: VkBool32;
    maxAnisotropy: float;
    compareEnable: VkBool32;
    compareOp: VkCompareOp;
    minLod: float;
    maxLod: float;
    borderColor: VkBorderColor;
    unnormalizedCoordinates: VkBool32;
  end;

  VkCommandPoolCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkCommandPoolCreateFlags; // Command pool creation flags
    queueFamilyIndex: uint32_t;
  end;

  VkCommandBufferAllocateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    commandPool: VkCommandPool;
    level: VkCommandBufferLevel;
    commandBufferCount: uint32_t;
  end;

  VkCommandBufferInheritanceInfo = record
    sType: VkStructureType;
    pNext: pointer;
    renderPass: VkRenderPass; // Render pass for secondary command buffers
    subpass: uint32_t;
    framebuffer: VkFramebuffer; // Framebuffer for secondary command buffers
    occlusionQueryEnable: VkBool32; // Whether this secondary command buffer may be executed during an occlusion query
    queryFlags: VkQueryControlFlags; // Query flags used by this secondary command buffer, if executed during an occlusion query
    pipelineStatistics: VkQueryPipelineStatisticFlags; // Pipeline statistics that may be counted for this secondary command buffer
  end;

  VkCommandBufferBeginInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkCommandBufferUsageFlags; // Command buffer usage flags
    pInheritanceInfo: ^VkCommandBufferInheritanceInfo; // Pointer to inheritance info for secondary command buffers
  end;

  VkClearColorValue = record
    case uint32 of
    0:(float32: array [0..3] of float;);
    1:(int32: array [0..3] of int32_t;);
    2:(uint32: array [0..3] of uint32_t;);
  end;

  VkClearDepthStencilValue = record
    depth: float;
    stencil: uint32_t;
  end;

  VkClearValue = record
    case uint32 of
    0:(color: VkClearColorValue;);
    1:(depthStencil: VkClearDepthStencilValue;);
  end;

  VkClearAttachment = record
    aspectMask: VkImageAspectFlags;
    colorAttachment: uint32_t;
    clearValue: VkClearValue;
  end;

  VkAttachmentDescription = record
    flags: VkAttachmentDescriptionFlags;
    format: VkFormat;
    samples: VkSampleCountFlagBits;
    loadOp: VkAttachmentLoadOp; // Load operation for color or depth data
    storeOp: VkAttachmentStoreOp; // Store operation for color or depth data
    stencilLoadOp: VkAttachmentLoadOp; // Load operation for stencil data
    stencilStoreOp: VkAttachmentStoreOp; // Store operation for stencil data
    initialLayout: VkImageLayout;
    finalLayout: VkImageLayout;
  end;

  VkAttachmentReference = record
    attachment: uint32_t;
    layout: VkImageLayout;
  end;

  VkSubpassDescription = record
    flags: VkSubpassDescriptionFlags;
    pipelineBindPoint: VkPipelineBindPoint; // Must be VK_PIPELINE_BIND_POINT_GRAPHICS for now
    inputAttachmentCount: uint32_t;
    pInputAttachments: ^VkAttachmentReference;
    colorAttachmentCount: uint32_t;
    pColorAttachments: ^VkAttachmentReference;
    pResolveAttachments: ^VkAttachmentReference;
    pDepthStencilAttachment: ^VkAttachmentReference;
    preserveAttachmentCount: uint32_t;
    pPreserveAttachments: ^uint32_t;
  end;

  VkSubpassDependency = record
    srcSubpass: uint32_t;
    dstSubpass: uint32_t;
    srcStageMask: VkPipelineStageFlags;
    dstStageMask: VkPipelineStageFlags;
    srcAccessMask: VkAccessFlags; // Memory accesses from the source of the dependency to synchronize
    dstAccessMask: VkAccessFlags; // Memory accesses from the destination of the dependency to synchronize
    dependencyFlags: VkDependencyFlags;
  end;

  VkRenderPassCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkRenderPassCreateFlags;
    attachmentCount: uint32_t;
    pAttachments: ^VkAttachmentDescription;
    subpassCount: uint32_t;
    pSubpasses: ^VkSubpassDescription;
    dependencyCount: uint32_t;
    pDependencies: ^VkSubpassDependency;
  end;

  VkEventCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkEventCreateFlags; // Event creation flags
  end;

  VkFenceCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkFenceCreateFlags; // Fence creation flags
  end;

  VkPhysicalDeviceFeatures = record
    robustBufferAccess: VkBool32; // out of bounds buffer accesses are well defined
    fullDrawIndexUint32: VkBool32; // full 32-bit range of indices for indexed draw calls
    imageCubeArray: VkBool32; // image views which are arrays of cube maps
    independentBlend: VkBool32; // blending operations are controlled per-attachment
    geometryShader: VkBool32; // geometry stage
    tessellationShader: VkBool32; // tessellation control and evaluation stage
    sampleRateShading: VkBool32; // per-sample shading and interpolation
    dualSrcBlend: VkBool32; // blend operations which take two sources
    logicOp: VkBool32; // logic operations
    multiDrawIndirect: VkBool32; // multi draw indirect
    drawIndirectFirstInstance: VkBool32; // indirect draws can use non-zero firstInstance
    depthClamp: VkBool32; // depth clamping
    depthBiasClamp: VkBool32; // depth bias clamping
    fillModeNonSolid: VkBool32; // point and wireframe fill modes
    depthBounds: VkBool32; // depth bounds test
    wideLines: VkBool32; // lines with width greater than 1
    largePoints: VkBool32; // points with size greater than 1
    alphaToOne: VkBool32; // the fragment alpha component can be forced to maximum representable alpha value
    multiViewport: VkBool32; // viewport arrays
    samplerAnisotropy: VkBool32; // anisotropic sampler filtering
    textureCompressionETC2: VkBool32; // ETC texture compression formats
    textureCompressionASTC_LDR: VkBool32; // ASTC LDR texture compression formats
    textureCompressionBC: VkBool32; // BC1-7 texture compressed formats
    occlusionQueryPrecise: VkBool32; // precise occlusion queries returning actual sample counts
    pipelineStatisticsQuery: VkBool32; // pipeline statistics query
    vertexPipelineStoresAndAtomics: VkBool32; // stores and atomic ops on storage buffers and images are supported in vertex, tessellation, and geometry stages
    fragmentStoresAndAtomics: VkBool32; // stores and atomic ops on storage buffers and images are supported in the fragment stage
    shaderTessellationAndGeometryPointSize: VkBool32; // tessellation and geometry stages can export point size
    shaderImageGatherExtended: VkBool32; // image gather with run-time values and independent offsets
    shaderStorageImageExtendedFormats: VkBool32; // the extended set of formats can be used for storage images
    shaderStorageImageMultisample: VkBool32; // multisample images can be used for storage images
    shaderStorageImageReadWithoutFormat: VkBool32; // read from storage image does not require format qualifier
    shaderStorageImageWriteWithoutFormat: VkBool32; // write to storage image does not require format qualifier
    shaderUniformBufferArrayDynamicIndexing: VkBool32; // arrays of uniform buffers can be accessed with dynamically uniform indices
    shaderSampledImageArrayDynamicIndexing: VkBool32; // arrays of sampled images can be accessed with dynamically uniform indices
    shaderStorageBufferArrayDynamicIndexing: VkBool32; // arrays of storage buffers can be accessed with dynamically uniform indices
    shaderStorageImageArrayDynamicIndexing: VkBool32; // arrays of storage images can be accessed with dynamically uniform indices
    shaderClipDistance: VkBool32; // clip distance in shaders
    shaderCullDistance: VkBool32; // cull distance in shaders
    shaderFloat64: VkBool32; // 64-bit floats (doubles) in shaders
    shaderInt64: VkBool32; // 64-bit integers in shaders
    shaderInt16: VkBool32; // 16-bit integers in shaders
    shaderResourceResidency: VkBool32; // shader can use texture operations that return resource residency information (requires sparseNonResident support)
    shaderResourceMinLod: VkBool32; // shader can use texture operations that specify minimum resource LOD
    sparseBinding: VkBool32; // Sparse resources support: Resource memory can be managed at opaque page level rather than object level
    sparseResidencyBuffer: VkBool32; // Sparse resources support: GPU can access partially resident buffers
    sparseResidencyImage2D: VkBool32; // Sparse resources support: GPU can access partially resident 2D (non-MSAA non-depth/stencil) images
    sparseResidencyImage3D: VkBool32; // Sparse resources support: GPU can access partially resident 3D images
    sparseResidency2Samples: VkBool32; // Sparse resources support: GPU can access partially resident MSAA 2D images with 2 samples
    sparseResidency4Samples: VkBool32; // Sparse resources support: GPU can access partially resident MSAA 2D images with 4 samples
    sparseResidency8Samples: VkBool32; // Sparse resources support: GPU can access partially resident MSAA 2D images with 8 samples
    sparseResidency16Samples: VkBool32; // Sparse resources support: GPU can access partially resident MSAA 2D images with 16 samples
    sparseResidencyAliased: VkBool32; // Sparse resources support: GPU can correctly access data aliased into multiple locations (opt-in)
    variableMultisampleRate: VkBool32; // multisample rate must be the same for all pipelines in a subpass
    inheritedQueries: VkBool32; // Queries may be inherited from primary to secondary command buffers
  end;

  VkPhysicalDeviceSparseProperties = record
    residencyStandard2DBlockShape: VkBool32; // Sparse resources support: GPU will access all 2D (single sample) sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyStandard2DMultisampleBlockShape: VkBool32; // Sparse resources support: GPU will access all 2D (multisample) sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyStandard3DBlockShape: VkBool32; // Sparse resources support: GPU will access all 3D sparse resources using the standard sparse image block shapes (based on pixel format)
    residencyAlignedMipSize: VkBool32; // Sparse resources support: Images with mip level dimensions that are NOT a multiple of the sparse image block dimensions will be placed in the mip tail
    residencyNonResidentStrict: VkBool32; // Sparse resources support: GPU can consistently access non-resident regions of a resource, all reads return as if data is 0, writes are discarded
  end;

  VkPhysicalDeviceLimits = record
    maxImageDimension1D: uint32_t; // max 1D image dimension
    maxImageDimension2D: uint32_t; // max 2D image dimension
    maxImageDimension3D: uint32_t; // max 3D image dimension
    maxImageDimensionCube: uint32_t; // max cubemap image dimension
    maxImageArrayLayers: uint32_t; // max layers for image arrays
    maxTexelBufferElements: uint32_t; // max texel buffer size (fstexels)
    maxUniformBufferRange: uint32_t; // max uniform buffer range (bytes)
    maxStorageBufferRange: uint32_t; // max storage buffer range (bytes)
    maxPushConstantsSize: uint32_t; // max size of the push constants pool (bytes)
    maxMemoryAllocationCount: uint32_t; // max number of device memory allocations supported
    maxSamplerAllocationCount: uint32_t; // max number of samplers that can be allocated on a device
    bufferImageGranularity: VkDeviceSize; // Granularity (in bytes) at which buffers and images can be bound to adjacent memory for simultaneous usage
    sparseAddressSpaceSize: VkDeviceSize; // Total address space available for sparse allocations (bytes)
    maxBoundDescriptorSets: uint32_t; // max number of descriptors sets that can be bound to a pipeline
    maxPerStageDescriptorSamplers: uint32_t; // max number of samplers allowed per-stage in a descriptor set
    maxPerStageDescriptorUniformBuffers: uint32_t; // max number of uniform buffers allowed per-stage in a descriptor set
    maxPerStageDescriptorStorageBuffers: uint32_t; // max number of storage buffers allowed per-stage in a descriptor set
    maxPerStageDescriptorSampledImages: uint32_t; // max number of sampled images allowed per-stage in a descriptor set
    maxPerStageDescriptorStorageImages: uint32_t; // max number of storage images allowed per-stage in a descriptor set
    maxPerStageDescriptorInputAttachments: uint32_t; // max number of input attachments allowed per-stage in a descriptor set
    maxPerStageResources: uint32_t; // max number of resources allowed by a single stage
    maxDescriptorSetSamplers: uint32_t; // max number of samplers allowed in all stages in a descriptor set
    maxDescriptorSetUniformBuffers: uint32_t; // max number of uniform buffers allowed in all stages in a descriptor set
    maxDescriptorSetUniformBuffersDynamic: uint32_t; // max number of dynamic uniform buffers allowed in all stages in a descriptor set
    maxDescriptorSetStorageBuffers: uint32_t; // max number of storage buffers allowed in all stages in a descriptor set
    maxDescriptorSetStorageBuffersDynamic: uint32_t; // max number of dynamic storage buffers allowed in all stages in a descriptor set
    maxDescriptorSetSampledImages: uint32_t; // max number of sampled images allowed in all stages in a descriptor set
    maxDescriptorSetStorageImages: uint32_t; // max number of storage images allowed in all stages in a descriptor set
    maxDescriptorSetInputAttachments: uint32_t; // max number of input attachments allowed in all stages in a descriptor set
    maxVertexInputAttributes: uint32_t; // max number of vertex input attribute slots
    maxVertexInputBindings: uint32_t; // max number of vertex input binding slots
    maxVertexInputAttributeOffset: uint32_t; // max vertex input attribute offset added to vertex buffer offset
    maxVertexInputBindingStride: uint32_t; // max vertex input binding stride
    maxVertexOutputComponents: uint32_t; // max number of output components written by vertex shader
    maxTessellationGenerationLevel: uint32_t; // max level supported by tessellation primitive generator
    maxTessellationPatchSize: uint32_t; // max patch size (vertices)
    maxTessellationControlPerVertexInputComponents: uint32_t; // max number of input components per-vertex in TCS
    maxTessellationControlPerVertexOutputComponents: uint32_t; // max number of output components per-vertex in TCS
    maxTessellationControlPerPatchOutputComponents: uint32_t; // max number of output components per-patch in TCS
    maxTessellationControlTotalOutputComponents: uint32_t; // max total number of per-vertex and per-patch output components in TCS
    maxTessellationEvaluationInputComponents: uint32_t; // max number of input components per vertex in TES
    maxTessellationEvaluationOutputComponents: uint32_t; // max number of output components per vertex in TES
    maxGeometryShaderInvocations: uint32_t; // max invocation count supported in geometry shader
    maxGeometryInputComponents: uint32_t; // max number of input components read in geometry stage
    maxGeometryOutputComponents: uint32_t; // max number of output components written in geometry stage
    maxGeometryOutputVertices: uint32_t; // max number of vertices that can be emitted in geometry stage
    maxGeometryTotalOutputComponents: uint32_t; // max total number of components (all vertices) written in geometry stage
    maxFragmentInputComponents: uint32_t; // max number of input components read in fragment stage
    maxFragmentOutputAttachments: uint32_t; // max number of output attachments written in fragment stage
    maxFragmentDualSrcAttachments: uint32_t; // max number of output attachments written when using dual source blending
    maxFragmentCombinedOutputResources: uint32_t; // max total number of storage buffers, storage images and output buffers
    maxComputeSharedMemorySize: uint32_t; // max total storage size of work group local storage (bytes)
    maxComputeWorkGroupCount: array [0..2] of uint32_t; // max num of compute work groups that may be dispatched by a single command (x,y,z)
    maxComputeWorkGroupInvocations: uint32_t; // max total compute invocations in a single local work group
    maxComputeWorkGroupSize: array [0..2] of uint32_t; // max local size of a compute work group (x,y,z)
    subPixelPrecisionBits: uint32_t; // number bits of subpixel precision in screen x and y
    subTexelPrecisionBits: uint32_t; // number bits of precision for selecting texel weights
    mipmapPrecisionBits: uint32_t; // number bits of precision for selecting mipmap weights
    maxDrawIndexedIndexValue: uint32_t; // max index value for indexed draw calls (for 32-bit indices)
    maxDrawIndirectCount: uint32_t; // max draw count for indirect draw calls
    maxSamplerLodBias: float; // max absolute sampler LOD bias
    maxSamplerAnisotropy: float; // max degree of sampler anisotropy
    maxViewports: uint32_t; // max number of active viewports
    maxViewportDimensions: array [0..1] of uint32_t; // max viewport dimensions (x,y)
    viewportBoundsRange: array [0..1] of float; // viewport bounds range (min,max)
    viewportSubPixelBits: uint32_t; // number bits of subpixel precision for viewport
    minMemoryMapAlignment: size_t; // min required alignment of pointers returned by MapMemory (bytes)
    minTexelBufferOffsetAlignment: VkDeviceSize; // min required alignment for texel buffer offsets (bytes)
    minUniformBufferOffsetAlignment: VkDeviceSize; // min required alignment for uniform buffer sizes and offsets (bytes)
    minStorageBufferOffsetAlignment: VkDeviceSize; // min required alignment for storage buffer offsets (bytes)
    minTexelOffset: int32_t; // min texel offset for OpTextureSampleOffset
    maxTexelOffset: uint32_t; // max texel offset for OpTextureSampleOffset
    minTexelGatherOffset: int32_t; // min texel offset for OpTextureGatherOffset
    maxTexelGatherOffset: uint32_t; // max texel offset for OpTextureGatherOffset
    minInterpolationOffset: float; // furthest negative offset for interpolateAtOffset
    maxInterpolationOffset: float; // furthest positive offset for interpolateAtOffset
    subPixelInterpolationOffsetBits: uint32_t; // number of subpixel bits for interpolateAtOffset
    maxFramebufferWidth: uint32_t; // max width for a framebuffer
    maxFramebufferHeight: uint32_t; // max height for a framebuffer
    maxFramebufferLayers: uint32_t; // max layer count for a layered framebuffer
    framebufferColorSampleCounts: VkSampleCountFlags; // supported color sample counts for a framebuffer
    framebufferDepthSampleCounts: VkSampleCountFlags; // supported depth sample counts for a framebuffer
    framebufferStencilSampleCounts: VkSampleCountFlags; // supported stencil sample counts for a framebuffer
    framebufferNoAttachmentsSampleCounts: VkSampleCountFlags; // supported sample counts for a framebuffer with no attachments
    maxColorAttachments: uint32_t; // max number of color attachments per subpass
    sampledImageColorSampleCounts: VkSampleCountFlags; // supported color sample counts for a non-integer sampled image
    sampledImageIntegerSampleCounts: VkSampleCountFlags; // supported sample counts for an integer image
    sampledImageDepthSampleCounts: VkSampleCountFlags; // supported depth sample counts for a sampled image
    sampledImageStencilSampleCounts: VkSampleCountFlags; // supported stencil sample counts for a sampled image
    storageImageSampleCounts: VkSampleCountFlags; // supported sample counts for a storage image
    maxSampleMaskWords: uint32_t; // max number of sample mask words
    timestampComputeAndGraphics: VkBool32; // timestamps on graphics and compute queues
    timestampPeriod: float; // number of nanoseconds it takes for timestamp query value to increment by 1
    maxClipDistances: uint32_t; // max number of clip distances
    maxCullDistances: uint32_t; // max number of cull distances
    maxCombinedClipAndCullDistances: uint32_t; // max combined number of user clipping
    discreteQueuePriorities: uint32_t; // distinct queue priorities available
    pointSizeRange: array [0..1] of float; // range (min,max) of supported point sizes
    lineWidthRange: array [0..1] of float; // range (min,max) of supported line widths
    pointSizeGranularity: float; // granularity of supported point sizes
    lineWidthGranularity: float; // granularity of supported line widths
    strictLines: VkBool32; // line rasterization follows preferred rules
    standardSampleLocations: VkBool32; // supports standard sample locations for all supported sample counts
    optimalBufferCopyOffsetAlignment: VkDeviceSize; // optimal offset of buffer copies
    optimalBufferCopyRowPitchAlignment: VkDeviceSize; // optimal pitch of buffer copies
    nonCoherentAtomSize: VkDeviceSize; // minimum size and alignment for non-coherent host-mapped device memory access
  end;

  VkSemaphoreCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkSemaphoreCreateFlags; // Semaphore creation flags
  end;

  VkQueryPoolCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkQueryPoolCreateFlags;
    queryType: VkQueryType;
    queryCount: uint32_t;
    pipelineStatistics: VkQueryPipelineStatisticFlags; // Optional
  end;

  VkFramebufferCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkFramebufferCreateFlags;
    renderPass: VkRenderPass;
    attachmentCount: uint32_t;
    pAttachments: ^VkImageView;
    width: uint32_t;
    height: uint32_t;
    layers: uint32_t;
  end;

  VkDrawIndirectCommand = record
    vertexCount: uint32_t;
    instanceCount: uint32_t;
    firstVertex: uint32_t;
    firstInstance: uint32_t;
  end;

  VkDrawIndexedIndirectCommand = record
    indexCount: uint32_t;
    instanceCount: uint32_t;
    firstIndex: uint32_t;
    vertexOffset: int32_t;
    firstInstance: uint32_t;
  end;

  VkDispatchIndirectCommand = record
    x: uint32_t;
    y: uint32_t;
    z: uint32_t;
  end;

  VkSubmitInfo = record
    sType: VkStructureType;
    pNext: pointer;
    waitSemaphoreCount: uint32_t;
    pWaitSemaphores: ^VkSemaphore;
    pWaitDstStageMask: ^VkPipelineStageFlags;
    commandBufferCount: uint32_t;
    pCommandBuffers: ^VkCommandBuffer;
    signalSemaphoreCount: uint32_t;
    pSignalSemaphores: ^VkSemaphore;
  end;

  VkDisplayPropertiesKHR = record
    display: VkDisplayKHR; // Handle of the display object
    displayName: pansichar; // Name of the display
    physicalDimensions: VkExtent2D; // In millimeters?
    physicalResolution: VkExtent2D; // Max resolution for CRT?
    supportedTransforms: VkSurfaceTransformFlagsKHR; // one or more bits from VkSurfaceTransformFlagsKHR
    planeReorderPossible: VkBool32; // VK_TRUE if the overlay plane's z-order can be changed on this display.
    persistentContent: VkBool32; // VK_TRUE if this is a "smart" display that supports self-refresh/internal buffering.
  end;

  VkDisplayPlanePropertiesKHR = record
    currentDisplay: VkDisplayKHR; // Display the plane is currently associated with.  Will be VK_NULL_HANDLE if the plane is not in use.
    currentStackIndex: uint32_t; // Current z-order of the plane.
  end;

  VkDisplayModeParametersKHR = record
    visibleRegion: VkExtent2D; // Visible scanout region.
    refreshRate: uint32_t; // Number of times per second the display is updated.
  end;

  VkDisplayModePropertiesKHR = record
    displayMode: VkDisplayModeKHR; // Handle of this display mode.
    parameters: VkDisplayModeParametersKHR; // The parameters this mode uses.
  end;

  VkDisplayModeCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDisplayModeCreateFlagsKHR;
    parameters: VkDisplayModeParametersKHR; // The parameters this mode uses.
  end;

  VkDisplayPlaneCapabilitiesKHR = record
    supportedAlpha: VkDisplayPlaneAlphaFlagsKHR; // Types of alpha blending supported, if any.
    minSrcPosition: VkOffset2D; // Does the plane have any position and extent restrictions?
    maxSrcPosition: VkOffset2D;
    minSrcExtent: VkExtent2D;
    maxSrcExtent: VkExtent2D;
    minDstPosition: VkOffset2D;
    maxDstPosition: VkOffset2D;
    minDstExtent: VkExtent2D;
    maxDstExtent: VkExtent2D;
  end;

  VkDisplaySurfaceCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDisplaySurfaceCreateFlagsKHR;
    displayMode: VkDisplayModeKHR; // The mode to use when displaying this surface
    planeIndex: uint32_t; // The plane on which this surface appears.  Must be between 0 and the value returned by vkGetPhysicalDeviceDisplayPlanePropertiesKHR() in pPropertyCount.
    planeStackIndex: uint32_t; // The z-order of the plane.
    transform: VkSurfaceTransformFlagBitsKHR; // Transform to apply to the images as part of the scanout operation
    globalAlpha: float; // Global alpha value.  Must be between 0 and 1, inclusive.  Ignored if alphaMode is not VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR
    alphaMode: VkDisplayPlaneAlphaFlagBitsKHR; // What type of alpha blending to use.  Must be a bit from vkGetDisplayPlanePropertiesKHR::supportedAlpha.
    imageExtent: VkExtent2D; // size of the images to use with this surface
  end;

  VkDisplayPresentInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    srcRect: VkRect2D; // Rectangle within the presentable image to read pixel data from when presenting to the display.
    dstRect: VkRect2D; // Rectangle within the current display mode's visible region to display srcRectangle in.
    persistent: VkBool32; // For smart displays, use buffered mode.  If the display properties member "persistentMode" is VK_FALSE, this member must always be VK_FALSE.
  end;

  VkSurfaceCapabilitiesKHR = record
    minImageCount: uint32_t; // Supported minimum number of images for the surface
    maxImageCount: uint32_t; // Supported maximum number of images for the surface, 0 for unlimited
    currentExtent: VkExtent2D; // Current image width and height for the surface, (0, 0) if undefined
    minImageExtent: VkExtent2D; // Supported minimum image width and height for the surface
    maxImageExtent: VkExtent2D; // Supported maximum image width and height for the surface
    maxImageArrayLayers: uint32_t; // Supported maximum number of image layers for the surface
    supportedTransforms: VkSurfaceTransformFlagsKHR; // 1 or more bits representing the transforms supported
    currentTransform: VkSurfaceTransformFlagBitsKHR; // The surface's current transform relative to the device's natural orientation
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR; // 1 or more bits representing the alpha compositing modes supported
    supportedUsageFlags: VkImageUsageFlags; // Supported image usage flags for the surface
  end;

  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  VkAndroidSurfaceCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkAndroidSurfaceCreateFlagsKHR;
    window: ^ANativeWindow;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_MIR_KHR}
  VkMirSurfaceCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkMirSurfaceCreateFlagsKHR;
    connection: ^MirConnection;
    mirSurface: ^MirSurface;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_VI_NN}
  VkViSurfaceCreateInfoNN = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkViSurfaceCreateFlagsNN;
    window: pointer;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WAYLAND_KHR}
  VkWaylandSurfaceCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkWaylandSurfaceCreateFlagsKHR;
    display: ^wl_display;
    surface: ^wl_surface;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkWin32SurfaceCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkWin32SurfaceCreateFlagsKHR;
    hinstance: nativeuint;
    hwnd: HWND;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}
  VkXlibSurfaceCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkXlibSurfaceCreateFlagsKHR;
    dpy: ^Display;
    window: Window;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_XCB_KHR}
  VkXcbSurfaceCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkXcbSurfaceCreateFlagsKHR;
    connection: ^xcb_connection_t;
    window: xcb_window_t;
  end;

  {$endif}
  VkSurfaceFormatKHR = record
    format: VkFormat; // Supported pair of rendering format
    colorSpace: VkColorSpaceKHR; // and color space for the surface
  end;

  VkSwapchainCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkSwapchainCreateFlagsKHR;
    surface: VkSurfaceKHR; // The swapchain's target surface
    minImageCount: uint32_t; // Minimum number of presentation images the application needs
    imageFormat: VkFormat; // Format of the presentation images
    imageColorSpace: VkColorSpaceKHR; // Colorspace of the presentation images
    imageExtent: VkExtent2D; // Dimensions of the presentation images
    imageArrayLayers: uint32_t; // Determines the number of views for multiview/stereo presentation
    imageUsage: VkImageUsageFlags; // Bits indicating how the presentation images will be used
    imageSharingMode: VkSharingMode; // Sharing mode used for the presentation images
    queueFamilyIndexCount: uint32_t; // Number of queue families having access to the images in case of concurrent sharing mode
    pQueueFamilyIndices: ^uint32_t; // Array of queue family indices having access to the images in case of concurrent sharing mode
    preTransform: VkSurfaceTransformFlagBitsKHR; // The transform, relative to the device's natural orientation, applied to the image content prior to presentation
    compositeAlpha: VkCompositeAlphaFlagBitsKHR; // The alpha blending mode used when compositing this surface with other surfaces in the window system
    presentMode: VkPresentModeKHR; // Which presentation mode to use for presents on this swap chain
    clipped: VkBool32; // Specifies whether presentable images may be affected by window clip regions
    oldSwapchain: VkSwapchainKHR; // Existing swap chain to replace, if any
  end;

  VkPresentInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    waitSemaphoreCount: uint32_t; // Number of semaphores to wait for before presenting
    pWaitSemaphores: ^VkSemaphore; // Semaphores to wait for before presenting
    swapchainCount: uint32_t; // Number of swapchains to present in this call
    pSwapchains: ^VkSwapchainKHR; // Swapchains to present an image from
    pImageIndices: ^uint32_t; // Indices of which presentable images to present
    pResults: ^VkResult; // Optional (i.e. if non-NULL) VkResult for each swapchain
  end;

  VkDebugReportCallbackCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDebugReportFlagsEXT; // Indicates which events call this callback
    pfnCallback: PFN_vkDebugReportCallbackEXT; // Function pointer of a callback function
    pUserData: pointer; // User data provided to callback function
  end;

  VkValidationFlagsEXT = record
    sType: VkStructureType; // Must be VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT
    pNext: pointer;
    disabledValidationCheckCount: uint32_t; // Number of validation checks to disable
    pDisabledValidationChecks: ^VkValidationCheckEXT; // Validation checks to disable
  end;

  VkPipelineRasterizationStateRasterizationOrderAMD = record
    sType: VkStructureType;
    pNext: pointer;
    rasterizationOrder: VkRasterizationOrderAMD; // Rasterization order to use for the pipeline
  end;

  VkDebugMarkerObjectNameInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    objectType: VkDebugReportObjectTypeEXT; // The type of the object
    _object: uint64_t; // The handle of the object, cast to uint64_t
    pObjectName: pansichar; // Name to apply to the object
  end;

  VkDebugMarkerObjectTagInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    objectType: VkDebugReportObjectTypeEXT; // The type of the object
    _object: uint64_t; // The handle of the object, cast to uint64_t
    tagName: uint64_t; // The name of the tag to set on the object
    tagSize: size_t; // The length in bytes of the tag data
    pTag: pointer; // Tag data to attach to the object
  end;

  VkDebugMarkerMarkerInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    pMarkerName: pansichar; // Name of the debug marker
    color: array [0..3] of float; // Optional color for debug marker
  end;

  VkDedicatedAllocationImageCreateInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    dedicatedAllocation: VkBool32; // Whether this image uses a dedicated allocation
  end;

  VkDedicatedAllocationBufferCreateInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    dedicatedAllocation: VkBool32; // Whether this buffer uses a dedicated allocation
  end;

  VkDedicatedAllocationMemoryAllocateInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    image: VkImage; // Image that this allocation will be bound to
    buffer: VkBuffer; // Buffer that this allocation will be bound to
  end;

  VkExternalImageFormatPropertiesNV = record
    imageFormatProperties: VkImageFormatProperties;
    externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV;
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV;
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV;
  end;

  VkExternalMemoryImageCreateInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    handleTypes: VkExternalMemoryHandleTypeFlagsNV;
  end;

  VkExportMemoryAllocateInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    handleTypes: VkExternalMemoryHandleTypeFlagsNV;
  end;

  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkImportMemoryWin32HandleInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    handleType: VkExternalMemoryHandleTypeFlagsNV;
    handle: THandle;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkExportMemoryWin32HandleInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    pAttributes: ^SECURITY_ATTRIBUTES;
    dwAccess: DWORD;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkWin32KeyedMutexAcquireReleaseInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    acquireCount: uint32_t;
    pAcquireSyncs: ^VkDeviceMemory;
    pAcquireKeys: ^uint64_t;
    pAcquireTimeoutMilliseconds: ^uint32_t;
    releaseCount: uint32_t;
    pReleaseSyncs: ^VkDeviceMemory;
    pReleaseKeys: ^uint64_t;
  end;

  {$endif}
  VkDeviceGeneratedCommandsFeaturesNVX = record
    sType: VkStructureType;
    pNext: pointer;
    computeBindingPointSupport: VkBool32;
  end;

  VkDeviceGeneratedCommandsLimitsNVX = record
    sType: VkStructureType;
    pNext: pointer;
    maxIndirectCommandsLayoutTokenCount: uint32_t;
    maxObjectEntryCounts: uint32_t;
    minSequenceCountBufferOffsetAlignment: uint32_t;
    minSequenceIndexBufferOffsetAlignment: uint32_t;
    minCommandsTokenBufferOffsetAlignment: uint32_t;
  end;

  VkIndirectCommandsTokenNVX = record
    tokenType: VkIndirectCommandsTokenTypeNVX;
    buffer: VkBuffer; // buffer containing tableEntries and additional data for indirectCommands
    offset: VkDeviceSize; // offset from the base address of the buffer
  end;

  VkIndirectCommandsLayoutTokenNVX = record
    tokenType: VkIndirectCommandsTokenTypeNVX;
    bindingUnit: uint32_t; // Binding unit for vertex attribute / descriptor set, offset for pushconstants
    dynamicCount: uint32_t; // Number of variable dynamic values for descriptor set / push constants
    divisor: uint32_t; // Rate the which the array is advanced per element (must be power of 2, minimum 1)
  end;

  VkIndirectCommandsLayoutCreateInfoNVX = record
    sType: VkStructureType;
    pNext: pointer;
    pipelineBindPoint: VkPipelineBindPoint;
    flags: VkIndirectCommandsLayoutUsageFlagsNVX;
    tokenCount: uint32_t;
    pTokens: ^VkIndirectCommandsLayoutTokenNVX;
  end;

  VkCmdProcessCommandsInfoNVX = record
    sType: VkStructureType;
    pNext: pointer;
    objectTable: VkObjectTableNVX;
    indirectCommandsLayout: VkIndirectCommandsLayoutNVX;
    indirectCommandsTokenCount: uint32_t;
    pIndirectCommandsTokens: ^VkIndirectCommandsTokenNVX;
    maxSequencesCount: uint32_t;
    targetCommandBuffer: VkCommandBuffer;
    sequencesCountBuffer: VkBuffer;
    sequencesCountOffset: VkDeviceSize;
    sequencesIndexBuffer: VkBuffer;
    sequencesIndexOffset: VkDeviceSize;
  end;

  VkCmdReserveSpaceForCommandsInfoNVX = record
    sType: VkStructureType;
    pNext: pointer;
    objectTable: VkObjectTableNVX;
    indirectCommandsLayout: VkIndirectCommandsLayoutNVX;
    maxSequencesCount: uint32_t;
  end;

  VkObjectTableCreateInfoNVX = record
    sType: VkStructureType;
    pNext: pointer;
    objectCount: uint32_t;
    pObjectEntryTypes: ^VkObjectEntryTypeNVX;
    pObjectEntryCounts: ^uint32_t;
    pObjectEntryUsageFlags: ^VkObjectEntryUsageFlagsNVX;
    maxUniformBuffersPerDescriptor: uint32_t;
    maxStorageBuffersPerDescriptor: uint32_t;
    maxStorageImagesPerDescriptor: uint32_t;
    maxSampledImagesPerDescriptor: uint32_t;
    maxPipelineLayouts: uint32_t;
  end;

  VkObjectTableEntryNVX = record
    _type: VkObjectEntryTypeNVX;
    flags: VkObjectEntryUsageFlagsNVX;
  end;

  VkObjectTablePipelineEntryNVX = record
    _type: VkObjectEntryTypeNVX;
    flags: VkObjectEntryUsageFlagsNVX;
    pipeline: VkPipeline;
  end;

  VkObjectTableDescriptorSetEntryNVX = record
    _type: VkObjectEntryTypeNVX;
    flags: VkObjectEntryUsageFlagsNVX;
    pipelineLayout: VkPipelineLayout;
    descriptorSet: VkDescriptorSet;
  end;

  VkObjectTableVertexBufferEntryNVX = record
    _type: VkObjectEntryTypeNVX;
    flags: VkObjectEntryUsageFlagsNVX;
    buffer: VkBuffer;
  end;

  VkObjectTableIndexBufferEntryNVX = record
    _type: VkObjectEntryTypeNVX;
    flags: VkObjectEntryUsageFlagsNVX;
    buffer: VkBuffer;
    indexType: VkIndexType;
  end;

  VkObjectTablePushConstantEntryNVX = record
    _type: VkObjectEntryTypeNVX;
    flags: VkObjectEntryUsageFlagsNVX;
    pipelineLayout: VkPipelineLayout;
    stageFlags: VkShaderStageFlags;
  end;

  VkPhysicalDeviceFeatures2 = record
    sType: VkStructureType;
    pNext: pointer;
    features: VkPhysicalDeviceFeatures;
  end;

  VkFormatProperties2 = record
    sType: VkStructureType;
    pNext: pointer;
    formatProperties: VkFormatProperties;
  end;

  VkImageFormatProperties2 = record
    sType: VkStructureType;
    pNext: pointer;
    imageFormatProperties: VkImageFormatProperties;
  end;

  VkPhysicalDeviceImageFormatInfo2 = record
    sType: VkStructureType;
    pNext: pointer;
    format: VkFormat;
    _type: VkImageType;
    tiling: VkImageTiling;
    usage: VkImageUsageFlags;
    flags: VkImageCreateFlags;
  end;

  VkQueueFamilyProperties2 = record
    sType: VkStructureType;
    pNext: pointer;
    queueFamilyProperties: VkQueueFamilyProperties;
  end;

  VkSparseImageFormatProperties2 = record
    sType: VkStructureType;
    pNext: pointer;
    properties: VkSparseImageFormatProperties;
  end;

  VkPhysicalDeviceSparseImageFormatInfo2 = record
    sType: VkStructureType;
    pNext: pointer;
    format: VkFormat;
    _type: VkImageType;
    samples: VkSampleCountFlagBits;
    usage: VkImageUsageFlags;
    tiling: VkImageTiling;
  end;

  VkPhysicalDevicePushDescriptorPropertiesKHR = record
    sType: VkStructureType;
    pNext: pointer;
    maxPushDescriptors: uint32_t;
  end;

  VkRectLayerKHR = record
    offset: VkOffset2D; // upper-left corner of a rectangle that has not changed, in pixels of a presentation images
    extent: VkExtent2D; // Dimensions of a rectangle that has not changed, in pixels of a presentation images
    layer: uint32_t; // Layer of a swapchain's image(s), for stereoscopic-3D images
  end;

  VkPhysicalDeviceVariablePointerFeatures = record
    sType: VkStructureType;
    pNext: pointer;
    variablePointersStorageBuffer: VkBool32;
    variablePointers: VkBool32;
  end;

  VkExternalMemoryProperties = record
    externalMemoryFeatures: VkExternalMemoryFeatureFlags;
    exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlags;
    compatibleHandleTypes: VkExternalMemoryHandleTypeFlags;
  end;

  VkPhysicalDeviceExternalImageFormatInfo = record
    sType: VkStructureType;
    pNext: pointer;
    handleType: VkExternalMemoryHandleTypeFlagBits;
  end;

  VkExternalImageFormatProperties = record
    sType: VkStructureType;
    pNext: pointer;
    externalMemoryProperties: VkExternalMemoryProperties;
  end;

  VkPhysicalDeviceExternalBufferInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkBufferCreateFlags;
    usage: VkBufferUsageFlags;
    handleType: VkExternalMemoryHandleTypeFlagBits;
  end;

  VkExternalBufferProperties = record
    sType: VkStructureType;
    pNext: pointer;
    externalMemoryProperties: VkExternalMemoryProperties;
  end;

  VkPhysicalDeviceIDProperties = record
    sType: VkStructureType;
    pNext: pointer;
    deviceUUID: array [0..VK_UUID_SIZE-1] of uint8_t;
    driverUUID: array [0..VK_UUID_SIZE-1] of uint8_t;
    deviceLUID: array [0..VK_LUID_SIZE-1] of uint8_t;
    deviceNodeMask: uint32_t;
    deviceLUIDValid: VkBool32;
  end;

  VkExternalMemoryImageCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    handleTypes: VkExternalMemoryHandleTypeFlags;
  end;

  VkExternalMemoryBufferCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    handleTypes: VkExternalMemoryHandleTypeFlags;
  end;

  VkExportMemoryAllocateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    handleTypes: VkExternalMemoryHandleTypeFlags;
  end;

  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkImportMemoryWin32HandleInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    handleType: VkExternalMemoryHandleTypeFlagBits;
    handle: THandle;
    name: LPCWSTR;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkExportMemoryWin32HandleInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    pAttributes: ^SECURITY_ATTRIBUTES;
    dwAccess: DWORD;
    name: LPCWSTR;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkMemoryWin32HandlePropertiesKHR = record
    sType: VkStructureType;
    pNext: pointer;
    memoryTypeBits: uint32_t;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkMemoryGetWin32HandleInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    memory: VkDeviceMemory;
    handleType: VkExternalMemoryHandleTypeFlagBits;
  end;

  {$endif}
  VkImportMemoryFdInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    handleType: VkExternalMemoryHandleTypeFlagBits;
    fd: integer;
  end;

  VkMemoryFdPropertiesKHR = record
    sType: VkStructureType;
    pNext: pointer;
    memoryTypeBits: uint32_t;
  end;

  VkMemoryGetFdInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    memory: VkDeviceMemory;
    handleType: VkExternalMemoryHandleTypeFlagBits;
  end;

  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkWin32KeyedMutexAcquireReleaseInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    acquireCount: uint32_t;
    pAcquireSyncs: ^VkDeviceMemory;
    pAcquireKeys: ^uint64_t;
    pAcquireTimeouts: ^uint32_t;
    releaseCount: uint32_t;
    pReleaseSyncs: ^VkDeviceMemory;
    pReleaseKeys: ^uint64_t;
  end;

  {$endif}
  VkPhysicalDeviceExternalSemaphoreInfo = record
    sType: VkStructureType;
    pNext: pointer;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
  end;

  VkExternalSemaphoreProperties = record
    sType: VkStructureType;
    pNext: pointer;
    exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlags;
    compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlags;
    externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlags;
  end;

  VkExportSemaphoreCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    handleTypes: VkExternalSemaphoreHandleTypeFlags;
  end;

  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkImportSemaphoreWin32HandleInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    semaphore: VkSemaphore;
    flags: VkSemaphoreImportFlags;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
    handle: THandle;
    name: LPCWSTR;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkExportSemaphoreWin32HandleInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    pAttributes: ^SECURITY_ATTRIBUTES;
    dwAccess: DWORD;
    name: LPCWSTR;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkD3D12FenceSubmitInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    waitSemaphoreValuesCount: uint32_t;
    pWaitSemaphoreValues: ^uint64_t;
    signalSemaphoreValuesCount: uint32_t;
    pSignalSemaphoreValues: ^uint64_t;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkSemaphoreGetWin32HandleInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    semaphore: VkSemaphore;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
  end;

  {$endif}
  VkImportSemaphoreFdInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    semaphore: VkSemaphore;
    flags: VkSemaphoreImportFlags;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
    fd: integer;
  end;

  VkSemaphoreGetFdInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    semaphore: VkSemaphore;
    handleType: VkExternalSemaphoreHandleTypeFlagBits;
  end;

  VkPhysicalDeviceExternalFenceInfo = record
    sType: VkStructureType;
    pNext: pointer;
    handleType: VkExternalFenceHandleTypeFlagBits;
  end;

  VkExternalFenceProperties = record
    sType: VkStructureType;
    pNext: pointer;
    exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlags;
    compatibleHandleTypes: VkExternalFenceHandleTypeFlags;
    externalFenceFeatures: VkExternalFenceFeatureFlags;
  end;

  VkExportFenceCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    handleTypes: VkExternalFenceHandleTypeFlags;
  end;

  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkImportFenceWin32HandleInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    fence: VkFence;
    flags: VkFenceImportFlags;
    handleType: VkExternalFenceHandleTypeFlagBits;
    handle: THandle;
    name: LPCWSTR;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkExportFenceWin32HandleInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    pAttributes: ^SECURITY_ATTRIBUTES;
    dwAccess: DWORD;
    name: LPCWSTR;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}
  VkFenceGetWin32HandleInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    fence: VkFence;
    handleType: VkExternalFenceHandleTypeFlagBits;
  end;

  {$endif}
  VkImportFenceFdInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    fence: VkFence;
    flags: VkFenceImportFlags;
    handleType: VkExternalFenceHandleTypeFlagBits;
    fd: integer;
  end;

  VkFenceGetFdInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    fence: VkFence;
    handleType: VkExternalFenceHandleTypeFlagBits;
  end;

  VkPhysicalDeviceMultiviewFeatures = record
    sType: VkStructureType;
    pNext: pointer;
    multiview: VkBool32; // Multiple views in a renderpass
    multiviewGeometryShader: VkBool32; // Multiple views in a renderpass w/ geometry shader
    multiviewTessellationShader: VkBool32; // Multiple views in a renderpass w/ tessellation shader
  end;

  VkPhysicalDeviceMultiviewProperties = record
    sType: VkStructureType;
    pNext: pointer;
    maxMultiviewViewCount: uint32_t; // max number of views in a subpass
    maxMultiviewInstanceIndex: uint32_t; // max instance index for a draw in a multiview subpass
  end;

  VkRenderPassMultiviewCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    subpassCount: uint32_t;
    pViewMasks: ^uint32_t;
    dependencyCount: uint32_t;
    pViewOffsets: ^int32_t;
    correlationMaskCount: uint32_t;
    pCorrelationMasks: ^uint32_t;
  end;

  VkSurfaceCapabilities2EXT = record
    sType: VkStructureType;
    pNext: pointer;
    minImageCount: uint32_t; // Supported minimum number of images for the surface
    maxImageCount: uint32_t; // Supported maximum number of images for the surface, 0 for unlimited
    currentExtent: VkExtent2D; // Current image width and height for the surface, (0, 0) if undefined
    minImageExtent: VkExtent2D; // Supported minimum image width and height for the surface
    maxImageExtent: VkExtent2D; // Supported maximum image width and height for the surface
    maxImageArrayLayers: uint32_t; // Supported maximum number of image layers for the surface
    supportedTransforms: VkSurfaceTransformFlagsKHR; // 1 or more bits representing the transforms supported
    currentTransform: VkSurfaceTransformFlagBitsKHR; // The surface's current transform relative to the device's natural orientation
    supportedCompositeAlpha: VkCompositeAlphaFlagsKHR; // 1 or more bits representing the alpha compositing modes supported
    supportedUsageFlags: VkImageUsageFlags; // Supported image usage flags for the surface
    supportedSurfaceCounters: VkSurfaceCounterFlagsEXT;
  end;

  VkDisplayPowerInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    powerState: VkDisplayPowerStateEXT;
  end;

  VkDeviceEventInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    deviceEvent: VkDeviceEventTypeEXT;
  end;

  VkDisplayEventInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    displayEvent: VkDisplayEventTypeEXT;
  end;

  VkSwapchainCounterCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    surfaceCounters: VkSurfaceCounterFlagsEXT;
  end;

  VkPhysicalDeviceGroupProperties = record
    sType: VkStructureType;
    pNext: pointer;
    physicalDeviceCount: uint32_t;
    physicalDevices: array [0..VK_MAX_DEVICE_GROUP_SIZE-1] of VkPhysicalDevice;
    subsetAllocation: VkBool32;
  end;

  VkMemoryAllocateFlagsInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkMemoryAllocateFlags;
    deviceMask: uint32_t;
  end;

  VkBindBufferMemoryInfo = record
    sType: VkStructureType;
    pNext: pointer;
    buffer: VkBuffer;
    memory: VkDeviceMemory;
    memoryOffset: VkDeviceSize;
  end;

  VkBindBufferMemoryDeviceGroupInfo = record
    sType: VkStructureType;
    pNext: pointer;
    deviceIndexCount: uint32_t;
    pDeviceIndices: ^uint32_t;
  end;

  VkBindImageMemoryInfo = record
    sType: VkStructureType;
    pNext: pointer;
    image: VkImage;
    memory: VkDeviceMemory;
    memoryOffset: VkDeviceSize;
  end;

  VkBindImageMemoryDeviceGroupInfo = record
    sType: VkStructureType;
    pNext: pointer;
    deviceIndexCount: uint32_t;
    pDeviceIndices: ^uint32_t;
    splitInstanceBindRegionCount: uint32_t;
    pSplitInstanceBindRegions: ^VkRect2D;
  end;

  VkDeviceGroupRenderPassBeginInfo = record
    sType: VkStructureType;
    pNext: pointer;
    deviceMask: uint32_t;
    deviceRenderAreaCount: uint32_t;
    pDeviceRenderAreas: ^VkRect2D;
  end;

  VkDeviceGroupCommandBufferBeginInfo = record
    sType: VkStructureType;
    pNext: pointer;
    deviceMask: uint32_t;
  end;

  VkDeviceGroupSubmitInfo = record
    sType: VkStructureType;
    pNext: pointer;
    waitSemaphoreCount: uint32_t;
    pWaitSemaphoreDeviceIndices: ^uint32_t;
    commandBufferCount: uint32_t;
    pCommandBufferDeviceMasks: ^uint32_t;
    signalSemaphoreCount: uint32_t;
    pSignalSemaphoreDeviceIndices: ^uint32_t;
  end;

  VkDeviceGroupBindSparseInfo = record
    sType: VkStructureType;
    pNext: pointer;
    resourceDeviceIndex: uint32_t;
    memoryDeviceIndex: uint32_t;
  end;

  VkDeviceGroupPresentCapabilitiesKHR = record
    sType: VkStructureType;
    pNext: pointer;
    presentMask: array [0..VK_MAX_DEVICE_GROUP_SIZE-1] of uint32_t;
    modes: VkDeviceGroupPresentModeFlagsKHR;
  end;

  VkImageSwapchainCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    swapchain: VkSwapchainKHR;
  end;

  VkBindImageMemorySwapchainInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    swapchain: VkSwapchainKHR;
    imageIndex: uint32_t;
  end;

  VkAcquireNextImageInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    swapchain: VkSwapchainKHR;
    timeout: uint64_t;
    semaphore: VkSemaphore;
    fence: VkFence;
    deviceMask: uint32_t;
  end;

  VkDeviceGroupPresentInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    swapchainCount: uint32_t;
    pDeviceMasks: ^uint32_t;
    mode: VkDeviceGroupPresentModeFlagBitsKHR;
  end;

  VkDeviceGroupDeviceCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    physicalDeviceCount: uint32_t;
    pPhysicalDevices: ^VkPhysicalDevice;
  end;

  VkDeviceGroupSwapchainCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    modes: VkDeviceGroupPresentModeFlagsKHR;
  end;

  VkDescriptorUpdateTemplateEntry = record
    dstBinding: uint32_t; // Binding within the destination descriptor set to write
    dstArrayElement: uint32_t; // Array element within the destination binding to write
    descriptorCount: uint32_t; // Number of descriptors to write
    descriptorType: VkDescriptorType; // Descriptor type to write
    offset: size_t; // Offset into pData where the descriptors to update are stored
    stride: size_t; // Stride between two descriptors in pData when writing more than one descriptor
  end;

  VkDescriptorUpdateTemplateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDescriptorUpdateTemplateCreateFlags;
    descriptorUpdateEntryCount: uint32_t; // Number of descriptor update entries to use for the update template
    pDescriptorUpdateEntries: ^VkDescriptorUpdateTemplateEntry; // Descriptor update entries for the template
    templateType: VkDescriptorUpdateTemplateType;
    descriptorSetLayout: VkDescriptorSetLayout;
    pipelineBindPoint: VkPipelineBindPoint;
    pipelineLayout: VkPipelineLayout; // If used for push descriptors, this is the only allowed layout
    _set: uint32_t;
  end;

  VkXYColorEXT = record
    x: float;
    y: float;
  end;

  VkHdrMetadataEXT = record
    sType: VkStructureType;
    pNext: pointer;
    displayPrimaryRed: VkXYColorEXT; // Display primary's Red
    displayPrimaryGreen: VkXYColorEXT; // Display primary's Green
    displayPrimaryBlue: VkXYColorEXT; // Display primary's Blue
    whitePoint: VkXYColorEXT; // Display primary's Blue
    maxLuminance: float; // Display maximum luminance
    minLuminance: float; // Display minimum luminance
    maxContentLightLevel: float; // Content maximum luminance
    maxFrameAverageLightLevel: float;
  end;

  VkRefreshCycleDurationGOOGLE = record
    refreshDuration: uint64_t; // Number of nanoseconds from the start of one refresh cycle to the next
  end;

  VkPastPresentationTimingGOOGLE = record
    presentID: uint32_t; // Application-provided identifier, previously given to vkQueuePresentKHR
    desiredPresentTime: uint64_t; // Earliest time an image should have been presented, previously given to vkQueuePresentKHR
    actualPresentTime: uint64_t; // Time the image was actually displayed
    earliestPresentTime: uint64_t; // Earliest time the image could have been displayed
    presentMargin: uint64_t; // How early vkQueuePresentKHR was processed vs. how soon it needed to be and make earliestPresentTime
  end;

  VkPresentTimeGOOGLE = record
    presentID: uint32_t; // Application-provided identifier
    desiredPresentTime: uint64_t; // Earliest time an image should be presented
  end;

  {$ifdef VK_USE_PLATFORM_IOS_MVK}
  VkIOSSurfaceCreateInfoMVK = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkIOSSurfaceCreateFlagsMVK;
    pView: pointer;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_MACOS_MVK}
  VkMacOSSurfaceCreateInfoMVK = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkMacOSSurfaceCreateFlagsMVK;
    pView: pointer;
  end;

  {$endif}
  VkViewportWScalingNV = record
    xcoeff: float;
    ycoeff: float;
  end;

  VkPipelineViewportWScalingStateCreateInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    viewportWScalingEnable: VkBool32;
    viewportCount: uint32_t;
    pViewportWScalings: ^VkViewportWScalingNV;
  end;

  VkViewportSwizzleNV = record
    x: VkViewportCoordinateSwizzleNV;
    y: VkViewportCoordinateSwizzleNV;
    z: VkViewportCoordinateSwizzleNV;
    w: VkViewportCoordinateSwizzleNV;
  end;

  VkPipelineViewportSwizzleStateCreateInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineViewportSwizzleStateCreateFlagsNV;
    viewportCount: uint32_t;
    pViewportSwizzles: ^VkViewportSwizzleNV;
  end;

  VkPhysicalDeviceDiscardRectanglePropertiesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    maxDiscardRectangles: uint32_t; // max number of active discard rectangles
  end;

  VkPipelineDiscardRectangleStateCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineDiscardRectangleStateCreateFlagsEXT;
    discardRectangleMode: VkDiscardRectangleModeEXT;
    discardRectangleCount: uint32_t;
    pDiscardRectangles: ^VkRect2D;
  end;

  VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX = record
    sType: VkStructureType;
    pNext: pointer;
    perViewPositionAllComponents: VkBool32;
  end;

  VkInputAttachmentAspectReference = record
    subpass: uint32_t;
    inputAttachmentIndex: uint32_t;
    aspectMask: VkImageAspectFlags;
  end;

  VkRenderPassInputAttachmentAspectCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    aspectReferenceCount: uint32_t;
    pAspectReferences: ^VkInputAttachmentAspectReference;
  end;

  VkPhysicalDeviceSurfaceInfo2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    surface: VkSurfaceKHR;
  end;

  VkSurfaceCapabilities2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    surfaceCapabilities: VkSurfaceCapabilitiesKHR;
  end;

  VkSurfaceFormat2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    surfaceFormat: VkSurfaceFormatKHR;
  end;

  VkDisplayProperties2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    displayProperties: VkDisplayPropertiesKHR;
  end;

  VkDisplayPlaneProperties2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    displayPlaneProperties: VkDisplayPlanePropertiesKHR;
  end;

  VkDisplayModeProperties2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    displayModeProperties: VkDisplayModePropertiesKHR;
  end;

  VkDisplayPlaneInfo2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    mode: VkDisplayModeKHR;
    planeIndex: uint32_t;
  end;

  VkDisplayPlaneCapabilities2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    capabilities: VkDisplayPlaneCapabilitiesKHR;
  end;

  VkSharedPresentSurfaceCapabilitiesKHR = record
    sType: VkStructureType;
    pNext: pointer;
    sharedPresentSupportedUsageFlags: VkImageUsageFlags; // Supported image usage flags if swapchain created using a shared present mode
  end;

  VkPhysicalDevice16BitStorageFeatures = record
    sType: VkStructureType;
    pNext: pointer;
    storageBuffer16BitAccess: VkBool32; // 16-bit integer/floating-point variables supported in BufferBlock
    uniformAndStorageBuffer16BitAccess: VkBool32; // 16-bit integer/floating-point variables supported in BufferBlock and Block
    storagePushConstant16: VkBool32; // 16-bit integer/floating-point variables supported in PushConstant
    storageInputOutput16: VkBool32; // 16-bit integer/floating-point variables supported in shader inputs and outputs
  end;

  VkPhysicalDeviceSubgroupProperties = record
    sType: VkStructureType;
    pNext: pointer;
    subgroupSize: uint32_t; // The size of a subgroup for this queue.
    supportedStages: VkShaderStageFlags; // Bitfield of what shader stages support subgroup operations
    supportedOperations: VkSubgroupFeatureFlags; // Bitfield of what subgroup operations are supported.
    quadOperationsInAllStages: VkBool32; // Flag to specify whether quad operations are available in all stages.
  end;

  VkBufferMemoryRequirementsInfo2 = record
    sType: VkStructureType;
    pNext: pointer;
    buffer: VkBuffer;
  end;

  VkImageMemoryRequirementsInfo2 = record
    sType: VkStructureType;
    pNext: pointer;
    image: VkImage;
  end;

  VkImageSparseMemoryRequirementsInfo2 = record
    sType: VkStructureType;
    pNext: pointer;
    image: VkImage;
  end;

  VkMemoryRequirements2 = record
    sType: VkStructureType;
    pNext: pointer;
    memoryRequirements: VkMemoryRequirements;
  end;

  VkSparseImageMemoryRequirements2 = record
    sType: VkStructureType;
    pNext: pointer;
    memoryRequirements: VkSparseImageMemoryRequirements;
  end;

  VkPhysicalDevicePointClippingProperties = record
    sType: VkStructureType;
    pNext: pointer;
    pointClippingBehavior: VkPointClippingBehavior;
  end;

  VkMemoryDedicatedRequirements = record
    sType: VkStructureType;
    pNext: pointer;
    prefersDedicatedAllocation: VkBool32;
    requiresDedicatedAllocation: VkBool32;
  end;

  VkMemoryDedicatedAllocateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    image: VkImage; // Image that this allocation will be bound to
    buffer: VkBuffer; // Buffer that this allocation will be bound to
  end;

  VkImageViewUsageCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    usage: VkImageUsageFlags;
  end;

  VkPipelineTessellationDomainOriginStateCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    domainOrigin: VkTessellationDomainOrigin;
  end;

  VkSamplerYcbcrConversionInfo = record
    sType: VkStructureType;
    pNext: pointer;
    conversion: VkSamplerYcbcrConversion;
  end;

  VkSamplerYcbcrConversionCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    format: VkFormat;
    ycbcrModel: VkSamplerYcbcrModelConversion;
    ycbcrRange: VkSamplerYcbcrRange;
    components: VkComponentMapping;
    xChromaOffset: VkChromaLocation;
    yChromaOffset: VkChromaLocation;
    chromaFilter: VkFilter;
    forceExplicitReconstruction: VkBool32;
  end;

  VkBindImagePlaneMemoryInfo = record
    sType: VkStructureType;
    pNext: pointer;
    planeAspect: VkImageAspectFlagBits;
  end;

  VkImagePlaneMemoryRequirementsInfo = record
    sType: VkStructureType;
    pNext: pointer;
    planeAspect: VkImageAspectFlagBits;
  end;

  VkPhysicalDeviceSamplerYcbcrConversionFeatures = record
    sType: VkStructureType;
    pNext: pointer;
    samplerYcbcrConversion: VkBool32; // Sampler color conversion supported
  end;

  VkSamplerYcbcrConversionImageFormatProperties = record
    sType: VkStructureType;
    pNext: pointer;
    combinedImageSamplerDescriptorCount: uint32_t;
  end;

  VkTextureLODGatherFormatPropertiesAMD = record
    sType: VkStructureType;
    pNext: pointer;
    supportsTextureGatherLODBiasAMD: VkBool32;
  end;

  VkConditionalRenderingBeginInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    buffer: VkBuffer;
    offset: VkDeviceSize;
    flags: VkConditionalRenderingFlagsEXT;
  end;

  VkProtectedSubmitInfo = record
    sType: VkStructureType;
    pNext: pointer;
    protectedSubmit: VkBool32; // Submit protected command buffers
  end;

  VkPhysicalDeviceProtectedMemoryFeatures = record
    sType: VkStructureType;
    pNext: pointer;
    protectedMemory: VkBool32;
  end;

  VkPhysicalDeviceProtectedMemoryProperties = record
    sType: VkStructureType;
    pNext: pointer;
    protectedNoFault: VkBool32;
  end;

  VkDeviceQueueInfo2 = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDeviceQueueCreateFlags;
    queueFamilyIndex: uint32_t;
    queueIndex: uint32_t;
  end;

  VkPipelineCoverageToColorStateCreateInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineCoverageToColorStateCreateFlagsNV;
    coverageToColorEnable: VkBool32;
    coverageToColorLocation: uint32_t;
  end;

  VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    filterMinmaxSingleComponentFormats: VkBool32;
    filterMinmaxImageComponentMapping: VkBool32;
  end;

  VkSampleLocationEXT = record
    x: float;
    y: float;
  end;

  VkSampleLocationsInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    sampleLocationsPerPixel: VkSampleCountFlagBits;
    sampleLocationGridSize: VkExtent2D;
    sampleLocationsCount: uint32_t;
    pSampleLocations: ^VkSampleLocationEXT;
  end;

  VkAttachmentSampleLocationsEXT = record
    attachmentIndex: uint32_t;
    sampleLocationsInfo: VkSampleLocationsInfoEXT;
  end;

  VkSubpassSampleLocationsEXT = record
    subpassIndex: uint32_t;
    sampleLocationsInfo: VkSampleLocationsInfoEXT;
  end;

  VkRenderPassSampleLocationsBeginInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    attachmentInitialSampleLocationsCount: uint32_t;
    pAttachmentInitialSampleLocations: ^VkAttachmentSampleLocationsEXT;
    postSubpassSampleLocationsCount: uint32_t;
    pPostSubpassSampleLocations: ^VkSubpassSampleLocationsEXT;
  end;

  VkPipelineSampleLocationsStateCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    sampleLocationsEnable: VkBool32;
    sampleLocationsInfo: VkSampleLocationsInfoEXT;
  end;

  VkPhysicalDeviceSampleLocationsPropertiesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    sampleLocationSampleCounts: VkSampleCountFlags;
    maxSampleLocationGridSize: VkExtent2D;
    sampleLocationCoordinateRange: array [0..1] of float;
    sampleLocationSubPixelBits: uint32_t;
    variableSampleLocations: VkBool32;
  end;

  VkMultisamplePropertiesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    maxSampleLocationGridSize: VkExtent2D;
  end;

  VkSamplerReductionModeCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    reductionMode: VkSamplerReductionModeEXT;
  end;

  VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    advancedBlendCoherentOperations: VkBool32;
  end;

  VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    advancedBlendMaxColorAttachments: uint32_t;
    advancedBlendIndependentBlend: VkBool32;
    advancedBlendNonPremultipliedSrcColor: VkBool32;
    advancedBlendNonPremultipliedDstColor: VkBool32;
    advancedBlendCorrelatedOverlap: VkBool32;
    advancedBlendAllOperations: VkBool32;
  end;

  VkPipelineColorBlendAdvancedStateCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    srcPremultiplied: VkBool32;
    dstPremultiplied: VkBool32;
    blendOverlap: VkBlendOverlapEXT;
  end;

  VkPipelineCoverageModulationStateCreateInfoNV = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineCoverageModulationStateCreateFlagsNV;
    coverageModulationMode: VkCoverageModulationModeNV;
    coverageModulationTableEnable: VkBool32;
    coverageModulationTableCount: uint32_t;
    pCoverageModulationTable: ^float;
  end;

  VkImageFormatListCreateInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    viewFormatCount: uint32_t;
    pViewFormats: ^VkFormat;
  end;

  VkValidationCacheCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkValidationCacheCreateFlagsEXT;
    initialDataSize: size_t;
    pInitialData: pointer;
  end;

  VkShaderModuleValidationCacheCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    validationCache: VkValidationCacheEXT;
  end;

  VkPhysicalDeviceMaintenance3Properties = record
    sType: VkStructureType;
    pNext: pointer;
    maxPerSetDescriptors: uint32_t;
    maxMemoryAllocationSize: VkDeviceSize;
  end;

  VkDescriptorSetLayoutSupport = record
    sType: VkStructureType;
    pNext: pointer;
    supported: VkBool32;
  end;

  VkPhysicalDeviceShaderDrawParameterFeatures = record
    sType: VkStructureType;
    pNext: pointer;
    shaderDrawParameters: VkBool32;
  end;

  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  VkNativeBufferANDROID = record
    sType: VkStructureType;
    pNext: pointer;
    handle: pointer;
    stride: integer;
    format: integer;
    usage: integer;
  end;

  {$endif}
  VkShaderResourceUsageAMD = record
    numUsedVgprs: uint32_t;
    numUsedSgprs: uint32_t;
    ldsSizePerLocalWorkGroup: uint32_t;
    ldsUsageSizeInBytes: size_t;
    scratchMemUsageInBytes: size_t;
  end;

  VkShaderStatisticsInfoAMD = record
    shaderStageMask: VkShaderStageFlags;
    resourceUsage: VkShaderResourceUsageAMD;
    numPhysicalVgprs: uint32_t;
    numPhysicalSgprs: uint32_t;
    numAvailableVgprs: uint32_t;
    numAvailableSgprs: uint32_t;
    computeWorkGroupSize: array [0..2] of uint32_t;
  end;

  VkDeviceQueueGlobalPriorityCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    globalPriority: VkQueueGlobalPriorityEXT;
  end;

  VkDebugUtilsObjectNameInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    objectType: VkObjectType;
    objectHandle: uint64_t;
    pObjectName: pansichar;
  end;

  VkDebugUtilsObjectTagInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    objectType: VkObjectType;
    objectHandle: uint64_t;
    tagName: uint64_t;
    tagSize: size_t;
    pTag: pointer;
  end;

  VkDebugUtilsLabelEXT = record
    sType: VkStructureType;
    pNext: pointer;
    pLabelName: pansichar;
    color: array [0..3] of float;
  end;

  VkDebugUtilsMessengerCallbackDataEXT = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDebugUtilsMessengerCallbackDataFlagsEXT;
    pMessageIdName: pansichar;
    messageIdNumber: int32_t;
    pMessage: pansichar;
    queueLabelCount: uint32_t;
    pQueueLabels: ^VkDebugUtilsLabelEXT;
    cmdBufLabelCount: uint32_t;
    pCmdBufLabels: ^VkDebugUtilsLabelEXT;
    objectCount: uint32_t;
    pObjects: ^VkDebugUtilsObjectNameInfoEXT;
  end;

  VkImportMemoryHostPointerInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    handleType: VkExternalMemoryHandleTypeFlagBits;
    pHostPointer: pointer;
  end;

  VkMemoryHostPointerPropertiesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    memoryTypeBits: uint32_t;
  end;

  VkPhysicalDeviceExternalMemoryHostPropertiesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    minImportedHostPointerAlignment: VkDeviceSize;
  end;

  VkPhysicalDeviceConservativeRasterizationPropertiesEXT = record
    sType: VkStructureType;
    pNext: pointer; // Pointer to next structure
    primitiveOverestimationSize: float; // The size in pixels the primitive is enlarged at each edge during conservative rasterization
    maxExtraPrimitiveOverestimationSize: float; // The maximum additional overestimation the client can specify in the pipeline state
    extraPrimitiveOverestimationSizeGranularity: float; // The granularity of extra overestimation sizes the implementations supports between 0 and maxExtraOverestimationSize
    primitiveUnderestimation: VkBool32; // true if the implementation supports conservative rasterization underestimation mode
    conservativePointAndLineRasterization: VkBool32; // true if conservative rasterization also applies to points and lines
    degenerateTrianglesRasterized: VkBool32; // true if degenerate triangles (those with zero area after snap) are rasterized
    degenerateLinesRasterized: VkBool32; // true if degenerate lines (those with zero length after snap) are rasterized
    fullyCoveredFragmentShaderInputVariable: VkBool32; // true if the implementation supports the FullyCoveredEXT SPIR-V builtin fragment shader input variable
    conservativeRasterizationPostDepthCoverage: VkBool32; // true if the implementation supports both conservative rasterization and post depth coverage sample coverage mask
  end;

  VkPhysicalDeviceShaderCorePropertiesAMD = record
    sType: VkStructureType;
    pNext: pointer; // Pointer to next structure
    shaderEngineCount: uint32_t; // number of shader engines
    shaderArraysPerEngineCount: uint32_t; // number of shader arrays
    computeUnitsPerShaderArray: uint32_t; // number of CUs per shader array
    simdPerComputeUnit: uint32_t; // number of SIMDs per compute unit
    wavefrontsPerSimd: uint32_t; // number of wavefront slots in each SIMD
    wavefrontSize: uint32_t; // number of threads per wavefront
    sgprsPerSimd: uint32_t; // number of physical SGPRs per SIMD
    minSgprAllocation: uint32_t; // minimum number of SGPRs that can be allocated by a wave
    maxSgprAllocation: uint32_t; // number of available SGPRs
    sgprAllocationGranularity: uint32_t; // SGPRs are allocated in groups of this size
    vgprsPerSimd: uint32_t; // number of physical VGPRs per SIMD
    minVgprAllocation: uint32_t; // minimum number of VGPRs that can be allocated by a wave
    maxVgprAllocation: uint32_t; // number of available VGPRs
    vgprAllocationGranularity: uint32_t; // VGPRs are allocated in groups of this size
  end;

  VkPipelineRasterizationConservativeStateCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkPipelineRasterizationConservativeStateCreateFlagsEXT;
    conservativeRasterizationMode: VkConservativeRasterizationModeEXT;
    extraPrimitiveOverestimationSize: float;
  end;

  VkPhysicalDeviceDescriptorIndexingFeaturesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    shaderInputAttachmentArrayDynamicIndexing: VkBool32;
    shaderUniformTexelBufferArrayDynamicIndexing: VkBool32;
    shaderStorageTexelBufferArrayDynamicIndexing: VkBool32;
    shaderUniformBufferArrayNonUniformIndexing: VkBool32;
    shaderSampledImageArrayNonUniformIndexing: VkBool32;
    shaderStorageBufferArrayNonUniformIndexing: VkBool32;
    shaderStorageImageArrayNonUniformIndexing: VkBool32;
    shaderInputAttachmentArrayNonUniformIndexing: VkBool32;
    shaderUniformTexelBufferArrayNonUniformIndexing: VkBool32;
    shaderStorageTexelBufferArrayNonUniformIndexing: VkBool32;
    descriptorBindingUniformBufferUpdateAfterBind: VkBool32;
    descriptorBindingSampledImageUpdateAfterBind: VkBool32;
    descriptorBindingStorageImageUpdateAfterBind: VkBool32;
    descriptorBindingStorageBufferUpdateAfterBind: VkBool32;
    descriptorBindingUniformTexelBufferUpdateAfterBind: VkBool32;
    descriptorBindingStorageTexelBufferUpdateAfterBind: VkBool32;
    descriptorBindingUpdateUnusedWhilePending: VkBool32;
    descriptorBindingPartiallyBound: VkBool32;
    descriptorBindingVariableDescriptorCount: VkBool32;
    runtimeDescriptorArray: VkBool32;
  end;

  VkPhysicalDeviceDescriptorIndexingPropertiesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    maxUpdateAfterBindDescriptorsInAllPools: uint32_t;
    shaderUniformBufferArrayNonUniformIndexingNative: VkBool32;
    shaderSampledImageArrayNonUniformIndexingNative: VkBool32;
    shaderStorageBufferArrayNonUniformIndexingNative: VkBool32;
    shaderStorageImageArrayNonUniformIndexingNative: VkBool32;
    shaderInputAttachmentArrayNonUniformIndexingNative: VkBool32;
    robustBufferAccessUpdateAfterBind: VkBool32;
    quadDivergentImplicitLod: VkBool32;
    maxPerStageDescriptorUpdateAfterBindSamplers: uint32_t;
    maxPerStageDescriptorUpdateAfterBindUniformBuffers: uint32_t;
    maxPerStageDescriptorUpdateAfterBindStorageBuffers: uint32_t;
    maxPerStageDescriptorUpdateAfterBindSampledImages: uint32_t;
    maxPerStageDescriptorUpdateAfterBindStorageImages: uint32_t;
    maxPerStageDescriptorUpdateAfterBindInputAttachments: uint32_t;
    maxPerStageUpdateAfterBindResources: uint32_t;
    maxDescriptorSetUpdateAfterBindSamplers: uint32_t;
    maxDescriptorSetUpdateAfterBindUniformBuffers: uint32_t;
    maxDescriptorSetUpdateAfterBindUniformBuffersDynamic: uint32_t;
    maxDescriptorSetUpdateAfterBindStorageBuffers: uint32_t;
    maxDescriptorSetUpdateAfterBindStorageBuffersDynamic: uint32_t;
    maxDescriptorSetUpdateAfterBindSampledImages: uint32_t;
    maxDescriptorSetUpdateAfterBindStorageImages: uint32_t;
    maxDescriptorSetUpdateAfterBindInputAttachments: uint32_t;
  end;

  VkDescriptorSetLayoutBindingFlagsCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    bindingCount: uint32_t;
    pBindingFlags: ^VkDescriptorBindingFlagsEXT;
  end;

  VkDescriptorSetVariableDescriptorCountAllocateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    descriptorSetCount: uint32_t;
    pDescriptorCounts: ^uint32_t;
  end;

  VkDescriptorSetVariableDescriptorCountLayoutSupportEXT = record
    sType: VkStructureType;
    pNext: pointer;
    maxVariableDescriptorCount: uint32_t;
  end;

  VkAttachmentDescription2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkAttachmentDescriptionFlags;
    format: VkFormat;
    samples: VkSampleCountFlagBits;
    loadOp: VkAttachmentLoadOp; // Load operation for color or depth data
    storeOp: VkAttachmentStoreOp; // Store operation for color or depth data
    stencilLoadOp: VkAttachmentLoadOp; // Load operation for stencil data
    stencilStoreOp: VkAttachmentStoreOp; // Store operation for stencil data
    initialLayout: VkImageLayout;
    finalLayout: VkImageLayout;
  end;

  VkAttachmentReference2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    attachment: uint32_t;
    layout: VkImageLayout;
    aspectMask: VkImageAspectFlags;
  end;

  VkSubpassDescription2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkSubpassDescriptionFlags;
    pipelineBindPoint: VkPipelineBindPoint;
    viewMask: uint32_t;
    inputAttachmentCount: uint32_t;
    pInputAttachments: ^VkAttachmentReference2KHR;
    colorAttachmentCount: uint32_t;
    pColorAttachments: ^VkAttachmentReference2KHR;
    pResolveAttachments: ^VkAttachmentReference2KHR;
    pDepthStencilAttachment: ^VkAttachmentReference2KHR;
    preserveAttachmentCount: uint32_t;
    pPreserveAttachments: ^uint32_t;
  end;

  VkSubpassDependency2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    srcSubpass: uint32_t;
    dstSubpass: uint32_t;
    srcStageMask: VkPipelineStageFlags;
    dstStageMask: VkPipelineStageFlags;
    srcAccessMask: VkAccessFlags;
    dstAccessMask: VkAccessFlags;
    dependencyFlags: VkDependencyFlags;
    viewOffset: int32_t;
  end;

  VkRenderPassCreateInfo2KHR = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkRenderPassCreateFlags;
    attachmentCount: uint32_t;
    pAttachments: ^VkAttachmentDescription2KHR;
    subpassCount: uint32_t;
    pSubpasses: ^VkSubpassDescription2KHR;
    dependencyCount: uint32_t;
    pDependencies: ^VkSubpassDependency2KHR;
    correlatedViewMaskCount: uint32_t;
    pCorrelatedViewMasks: ^uint32_t;
  end;

  VkSubpassBeginInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
    contents: VkSubpassContents;
  end;

  VkSubpassEndInfoKHR = record
    sType: VkStructureType;
    pNext: pointer;
  end;

  VkVertexInputBindingDivisorDescriptionEXT = record
    binding: uint32_t;
    divisor: uint32_t;
  end;

  VkPipelineVertexInputDivisorStateCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    vertexBindingDivisorCount: uint32_t;
    pVertexBindingDivisors: ^VkVertexInputBindingDivisorDescriptionEXT;
  end;

  VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    maxVertexAttribDivisor: uint32_t; // max value of vertex attribute divisor
  end;

  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  VkImportAndroidHardwareBufferInfoANDROID = record
    sType: VkStructureType;
    pNext: pointer;
    buffer: ^AHardwareBuffer;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  VkAndroidHardwareBufferUsageANDROID = record
    sType: VkStructureType;
    pNext: pointer;
    androidHardwareBufferUsage: uint64_t;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  VkAndroidHardwareBufferPropertiesANDROID = record
    sType: VkStructureType;
    pNext: pointer;
    allocationSize: VkDeviceSize;
    memoryTypeBits: uint32_t;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  VkMemoryGetAndroidHardwareBufferInfoANDROID = record
    sType: VkStructureType;
    pNext: pointer;
    memory: VkDeviceMemory;
  end;

  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  VkAndroidHardwareBufferFormatPropertiesANDROID = record
    sType: VkStructureType;
    pNext: pointer;
    format: VkFormat;
    externalFormat: uint64_t;
    formatFeatures: VkFormatFeatureFlags;
    samplerYcbcrConversionComponents: VkComponentMapping;
    suggestedYcbcrModel: VkSamplerYcbcrModelConversion;
    suggestedYcbcrRange: VkSamplerYcbcrRange;
    suggestedXChromaOffset: VkChromaLocation;
    suggestedYChromaOffset: VkChromaLocation;
  end;

  {$endif}
  VkCommandBufferInheritanceConditionalRenderingInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    conditionalRenderingEnable: VkBool32; // Whether this secondary command buffer may be executed during an active conditional rendering
  end;

  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}
  VkExternalFormatANDROID = record
    sType: VkStructureType;
    pNext: pointer;
    externalFormat: uint64_t;
  end;

  {$endif}
  VkPhysicalDevice8BitStorageFeaturesKHR = record
    sType: VkStructureType;
    pNext: pointer;
    storageBuffer8BitAccess: VkBool32; // 8-bit integer variables supported in StorageBuffer
    uniformAndStorageBuffer8BitAccess: VkBool32; // 8-bit integer variables supported in StorageBuffer and Uniform
    storagePushConstant8: VkBool32; // 8-bit integer variables supported in PushConstant
  end;

  VkPhysicalDeviceConditionalRenderingFeaturesEXT = record
    sType: VkStructureType;
    pNext: pointer;
    conditionalRendering: VkBool32;
    inheritedConditionalRendering: VkBool32;
  end;

  VkQueueFamilyCheckpointPropertiesNV = record
    sType: VkStructureType;
    pNext: pointer;
    checkpointExecutionStageMask: VkPipelineStageFlags;
  end;

  VkCheckpointDataNV = record
    sType: VkStructureType;
    pNext: pointer;
    stage: VkPipelineStageFlagBits;
    pCheckpointMarker: pointer;
  end;

  TpCallbackData = VkDebugUtilsMessengerCallbackDataEXT;
  pTpCallbackData = ^TpCallbackData;
  PFN_vkDebugUtilsMessengerCallbackEXT = function ( messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT; messageType: VkDebugUtilsMessageTypeFlagsEXT; pCallbackData: pTpCallbackData; pUserData: pointer ):VkBool32;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}

  VkPhysicalDeviceProperties = record
    apiVersion: uint32_t;
    driverVersion: uint32_t;
    vendorID: uint32_t;
    deviceID: uint32_t;
    deviceType: VkPhysicalDeviceType;
    deviceName: array [0..VK_MAX_PHYSICAL_DEVICE_NAME_SIZE-1] of TChar;
    pipelineCacheUUID: array [0..VK_UUID_SIZE-1] of uint8_t;
    limits: VkPhysicalDeviceLimits;
    sparseProperties: VkPhysicalDeviceSparseProperties;
  end;

  VkDeviceCreateInfo = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDeviceCreateFlags;
    queueCreateInfoCount: uint32_t;
    pQueueCreateInfos: ^VkDeviceQueueCreateInfo;
    enabledLayerCount: uint32_t;
    ppEnabledLayerNames: pppTppEnabledLayerNames; // Ordered list of layer names to be enabled
    enabledExtensionCount: uint32_t;
    ppEnabledExtensionNames: pppTppEnabledExtensionNames;
    pEnabledFeatures: ^VkPhysicalDeviceFeatures;
  end;

  VkPhysicalDeviceMemoryProperties = record
    memoryTypeCount: uint32_t;
    memoryTypes: array [0..VK_MAX_MEMORY_TYPES-1] of VkMemoryType;
    memoryHeapCount: uint32_t;
    memoryHeaps: array [0..VK_MAX_MEMORY_HEAPS-1] of VkMemoryHeap;
  end;

  VkRenderPassBeginInfo = record
    sType: VkStructureType;
    pNext: pointer;
    renderPass: VkRenderPass;
    framebuffer: VkFramebuffer;
    renderArea: VkRect2D;
    clearValueCount: uint32_t;
    pClearValues: ^VkClearValue;
  end;

  VkPhysicalDeviceProperties2 = record
    sType: VkStructureType;
    pNext: pointer;
    properties: VkPhysicalDeviceProperties;
  end;

  VkPhysicalDeviceMemoryProperties2 = record
    sType: VkStructureType;
    pNext: pointer;
    memoryProperties: VkPhysicalDeviceMemoryProperties;
  end;

  VkPresentRegionKHR = record
    rectangleCount: uint32_t; // Number of rectangles in pRectangles
    pRectangles: ^VkRectLayerKHR; // Array of rectangles that have changed in a swapchain's image(s)
  end;

  VkPresentTimesInfoGOOGLE = record
    sType: VkStructureType;
    pNext: pointer;
    swapchainCount: uint32_t; // Copy of VkPresentInfoKHR::swapchainCount
    pTimes: ^VkPresentTimeGOOGLE; // The earliest times to present images
  end;

  VkDebugUtilsMessengerCreateInfoEXT = record
    sType: VkStructureType;
    pNext: pointer;
    flags: VkDebugUtilsMessengerCreateFlagsEXT;
    messageSeverity: VkDebugUtilsMessageSeverityFlagsEXT;
    messageType: VkDebugUtilsMessageTypeFlagsEXT;
    pfnUserCallback: PFN_vkDebugUtilsMessengerCallbackEXT;
    pUserData: pointer;
  end;

  VkPresentRegionsKHR = record
    sType: VkStructureType;
    pNext: pointer;
    swapchainCount: uint32_t; // Copy of VkPresentInfoKHR::swapchainCount
    pRegions: ^VkPresentRegionKHR; // The regions that have changed
  end;


{
  These types are not in the source xml, they are required to support pointer parameters in delphi.
}


type
  TVkInstanceCreateInfo = VkInstanceCreateInfo;
  pTVkInstanceCreateInfo = ^TVkInstanceCreateInfo;
  TVkAllocationCallbacks = VkAllocationCallbacks;
  pTVkAllocationCallbacks = ^TVkAllocationCallbacks;
  TVkInstance = VkInstance;
  pTVkInstance = ^TVkInstance;
  Tuint32_t = uint32_t;
  pTuint32_t = ^Tuint32_t;
  TVkPhysicalDevice = VkPhysicalDevice;
  pTVkPhysicalDevice = ^TVkPhysicalDevice;
  TVkPhysicalDeviceProperties = VkPhysicalDeviceProperties;
  pTVkPhysicalDeviceProperties = ^TVkPhysicalDeviceProperties;
  TVkQueueFamilyProperties = VkQueueFamilyProperties;
  pTVkQueueFamilyProperties = ^TVkQueueFamilyProperties;
  TVkPhysicalDeviceMemoryProperties = VkPhysicalDeviceMemoryProperties;
  pTVkPhysicalDeviceMemoryProperties = ^TVkPhysicalDeviceMemoryProperties;
  TVkPhysicalDeviceFeatures = VkPhysicalDeviceFeatures;
  pTVkPhysicalDeviceFeatures = ^TVkPhysicalDeviceFeatures;
  TVkFormatProperties = VkFormatProperties;
  pTVkFormatProperties = ^TVkFormatProperties;
  TVkImageFormatProperties = VkImageFormatProperties;
  pTVkImageFormatProperties = ^TVkImageFormatProperties;
  TVkDeviceCreateInfo = VkDeviceCreateInfo;
  pTVkDeviceCreateInfo = ^TVkDeviceCreateInfo;
  TVkDevice = VkDevice;
  pTVkDevice = ^TVkDevice;
  TVkLayerProperties = VkLayerProperties;
  pTVkLayerProperties = ^TVkLayerProperties;
  TVkExtensionProperties = VkExtensionProperties;
  pTVkExtensionProperties = ^TVkExtensionProperties;
  TVkQueue = VkQueue;
  pTVkQueue = ^TVkQueue;
  TVkSubmitInfo = VkSubmitInfo;
  pTVkSubmitInfo = ^TVkSubmitInfo;
  TVkMemoryAllocateInfo = VkMemoryAllocateInfo;
  pTVkMemoryAllocateInfo = ^TVkMemoryAllocateInfo;
  TVkDeviceMemory = VkDeviceMemory;
  pTVkDeviceMemory = ^TVkDeviceMemory;
  ppointer = ^pointer;
  TVkMappedMemoryRange = VkMappedMemoryRange;
  pTVkMappedMemoryRange = ^TVkMappedMemoryRange;
  TVkDeviceSize = VkDeviceSize;
  pTVkDeviceSize = ^TVkDeviceSize;
  TVkMemoryRequirements = VkMemoryRequirements;
  pTVkMemoryRequirements = ^TVkMemoryRequirements;
  TVkSparseImageMemoryRequirements = VkSparseImageMemoryRequirements;
  pTVkSparseImageMemoryRequirements = ^TVkSparseImageMemoryRequirements;
  TVkSparseImageFormatProperties = VkSparseImageFormatProperties;
  pTVkSparseImageFormatProperties = ^TVkSparseImageFormatProperties;
  TVkBindSparseInfo = VkBindSparseInfo;
  pTVkBindSparseInfo = ^TVkBindSparseInfo;
  TVkFenceCreateInfo = VkFenceCreateInfo;
  pTVkFenceCreateInfo = ^TVkFenceCreateInfo;
  TVkFence = VkFence;
  pTVkFence = ^TVkFence;
  TVkSemaphoreCreateInfo = VkSemaphoreCreateInfo;
  pTVkSemaphoreCreateInfo = ^TVkSemaphoreCreateInfo;
  TVkSemaphore = VkSemaphore;
  pTVkSemaphore = ^TVkSemaphore;
  TVkEventCreateInfo = VkEventCreateInfo;
  pTVkEventCreateInfo = ^TVkEventCreateInfo;
  TVkEvent = VkEvent;
  pTVkEvent = ^TVkEvent;
  TVkQueryPoolCreateInfo = VkQueryPoolCreateInfo;
  pTVkQueryPoolCreateInfo = ^TVkQueryPoolCreateInfo;
  TVkQueryPool = VkQueryPool;
  pTVkQueryPool = ^TVkQueryPool;
  TVkBufferCreateInfo = VkBufferCreateInfo;
  pTVkBufferCreateInfo = ^TVkBufferCreateInfo;
  TVkBuffer = VkBuffer;
  pTVkBuffer = ^TVkBuffer;
  TVkBufferViewCreateInfo = VkBufferViewCreateInfo;
  pTVkBufferViewCreateInfo = ^TVkBufferViewCreateInfo;
  TVkBufferView = VkBufferView;
  pTVkBufferView = ^TVkBufferView;
  TVkImageCreateInfo = VkImageCreateInfo;
  pTVkImageCreateInfo = ^TVkImageCreateInfo;
  TVkImage = VkImage;
  pTVkImage = ^TVkImage;
  TVkImageSubresource = VkImageSubresource;
  pTVkImageSubresource = ^TVkImageSubresource;
  TVkSubresourceLayout = VkSubresourceLayout;
  pTVkSubresourceLayout = ^TVkSubresourceLayout;
  TVkImageViewCreateInfo = VkImageViewCreateInfo;
  pTVkImageViewCreateInfo = ^TVkImageViewCreateInfo;
  TVkImageView = VkImageView;
  pTVkImageView = ^TVkImageView;
  TVkShaderModuleCreateInfo = VkShaderModuleCreateInfo;
  pTVkShaderModuleCreateInfo = ^TVkShaderModuleCreateInfo;
  TVkShaderModule = VkShaderModule;
  pTVkShaderModule = ^TVkShaderModule;
  TVkPipelineCacheCreateInfo = VkPipelineCacheCreateInfo;
  pTVkPipelineCacheCreateInfo = ^TVkPipelineCacheCreateInfo;
  TVkPipelineCache = VkPipelineCache;
  pTVkPipelineCache = ^TVkPipelineCache;
  Tsize_t = size_t;
  pTsize_t = ^Tsize_t;
  TVkGraphicsPipelineCreateInfo = VkGraphicsPipelineCreateInfo;
  pTVkGraphicsPipelineCreateInfo = ^TVkGraphicsPipelineCreateInfo;
  TVkPipeline = VkPipeline;
  pTVkPipeline = ^TVkPipeline;
  TVkComputePipelineCreateInfo = VkComputePipelineCreateInfo;
  pTVkComputePipelineCreateInfo = ^TVkComputePipelineCreateInfo;
  TVkPipelineLayoutCreateInfo = VkPipelineLayoutCreateInfo;
  pTVkPipelineLayoutCreateInfo = ^TVkPipelineLayoutCreateInfo;
  TVkPipelineLayout = VkPipelineLayout;
  pTVkPipelineLayout = ^TVkPipelineLayout;
  TVkSamplerCreateInfo = VkSamplerCreateInfo;
  pTVkSamplerCreateInfo = ^TVkSamplerCreateInfo;
  TVkSampler = VkSampler;
  pTVkSampler = ^TVkSampler;
  TVkDescriptorSetLayoutCreateInfo = VkDescriptorSetLayoutCreateInfo;
  pTVkDescriptorSetLayoutCreateInfo = ^TVkDescriptorSetLayoutCreateInfo;
  TVkDescriptorSetLayout = VkDescriptorSetLayout;
  pTVkDescriptorSetLayout = ^TVkDescriptorSetLayout;
  TVkDescriptorPoolCreateInfo = VkDescriptorPoolCreateInfo;
  pTVkDescriptorPoolCreateInfo = ^TVkDescriptorPoolCreateInfo;
  TVkDescriptorPool = VkDescriptorPool;
  pTVkDescriptorPool = ^TVkDescriptorPool;
  TVkDescriptorSetAllocateInfo = VkDescriptorSetAllocateInfo;
  pTVkDescriptorSetAllocateInfo = ^TVkDescriptorSetAllocateInfo;
  TVkDescriptorSet = VkDescriptorSet;
  pTVkDescriptorSet = ^TVkDescriptorSet;
  TVkWriteDescriptorSet = VkWriteDescriptorSet;
  pTVkWriteDescriptorSet = ^TVkWriteDescriptorSet;
  TVkCopyDescriptorSet = VkCopyDescriptorSet;
  pTVkCopyDescriptorSet = ^TVkCopyDescriptorSet;
  TVkFramebufferCreateInfo = VkFramebufferCreateInfo;
  pTVkFramebufferCreateInfo = ^TVkFramebufferCreateInfo;
  TVkFramebuffer = VkFramebuffer;
  pTVkFramebuffer = ^TVkFramebuffer;
  TVkRenderPassCreateInfo = VkRenderPassCreateInfo;
  pTVkRenderPassCreateInfo = ^TVkRenderPassCreateInfo;
  TVkRenderPass = VkRenderPass;
  pTVkRenderPass = ^TVkRenderPass;
  TVkExtent2D = VkExtent2D;
  pTVkExtent2D = ^TVkExtent2D;
  TVkCommandPoolCreateInfo = VkCommandPoolCreateInfo;
  pTVkCommandPoolCreateInfo = ^TVkCommandPoolCreateInfo;
  TVkCommandPool = VkCommandPool;
  pTVkCommandPool = ^TVkCommandPool;
  TVkCommandBufferAllocateInfo = VkCommandBufferAllocateInfo;
  pTVkCommandBufferAllocateInfo = ^TVkCommandBufferAllocateInfo;
  TVkCommandBuffer = VkCommandBuffer;
  pTVkCommandBuffer = ^TVkCommandBuffer;
  TVkCommandBufferBeginInfo = VkCommandBufferBeginInfo;
  pTVkCommandBufferBeginInfo = ^TVkCommandBufferBeginInfo;
  TVkViewport = VkViewport;
  pTVkViewport = ^TVkViewport;
  TVkRect2D = VkRect2D;
  pTVkRect2D = ^TVkRect2D;
  TVkBufferCopy = VkBufferCopy;
  pTVkBufferCopy = ^TVkBufferCopy;
  TVkImageCopy = VkImageCopy;
  pTVkImageCopy = ^TVkImageCopy;
  TVkImageBlit = VkImageBlit;
  pTVkImageBlit = ^TVkImageBlit;
  TVkBufferImageCopy = VkBufferImageCopy;
  pTVkBufferImageCopy = ^TVkBufferImageCopy;
  TVkClearColorValue = VkClearColorValue;
  pTVkClearColorValue = ^TVkClearColorValue;
  TVkImageSubresourceRange = VkImageSubresourceRange;
  pTVkImageSubresourceRange = ^TVkImageSubresourceRange;
  TVkClearDepthStencilValue = VkClearDepthStencilValue;
  pTVkClearDepthStencilValue = ^TVkClearDepthStencilValue;
  TVkClearAttachment = VkClearAttachment;
  pTVkClearAttachment = ^TVkClearAttachment;
  TVkClearRect = VkClearRect;
  pTVkClearRect = ^TVkClearRect;
  TVkImageResolve = VkImageResolve;
  pTVkImageResolve = ^TVkImageResolve;
  TVkMemoryBarrier = VkMemoryBarrier;
  pTVkMemoryBarrier = ^TVkMemoryBarrier;
  TVkBufferMemoryBarrier = VkBufferMemoryBarrier;
  pTVkBufferMemoryBarrier = ^TVkBufferMemoryBarrier;
  TVkImageMemoryBarrier = VkImageMemoryBarrier;
  pTVkImageMemoryBarrier = ^TVkImageMemoryBarrier;
  TVkConditionalRenderingBeginInfoEXT = VkConditionalRenderingBeginInfoEXT;
  pTVkConditionalRenderingBeginInfoEXT = ^TVkConditionalRenderingBeginInfoEXT;
  TVkRenderPassBeginInfo = VkRenderPassBeginInfo;
  pTVkRenderPassBeginInfo = ^TVkRenderPassBeginInfo;
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  TVkAndroidSurfaceCreateInfoKHR = VkAndroidSurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  pTVkAndroidSurfaceCreateInfoKHR = ^TVkAndroidSurfaceCreateInfoKHR;  {$endif}
  TVkSurfaceKHR = VkSurfaceKHR;
  pTVkSurfaceKHR = ^TVkSurfaceKHR;
  TVkDisplayPropertiesKHR = VkDisplayPropertiesKHR;
  pTVkDisplayPropertiesKHR = ^TVkDisplayPropertiesKHR;
  TVkDisplayPlanePropertiesKHR = VkDisplayPlanePropertiesKHR;
  pTVkDisplayPlanePropertiesKHR = ^TVkDisplayPlanePropertiesKHR;
  TVkDisplayKHR = VkDisplayKHR;
  pTVkDisplayKHR = ^TVkDisplayKHR;
  TVkDisplayModePropertiesKHR = VkDisplayModePropertiesKHR;
  pTVkDisplayModePropertiesKHR = ^TVkDisplayModePropertiesKHR;
  TVkDisplayModeCreateInfoKHR = VkDisplayModeCreateInfoKHR;
  pTVkDisplayModeCreateInfoKHR = ^TVkDisplayModeCreateInfoKHR;
  TVkDisplayModeKHR = VkDisplayModeKHR;
  pTVkDisplayModeKHR = ^TVkDisplayModeKHR;
  TVkDisplayPlaneCapabilitiesKHR = VkDisplayPlaneCapabilitiesKHR;
  pTVkDisplayPlaneCapabilitiesKHR = ^TVkDisplayPlaneCapabilitiesKHR;
  TVkDisplaySurfaceCreateInfoKHR = VkDisplaySurfaceCreateInfoKHR;
  pTVkDisplaySurfaceCreateInfoKHR = ^TVkDisplaySurfaceCreateInfoKHR;
  TVkSwapchainCreateInfoKHR = VkSwapchainCreateInfoKHR;
  pTVkSwapchainCreateInfoKHR = ^TVkSwapchainCreateInfoKHR;
  TVkSwapchainKHR = VkSwapchainKHR;
  pTVkSwapchainKHR = ^TVkSwapchainKHR;
  {$ifdef VK_USE_PLATFORM_MIR_KHR}  TVkMirSurfaceCreateInfoKHR = VkMirSurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_MIR_KHR}  pTVkMirSurfaceCreateInfoKHR = ^TVkMirSurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_MIR_KHR}  TMirConnection = MirConnection;
  {$endif}
  {$ifdef VK_USE_PLATFORM_MIR_KHR}  pTMirConnection = ^TMirConnection;
  {$endif}
  TVkBool32 = VkBool32;
  pTVkBool32 = ^TVkBool32;
  TVkSurfaceCapabilitiesKHR = VkSurfaceCapabilitiesKHR;
  pTVkSurfaceCapabilitiesKHR = ^TVkSurfaceCapabilitiesKHR;
  TVkSurfaceFormatKHR = VkSurfaceFormatKHR;
  pTVkSurfaceFormatKHR = ^TVkSurfaceFormatKHR;
  TVkPresentModeKHR = VkPresentModeKHR;
  pTVkPresentModeKHR = ^TVkPresentModeKHR;
  TVkPresentInfoKHR = VkPresentInfoKHR;
  pTVkPresentInfoKHR = ^TVkPresentInfoKHR;
  {$ifdef VK_USE_PLATFORM_VI_NN}  TVkViSurfaceCreateInfoNN = VkViSurfaceCreateInfoNN;  {$endif}
  {$ifdef VK_USE_PLATFORM_VI_NN}  pTVkViSurfaceCreateInfoNN = ^TVkViSurfaceCreateInfoNN;  {$endif}
  {$ifdef VK_USE_PLATFORM_WAYLAND_KHR}  TVkWaylandSurfaceCreateInfoKHR = VkWaylandSurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WAYLAND_KHR}  pTVkWaylandSurfaceCreateInfoKHR = ^TVkWaylandSurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WAYLAND_KHR}  Twl_display = wl_display;
  {$endif}
  {$ifdef VK_USE_PLATFORM_WAYLAND_KHR}  pTwl_display = ^Twl_display;
  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  TVkWin32SurfaceCreateInfoKHR = VkWin32SurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  pTVkWin32SurfaceCreateInfoKHR = ^TVkWin32SurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}  TVkXlibSurfaceCreateInfoKHR = VkXlibSurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}  pTVkXlibSurfaceCreateInfoKHR = ^TVkXlibSurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}  TDisplay = Display;
  {$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}  pTDisplay = ^TDisplay;
  {$endif}
  {$ifdef VK_USE_PLATFORM_XCB_KHR}  TVkXcbSurfaceCreateInfoKHR = VkXcbSurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_XCB_KHR}  pTVkXcbSurfaceCreateInfoKHR = ^TVkXcbSurfaceCreateInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_XCB_KHR}  Txcb_connection_t = xcb_connection_t;
  {$endif}
  {$ifdef VK_USE_PLATFORM_XCB_KHR}  pTxcb_connection_t = ^Txcb_connection_t;
  {$endif}
  TVkDebugReportCallbackCreateInfoEXT = VkDebugReportCallbackCreateInfoEXT;
  pTVkDebugReportCallbackCreateInfoEXT = ^TVkDebugReportCallbackCreateInfoEXT;
  TVkDebugReportCallbackEXT = VkDebugReportCallbackEXT;
  pTVkDebugReportCallbackEXT = ^TVkDebugReportCallbackEXT;
  TVkDebugMarkerObjectNameInfoEXT = VkDebugMarkerObjectNameInfoEXT;
  pTVkDebugMarkerObjectNameInfoEXT = ^TVkDebugMarkerObjectNameInfoEXT;
  TVkDebugMarkerObjectTagInfoEXT = VkDebugMarkerObjectTagInfoEXT;
  pTVkDebugMarkerObjectTagInfoEXT = ^TVkDebugMarkerObjectTagInfoEXT;
  TVkDebugMarkerMarkerInfoEXT = VkDebugMarkerMarkerInfoEXT;
  pTVkDebugMarkerMarkerInfoEXT = ^TVkDebugMarkerMarkerInfoEXT;
  TVkExternalImageFormatPropertiesNV = VkExternalImageFormatPropertiesNV;
  pTVkExternalImageFormatPropertiesNV = ^TVkExternalImageFormatPropertiesNV;
  pTHANDLE = ^THANDLE;
  TVkCmdProcessCommandsInfoNVX = VkCmdProcessCommandsInfoNVX;
  pTVkCmdProcessCommandsInfoNVX = ^TVkCmdProcessCommandsInfoNVX;
  TVkCmdReserveSpaceForCommandsInfoNVX = VkCmdReserveSpaceForCommandsInfoNVX;
  pTVkCmdReserveSpaceForCommandsInfoNVX = ^TVkCmdReserveSpaceForCommandsInfoNVX;
  TVkIndirectCommandsLayoutCreateInfoNVX = VkIndirectCommandsLayoutCreateInfoNVX;
  pTVkIndirectCommandsLayoutCreateInfoNVX = ^TVkIndirectCommandsLayoutCreateInfoNVX;
  TVkIndirectCommandsLayoutNVX = VkIndirectCommandsLayoutNVX;
  pTVkIndirectCommandsLayoutNVX = ^TVkIndirectCommandsLayoutNVX;
  TVkObjectTableCreateInfoNVX = VkObjectTableCreateInfoNVX;
  pTVkObjectTableCreateInfoNVX = ^TVkObjectTableCreateInfoNVX;
  TVkObjectTableNVX = VkObjectTableNVX;
  pTVkObjectTableNVX = ^TVkObjectTableNVX;
  TVkObjectTableEntryNVX = VkObjectTableEntryNVX;
  pTVkObjectTableEntryNVX = ^TVkObjectTableEntryNVX;
  pppTVkObjectTableEntryNVX = ^pTVkObjectTableEntryNVX;
  TVkObjectEntryTypeNVX = VkObjectEntryTypeNVX;
  pTVkObjectEntryTypeNVX = ^TVkObjectEntryTypeNVX;
  TVkDeviceGeneratedCommandsFeaturesNVX = VkDeviceGeneratedCommandsFeaturesNVX;
  pTVkDeviceGeneratedCommandsFeaturesNVX = ^TVkDeviceGeneratedCommandsFeaturesNVX;
  TVkDeviceGeneratedCommandsLimitsNVX = VkDeviceGeneratedCommandsLimitsNVX;
  pTVkDeviceGeneratedCommandsLimitsNVX = ^TVkDeviceGeneratedCommandsLimitsNVX;
  TVkPhysicalDeviceFeatures2 = VkPhysicalDeviceFeatures2;
  pTVkPhysicalDeviceFeatures2 = ^TVkPhysicalDeviceFeatures2;
  TVkPhysicalDeviceProperties2 = VkPhysicalDeviceProperties2;
  pTVkPhysicalDeviceProperties2 = ^TVkPhysicalDeviceProperties2;
  TVkFormatProperties2 = VkFormatProperties2;
  pTVkFormatProperties2 = ^TVkFormatProperties2;
  TVkPhysicalDeviceImageFormatInfo2 = VkPhysicalDeviceImageFormatInfo2;
  pTVkPhysicalDeviceImageFormatInfo2 = ^TVkPhysicalDeviceImageFormatInfo2;
  TVkImageFormatProperties2 = VkImageFormatProperties2;
  pTVkImageFormatProperties2 = ^TVkImageFormatProperties2;
  TVkQueueFamilyProperties2 = VkQueueFamilyProperties2;
  pTVkQueueFamilyProperties2 = ^TVkQueueFamilyProperties2;
  TVkPhysicalDeviceMemoryProperties2 = VkPhysicalDeviceMemoryProperties2;
  pTVkPhysicalDeviceMemoryProperties2 = ^TVkPhysicalDeviceMemoryProperties2;
  TVkPhysicalDeviceSparseImageFormatInfo2 = VkPhysicalDeviceSparseImageFormatInfo2;
  pTVkPhysicalDeviceSparseImageFormatInfo2 = ^TVkPhysicalDeviceSparseImageFormatInfo2;
  TVkSparseImageFormatProperties2 = VkSparseImageFormatProperties2;
  pTVkSparseImageFormatProperties2 = ^TVkSparseImageFormatProperties2;
  TVkPhysicalDeviceExternalBufferInfo = VkPhysicalDeviceExternalBufferInfo;
  pTVkPhysicalDeviceExternalBufferInfo = ^TVkPhysicalDeviceExternalBufferInfo;
  TVkExternalBufferProperties = VkExternalBufferProperties;
  pTVkExternalBufferProperties = ^TVkExternalBufferProperties;
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  TVkMemoryGetWin32HandleInfoKHR = VkMemoryGetWin32HandleInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  pTVkMemoryGetWin32HandleInfoKHR = ^TVkMemoryGetWin32HandleInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  TVkMemoryWin32HandlePropertiesKHR = VkMemoryWin32HandlePropertiesKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  pTVkMemoryWin32HandlePropertiesKHR = ^TVkMemoryWin32HandlePropertiesKHR;  {$endif}
  TVkMemoryGetFdInfoKHR = VkMemoryGetFdInfoKHR;
  pTVkMemoryGetFdInfoKHR = ^TVkMemoryGetFdInfoKHR;
  Tint = integer;
  pTint = ^Tint;
  TVkMemoryFdPropertiesKHR = VkMemoryFdPropertiesKHR;
  pTVkMemoryFdPropertiesKHR = ^TVkMemoryFdPropertiesKHR;
  TVkPhysicalDeviceExternalSemaphoreInfo = VkPhysicalDeviceExternalSemaphoreInfo;
  pTVkPhysicalDeviceExternalSemaphoreInfo = ^TVkPhysicalDeviceExternalSemaphoreInfo;
  TVkExternalSemaphoreProperties = VkExternalSemaphoreProperties;
  pTVkExternalSemaphoreProperties = ^TVkExternalSemaphoreProperties;
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  TVkSemaphoreGetWin32HandleInfoKHR = VkSemaphoreGetWin32HandleInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  pTVkSemaphoreGetWin32HandleInfoKHR = ^TVkSemaphoreGetWin32HandleInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  TVkImportSemaphoreWin32HandleInfoKHR = VkImportSemaphoreWin32HandleInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  pTVkImportSemaphoreWin32HandleInfoKHR = ^TVkImportSemaphoreWin32HandleInfoKHR;  {$endif}
  TVkSemaphoreGetFdInfoKHR = VkSemaphoreGetFdInfoKHR;
  pTVkSemaphoreGetFdInfoKHR = ^TVkSemaphoreGetFdInfoKHR;
  TVkImportSemaphoreFdInfoKHR = VkImportSemaphoreFdInfoKHR;
  pTVkImportSemaphoreFdInfoKHR = ^TVkImportSemaphoreFdInfoKHR;
  TVkPhysicalDeviceExternalFenceInfo = VkPhysicalDeviceExternalFenceInfo;
  pTVkPhysicalDeviceExternalFenceInfo = ^TVkPhysicalDeviceExternalFenceInfo;
  TVkExternalFenceProperties = VkExternalFenceProperties;
  pTVkExternalFenceProperties = ^TVkExternalFenceProperties;
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  TVkFenceGetWin32HandleInfoKHR = VkFenceGetWin32HandleInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  pTVkFenceGetWin32HandleInfoKHR = ^TVkFenceGetWin32HandleInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  TVkImportFenceWin32HandleInfoKHR = VkImportFenceWin32HandleInfoKHR;  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  pTVkImportFenceWin32HandleInfoKHR = ^TVkImportFenceWin32HandleInfoKHR;  {$endif}
  TVkFenceGetFdInfoKHR = VkFenceGetFdInfoKHR;
  pTVkFenceGetFdInfoKHR = ^TVkFenceGetFdInfoKHR;
  TVkImportFenceFdInfoKHR = VkImportFenceFdInfoKHR;
  pTVkImportFenceFdInfoKHR = ^TVkImportFenceFdInfoKHR;
  TVkDisplayPowerInfoEXT = VkDisplayPowerInfoEXT;
  pTVkDisplayPowerInfoEXT = ^TVkDisplayPowerInfoEXT;
  TVkDeviceEventInfoEXT = VkDeviceEventInfoEXT;
  pTVkDeviceEventInfoEXT = ^TVkDeviceEventInfoEXT;
  TVkDisplayEventInfoEXT = VkDisplayEventInfoEXT;
  pTVkDisplayEventInfoEXT = ^TVkDisplayEventInfoEXT;
  Tuint64_t = uint64_t;
  pTuint64_t = ^Tuint64_t;
  TVkSurfaceCapabilities2EXT = VkSurfaceCapabilities2EXT;
  pTVkSurfaceCapabilities2EXT = ^TVkSurfaceCapabilities2EXT;
  TVkPhysicalDeviceGroupProperties = VkPhysicalDeviceGroupProperties;
  pTVkPhysicalDeviceGroupProperties = ^TVkPhysicalDeviceGroupProperties;
  TVkPeerMemoryFeatureFlags = VkPeerMemoryFeatureFlags;
  pTVkPeerMemoryFeatureFlags = ^TVkPeerMemoryFeatureFlags;
  TVkBindBufferMemoryInfo = VkBindBufferMemoryInfo;
  pTVkBindBufferMemoryInfo = ^TVkBindBufferMemoryInfo;
  TVkBindImageMemoryInfo = VkBindImageMemoryInfo;
  pTVkBindImageMemoryInfo = ^TVkBindImageMemoryInfo;
  TVkDeviceGroupPresentCapabilitiesKHR = VkDeviceGroupPresentCapabilitiesKHR;
  pTVkDeviceGroupPresentCapabilitiesKHR = ^TVkDeviceGroupPresentCapabilitiesKHR;
  TVkDeviceGroupPresentModeFlagsKHR = VkDeviceGroupPresentModeFlagsKHR;
  pTVkDeviceGroupPresentModeFlagsKHR = ^TVkDeviceGroupPresentModeFlagsKHR;
  TVkAcquireNextImageInfoKHR = VkAcquireNextImageInfoKHR;
  pTVkAcquireNextImageInfoKHR = ^TVkAcquireNextImageInfoKHR;
  TVkDescriptorUpdateTemplateCreateInfo = VkDescriptorUpdateTemplateCreateInfo;
  pTVkDescriptorUpdateTemplateCreateInfo = ^TVkDescriptorUpdateTemplateCreateInfo;
  TVkDescriptorUpdateTemplate = VkDescriptorUpdateTemplate;
  pTVkDescriptorUpdateTemplate = ^TVkDescriptorUpdateTemplate;
  TVkHdrMetadataEXT = VkHdrMetadataEXT;
  pTVkHdrMetadataEXT = ^TVkHdrMetadataEXT;
  TVkRefreshCycleDurationGOOGLE = VkRefreshCycleDurationGOOGLE;
  pTVkRefreshCycleDurationGOOGLE = ^TVkRefreshCycleDurationGOOGLE;
  TVkPastPresentationTimingGOOGLE = VkPastPresentationTimingGOOGLE;
  pTVkPastPresentationTimingGOOGLE = ^TVkPastPresentationTimingGOOGLE;
  {$ifdef VK_USE_PLATFORM_IOS_MVK}  TVkIOSSurfaceCreateInfoMVK = VkIOSSurfaceCreateInfoMVK;  {$endif}
  {$ifdef VK_USE_PLATFORM_IOS_MVK}  pTVkIOSSurfaceCreateInfoMVK = ^TVkIOSSurfaceCreateInfoMVK;  {$endif}
  {$ifdef VK_USE_PLATFORM_MACOS_MVK}  TVkMacOSSurfaceCreateInfoMVK = VkMacOSSurfaceCreateInfoMVK;  {$endif}
  {$ifdef VK_USE_PLATFORM_MACOS_MVK}  pTVkMacOSSurfaceCreateInfoMVK = ^TVkMacOSSurfaceCreateInfoMVK;  {$endif}
  TVkViewportWScalingNV = VkViewportWScalingNV;
  pTVkViewportWScalingNV = ^TVkViewportWScalingNV;
  TVkSampleLocationsInfoEXT = VkSampleLocationsInfoEXT;
  pTVkSampleLocationsInfoEXT = ^TVkSampleLocationsInfoEXT;
  TVkMultisamplePropertiesEXT = VkMultisamplePropertiesEXT;
  pTVkMultisamplePropertiesEXT = ^TVkMultisamplePropertiesEXT;
  TVkPhysicalDeviceSurfaceInfo2KHR = VkPhysicalDeviceSurfaceInfo2KHR;
  pTVkPhysicalDeviceSurfaceInfo2KHR = ^TVkPhysicalDeviceSurfaceInfo2KHR;
  TVkSurfaceCapabilities2KHR = VkSurfaceCapabilities2KHR;
  pTVkSurfaceCapabilities2KHR = ^TVkSurfaceCapabilities2KHR;
  TVkSurfaceFormat2KHR = VkSurfaceFormat2KHR;
  pTVkSurfaceFormat2KHR = ^TVkSurfaceFormat2KHR;
  TVkDisplayProperties2KHR = VkDisplayProperties2KHR;
  pTVkDisplayProperties2KHR = ^TVkDisplayProperties2KHR;
  TVkDisplayPlaneProperties2KHR = VkDisplayPlaneProperties2KHR;
  pTVkDisplayPlaneProperties2KHR = ^TVkDisplayPlaneProperties2KHR;
  TVkDisplayModeProperties2KHR = VkDisplayModeProperties2KHR;
  pTVkDisplayModeProperties2KHR = ^TVkDisplayModeProperties2KHR;
  TVkDisplayPlaneInfo2KHR = VkDisplayPlaneInfo2KHR;
  pTVkDisplayPlaneInfo2KHR = ^TVkDisplayPlaneInfo2KHR;
  TVkDisplayPlaneCapabilities2KHR = VkDisplayPlaneCapabilities2KHR;
  pTVkDisplayPlaneCapabilities2KHR = ^TVkDisplayPlaneCapabilities2KHR;
  TVkBufferMemoryRequirementsInfo2 = VkBufferMemoryRequirementsInfo2;
  pTVkBufferMemoryRequirementsInfo2 = ^TVkBufferMemoryRequirementsInfo2;
  TVkMemoryRequirements2 = VkMemoryRequirements2;
  pTVkMemoryRequirements2 = ^TVkMemoryRequirements2;
  TVkImageMemoryRequirementsInfo2 = VkImageMemoryRequirementsInfo2;
  pTVkImageMemoryRequirementsInfo2 = ^TVkImageMemoryRequirementsInfo2;
  TVkImageSparseMemoryRequirementsInfo2 = VkImageSparseMemoryRequirementsInfo2;
  pTVkImageSparseMemoryRequirementsInfo2 = ^TVkImageSparseMemoryRequirementsInfo2;
  TVkSparseImageMemoryRequirements2 = VkSparseImageMemoryRequirements2;
  pTVkSparseImageMemoryRequirements2 = ^TVkSparseImageMemoryRequirements2;
  TVkSamplerYcbcrConversionCreateInfo = VkSamplerYcbcrConversionCreateInfo;
  pTVkSamplerYcbcrConversionCreateInfo = ^TVkSamplerYcbcrConversionCreateInfo;
  TVkSamplerYcbcrConversion = VkSamplerYcbcrConversion;
  pTVkSamplerYcbcrConversion = ^TVkSamplerYcbcrConversion;
  TVkDeviceQueueInfo2 = VkDeviceQueueInfo2;
  pTVkDeviceQueueInfo2 = ^TVkDeviceQueueInfo2;
  TVkValidationCacheCreateInfoEXT = VkValidationCacheCreateInfoEXT;
  pTVkValidationCacheCreateInfoEXT = ^TVkValidationCacheCreateInfoEXT;
  TVkValidationCacheEXT = VkValidationCacheEXT;
  pTVkValidationCacheEXT = ^TVkValidationCacheEXT;
  TVkDescriptorSetLayoutSupport = VkDescriptorSetLayoutSupport;
  pTVkDescriptorSetLayoutSupport = ^TVkDescriptorSetLayoutSupport;
  TVkDebugUtilsObjectNameInfoEXT = VkDebugUtilsObjectNameInfoEXT;
  pTVkDebugUtilsObjectNameInfoEXT = ^TVkDebugUtilsObjectNameInfoEXT;
  TVkDebugUtilsObjectTagInfoEXT = VkDebugUtilsObjectTagInfoEXT;
  pTVkDebugUtilsObjectTagInfoEXT = ^TVkDebugUtilsObjectTagInfoEXT;
  TVkDebugUtilsLabelEXT = VkDebugUtilsLabelEXT;
  pTVkDebugUtilsLabelEXT = ^TVkDebugUtilsLabelEXT;
  TVkDebugUtilsMessengerCreateInfoEXT = VkDebugUtilsMessengerCreateInfoEXT;
  pTVkDebugUtilsMessengerCreateInfoEXT = ^TVkDebugUtilsMessengerCreateInfoEXT;
  TVkDebugUtilsMessengerEXT = VkDebugUtilsMessengerEXT;
  pTVkDebugUtilsMessengerEXT = ^TVkDebugUtilsMessengerEXT;
  TVkDebugUtilsMessengerCallbackDataEXT = VkDebugUtilsMessengerCallbackDataEXT;
  pTVkDebugUtilsMessengerCallbackDataEXT = ^TVkDebugUtilsMessengerCallbackDataEXT;
  TVkMemoryHostPointerPropertiesEXT = VkMemoryHostPointerPropertiesEXT;
  pTVkMemoryHostPointerPropertiesEXT = ^TVkMemoryHostPointerPropertiesEXT;
  TVkRenderPassCreateInfo2KHR = VkRenderPassCreateInfo2KHR;
  pTVkRenderPassCreateInfo2KHR = ^TVkRenderPassCreateInfo2KHR;
  TVkSubpassBeginInfoKHR = VkSubpassBeginInfoKHR;
  pTVkSubpassBeginInfoKHR = ^TVkSubpassBeginInfoKHR;
  TVkSubpassEndInfoKHR = VkSubpassEndInfoKHR;
  pTVkSubpassEndInfoKHR = ^TVkSubpassEndInfoKHR;
  TAHardwareBuffer = AHardwareBuffer;
  pTAHardwareBuffer = ^TAHardwareBuffer;
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  TVkAndroidHardwareBufferPropertiesANDROID = VkAndroidHardwareBufferPropertiesANDROID;  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  pTVkAndroidHardwareBufferPropertiesANDROID = ^TVkAndroidHardwareBufferPropertiesANDROID;  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  TVkMemoryGetAndroidHardwareBufferInfoANDROID = VkMemoryGetAndroidHardwareBufferInfoANDROID;  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  pTVkMemoryGetAndroidHardwareBufferInfoANDROID = ^TVkMemoryGetAndroidHardwareBufferInfoANDROID;  {$endif}
  pppTAHardwareBuffer = ^pTAHardwareBuffer;
  TVkCheckpointDataNV = VkCheckpointDataNV;
  pTVkCheckpointDataNV = ^TVkCheckpointDataNV;

type
  Tvk = class
  private
    procedure LoadPointers( const Instance: vkInstance; UseInstance: boolean = true );
  public
    procedure ReloadPointers( const Instance: vkInstance );
  public


  vkCreateInstance: function ( const pCreateInfo: pTVkInstanceCreateInfo; const pAllocator: pTVkAllocationCallbacks; pInstance: pTVkInstance ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyInstance: procedure ( instance: VkInstance; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkEnumeratePhysicalDevices: function ( instance: VkInstance; pPhysicalDeviceCount: pTuint32_t; pPhysicalDevices: pTVkPhysicalDevice ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDeviceProcAddr: function ( device: VkDevice; const pName: pansichar ): pointer;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetInstanceProcAddr: function ( instance: VkInstance; const pName: pansichar ): pointer;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceProperties: procedure ( physicalDevice: VkPhysicalDevice; pProperties: pTVkPhysicalDeviceProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceQueueFamilyProperties: procedure ( physicalDevice: VkPhysicalDevice; pQueueFamilyPropertyCount: pTuint32_t; pQueueFamilyProperties: pTVkQueueFamilyProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceMemoryProperties: procedure ( physicalDevice: VkPhysicalDevice; pMemoryProperties: pTVkPhysicalDeviceMemoryProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceFeatures: procedure ( physicalDevice: VkPhysicalDevice; pFeatures: pTVkPhysicalDeviceFeatures );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceFormatProperties: procedure ( physicalDevice: VkPhysicalDevice; format: VkFormat; pFormatProperties: pTVkFormatProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceImageFormatProperties: function ( physicalDevice: VkPhysicalDevice; format: VkFormat; _type: VkImageType; tiling: VkImageTiling; usage: VkImageUsageFlags; flags: VkImageCreateFlags; pImageFormatProperties: pTVkImageFormatProperties ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateDevice: function ( physicalDevice: VkPhysicalDevice; const pCreateInfo: pTVkDeviceCreateInfo; const pAllocator: pTVkAllocationCallbacks; pDevice: pTVkDevice ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyDevice: procedure ( device: VkDevice; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkEnumerateInstanceVersion: function ( pApiVersion: pTuint32_t ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkEnumerateInstanceLayerProperties: function ( pPropertyCount: pTuint32_t; pProperties: pTVkLayerProperties ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkEnumerateInstanceExtensionProperties: function ( const pLayerName: pansichar; pPropertyCount: pTuint32_t; pProperties: pTVkExtensionProperties ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkEnumerateDeviceLayerProperties: function ( physicalDevice: VkPhysicalDevice; pPropertyCount: pTuint32_t; pProperties: pTVkLayerProperties ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkEnumerateDeviceExtensionProperties: function ( physicalDevice: VkPhysicalDevice; const pLayerName: pansichar; pPropertyCount: pTuint32_t; pProperties: pTVkExtensionProperties ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDeviceQueue: procedure ( device: VkDevice; queueFamilyIndex: uint32_t; queueIndex: uint32_t; pQueue: pTVkQueue );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkQueueSubmit: function ( queue: VkQueue; submitCount: uint32_t; const pSubmits: pTVkSubmitInfo; fence: VkFence ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkQueueWaitIdle: function ( queue: VkQueue ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDeviceWaitIdle: function ( device: VkDevice ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkAllocateMemory: function ( device: VkDevice; const pAllocateInfo: pTVkMemoryAllocateInfo; const pAllocator: pTVkAllocationCallbacks; pMemory: pTVkDeviceMemory ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkFreeMemory: procedure ( device: VkDevice; memory: VkDeviceMemory; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkMapMemory: function ( device: VkDevice; memory: VkDeviceMemory; offset: VkDeviceSize; size: VkDeviceSize; flags: VkMemoryMapFlags; ppData: ppointer ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkUnmapMemory: procedure ( device: VkDevice; memory: VkDeviceMemory );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkFlushMappedMemoryRanges: function ( device: VkDevice; memoryRangeCount: uint32_t; const pMemoryRanges: pTVkMappedMemoryRange ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkInvalidateMappedMemoryRanges: function ( device: VkDevice; memoryRangeCount: uint32_t; const pMemoryRanges: pTVkMappedMemoryRange ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDeviceMemoryCommitment: procedure ( device: VkDevice; memory: VkDeviceMemory; pCommittedMemoryInBytes: pTVkDeviceSize );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetBufferMemoryRequirements: procedure ( device: VkDevice; buffer: VkBuffer; pMemoryRequirements: pTVkMemoryRequirements );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkBindBufferMemory: function ( device: VkDevice; buffer: VkBuffer; memory: VkDeviceMemory; memoryOffset: VkDeviceSize ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetImageMemoryRequirements: procedure ( device: VkDevice; image: VkImage; pMemoryRequirements: pTVkMemoryRequirements );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkBindImageMemory: function ( device: VkDevice; image: VkImage; memory: VkDeviceMemory; memoryOffset: VkDeviceSize ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetImageSparseMemoryRequirements: procedure ( device: VkDevice; image: VkImage; pSparseMemoryRequirementCount: pTuint32_t; pSparseMemoryRequirements: pTVkSparseImageMemoryRequirements );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceSparseImageFormatProperties: procedure ( physicalDevice: VkPhysicalDevice; format: VkFormat; _type: VkImageType; samples: VkSampleCountFlagBits; usage: VkImageUsageFlags; tiling: VkImageTiling; pPropertyCount: pTuint32_t; pProperties: pTVkSparseImageFormatProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkQueueBindSparse: function ( queue: VkQueue; bindInfoCount: uint32_t; const pBindInfo: pTVkBindSparseInfo; fence: VkFence ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateFence: function ( device: VkDevice; const pCreateInfo: pTVkFenceCreateInfo; const pAllocator: pTVkAllocationCallbacks; pFence: pTVkFence ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyFence: procedure ( device: VkDevice; fence: VkFence; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkResetFences: function ( device: VkDevice; fenceCount: uint32_t; const pFences: pTVkFence ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetFenceStatus: function ( device: VkDevice; fence: VkFence ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkWaitForFences: function ( device: VkDevice; fenceCount: uint32_t; const pFences: pTVkFence; waitAll: VkBool32; timeout: uint64_t ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateSemaphore: function ( device: VkDevice; const pCreateInfo: pTVkSemaphoreCreateInfo; const pAllocator: pTVkAllocationCallbacks; pSemaphore: pTVkSemaphore ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroySemaphore: procedure ( device: VkDevice; semaphore: VkSemaphore; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateEvent: function ( device: VkDevice; const pCreateInfo: pTVkEventCreateInfo; const pAllocator: pTVkAllocationCallbacks; pEvent: pTVkEvent ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyEvent: procedure ( device: VkDevice; event: VkEvent; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetEventStatus: function ( device: VkDevice; event: VkEvent ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkSetEvent: function ( device: VkDevice; event: VkEvent ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkResetEvent: function ( device: VkDevice; event: VkEvent ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateQueryPool: function ( device: VkDevice; const pCreateInfo: pTVkQueryPoolCreateInfo; const pAllocator: pTVkAllocationCallbacks; pQueryPool: pTVkQueryPool ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyQueryPool: procedure ( device: VkDevice; queryPool: VkQueryPool; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetQueryPoolResults: function ( device: VkDevice; queryPool: VkQueryPool; firstQuery: uint32_t; queryCount: uint32_t; dataSize: size_t; pData: pointer; stride: VkDeviceSize; flags: VkQueryResultFlags ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateBuffer: function ( device: VkDevice; const pCreateInfo: pTVkBufferCreateInfo; const pAllocator: pTVkAllocationCallbacks; pBuffer: pTVkBuffer ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyBuffer: procedure ( device: VkDevice; buffer: VkBuffer; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateBufferView: function ( device: VkDevice; const pCreateInfo: pTVkBufferViewCreateInfo; const pAllocator: pTVkAllocationCallbacks; pView: pTVkBufferView ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyBufferView: procedure ( device: VkDevice; bufferView: VkBufferView; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateImage: function ( device: VkDevice; const pCreateInfo: pTVkImageCreateInfo; const pAllocator: pTVkAllocationCallbacks; pImage: pTVkImage ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyImage: procedure ( device: VkDevice; image: VkImage; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetImageSubresourceLayout: procedure ( device: VkDevice; image: VkImage; const pSubresource: pTVkImageSubresource; pLayout: pTVkSubresourceLayout );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateImageView: function ( device: VkDevice; const pCreateInfo: pTVkImageViewCreateInfo; const pAllocator: pTVkAllocationCallbacks; pView: pTVkImageView ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyImageView: procedure ( device: VkDevice; imageView: VkImageView; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateShaderModule: function ( device: VkDevice; const pCreateInfo: pTVkShaderModuleCreateInfo; const pAllocator: pTVkAllocationCallbacks; pShaderModule: pTVkShaderModule ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyShaderModule: procedure ( device: VkDevice; shaderModule: VkShaderModule; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreatePipelineCache: function ( device: VkDevice; const pCreateInfo: pTVkPipelineCacheCreateInfo; const pAllocator: pTVkAllocationCallbacks; pPipelineCache: pTVkPipelineCache ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyPipelineCache: procedure ( device: VkDevice; pipelineCache: VkPipelineCache; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPipelineCacheData: function ( device: VkDevice; pipelineCache: VkPipelineCache; pDataSize: pTsize_t; pData: pointer ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkMergePipelineCaches: function ( device: VkDevice; dstCache: VkPipelineCache; srcCacheCount: uint32_t; const pSrcCaches: pTVkPipelineCache ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateGraphicsPipelines: function ( device: VkDevice; pipelineCache: VkPipelineCache; createInfoCount: uint32_t; const pCreateInfos: pTVkGraphicsPipelineCreateInfo; const pAllocator: pTVkAllocationCallbacks; pPipelines: pTVkPipeline ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateComputePipelines: function ( device: VkDevice; pipelineCache: VkPipelineCache; createInfoCount: uint32_t; const pCreateInfos: pTVkComputePipelineCreateInfo; const pAllocator: pTVkAllocationCallbacks; pPipelines: pTVkPipeline ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyPipeline: procedure ( device: VkDevice; pipeline: VkPipeline; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreatePipelineLayout: function ( device: VkDevice; const pCreateInfo: pTVkPipelineLayoutCreateInfo; const pAllocator: pTVkAllocationCallbacks; pPipelineLayout: pTVkPipelineLayout ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyPipelineLayout: procedure ( device: VkDevice; pipelineLayout: VkPipelineLayout; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateSampler: function ( device: VkDevice; const pCreateInfo: pTVkSamplerCreateInfo; const pAllocator: pTVkAllocationCallbacks; pSampler: pTVkSampler ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroySampler: procedure ( device: VkDevice; sampler: VkSampler; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateDescriptorSetLayout: function ( device: VkDevice; const pCreateInfo: pTVkDescriptorSetLayoutCreateInfo; const pAllocator: pTVkAllocationCallbacks; pSetLayout: pTVkDescriptorSetLayout ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyDescriptorSetLayout: procedure ( device: VkDevice; descriptorSetLayout: VkDescriptorSetLayout; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateDescriptorPool: function ( device: VkDevice; const pCreateInfo: pTVkDescriptorPoolCreateInfo; const pAllocator: pTVkAllocationCallbacks; pDescriptorPool: pTVkDescriptorPool ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyDescriptorPool: procedure ( device: VkDevice; descriptorPool: VkDescriptorPool; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkResetDescriptorPool: function ( device: VkDevice; descriptorPool: VkDescriptorPool; flags: VkDescriptorPoolResetFlags ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkAllocateDescriptorSets: function ( device: VkDevice; const pAllocateInfo: pTVkDescriptorSetAllocateInfo; pDescriptorSets: pTVkDescriptorSet ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkFreeDescriptorSets: function ( device: VkDevice; descriptorPool: VkDescriptorPool; descriptorSetCount: uint32_t; const pDescriptorSets: pTVkDescriptorSet ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkUpdateDescriptorSets: procedure ( device: VkDevice; descriptorWriteCount: uint32_t; const pDescriptorWrites: pTVkWriteDescriptorSet; descriptorCopyCount: uint32_t; const pDescriptorCopies: pTVkCopyDescriptorSet );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateFramebuffer: function ( device: VkDevice; const pCreateInfo: pTVkFramebufferCreateInfo; const pAllocator: pTVkAllocationCallbacks; pFramebuffer: pTVkFramebuffer ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyFramebuffer: procedure ( device: VkDevice; framebuffer: VkFramebuffer; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateRenderPass: function ( device: VkDevice; const pCreateInfo: pTVkRenderPassCreateInfo; const pAllocator: pTVkAllocationCallbacks; pRenderPass: pTVkRenderPass ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyRenderPass: procedure ( device: VkDevice; renderPass: VkRenderPass; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetRenderAreaGranularity: procedure ( device: VkDevice; renderPass: VkRenderPass; pGranularity: pTVkExtent2D );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateCommandPool: function ( device: VkDevice; const pCreateInfo: pTVkCommandPoolCreateInfo; const pAllocator: pTVkAllocationCallbacks; pCommandPool: pTVkCommandPool ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyCommandPool: procedure ( device: VkDevice; commandPool: VkCommandPool; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkResetCommandPool: function ( device: VkDevice; commandPool: VkCommandPool; flags: VkCommandPoolResetFlags ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkAllocateCommandBuffers: function ( device: VkDevice; const pAllocateInfo: pTVkCommandBufferAllocateInfo; pCommandBuffers: pTVkCommandBuffer ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkFreeCommandBuffers: procedure ( device: VkDevice; commandPool: VkCommandPool; commandBufferCount: uint32_t; const pCommandBuffers: pTVkCommandBuffer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkBeginCommandBuffer: function ( commandBuffer: VkCommandBuffer; const pBeginInfo: pTVkCommandBufferBeginInfo ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkEndCommandBuffer: function ( commandBuffer: VkCommandBuffer ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkResetCommandBuffer: function ( commandBuffer: VkCommandBuffer; flags: VkCommandBufferResetFlags ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdBindPipeline: procedure ( commandBuffer: VkCommandBuffer; pipelineBindPoint: VkPipelineBindPoint; pipeline: VkPipeline );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetViewport: procedure ( commandBuffer: VkCommandBuffer; firstViewport: uint32_t; viewportCount: uint32_t; const pViewports: pTVkViewport );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetScissor: procedure ( commandBuffer: VkCommandBuffer; firstScissor: uint32_t; scissorCount: uint32_t; const pScissors: pTVkRect2D );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetLineWidth: procedure ( commandBuffer: VkCommandBuffer; lineWidth: float );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetDepthBias: procedure ( commandBuffer: VkCommandBuffer; depthBiasConstantFactor: float; depthBiasClamp: float; depthBiasSlopeFactor: float );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetBlendConstants: procedure ( commandBuffer: VkCommandBuffer; const blendConstants: float );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetDepthBounds: procedure ( commandBuffer: VkCommandBuffer; minDepthBounds: float; maxDepthBounds: float );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetStencilCompareMask: procedure ( commandBuffer: VkCommandBuffer; faceMask: VkStencilFaceFlags; compareMask: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetStencilWriteMask: procedure ( commandBuffer: VkCommandBuffer; faceMask: VkStencilFaceFlags; writeMask: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetStencilReference: procedure ( commandBuffer: VkCommandBuffer; faceMask: VkStencilFaceFlags; reference: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdBindDescriptorSets: procedure ( commandBuffer: VkCommandBuffer; pipelineBindPoint: VkPipelineBindPoint; layout: VkPipelineLayout; firstSet: uint32_t; descriptorSetCount: uint32_t; const pDescriptorSets: pTVkDescriptorSet; dynamicOffsetCount: uint32_t; const pDynamicOffsets: pTuint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdBindIndexBuffer: procedure ( commandBuffer: VkCommandBuffer; buffer: VkBuffer; offset: VkDeviceSize; indexType: VkIndexType );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdBindVertexBuffers: procedure ( commandBuffer: VkCommandBuffer; firstBinding: uint32_t; bindingCount: uint32_t; const pBuffers: pTVkBuffer; const pOffsets: pTVkDeviceSize );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDraw: procedure ( commandBuffer: VkCommandBuffer; vertexCount: uint32_t; instanceCount: uint32_t; firstVertex: uint32_t; firstInstance: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDrawIndexed: procedure ( commandBuffer: VkCommandBuffer; indexCount: uint32_t; instanceCount: uint32_t; firstIndex: uint32_t; vertexOffset: int32_t; firstInstance: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDrawIndirect: procedure ( commandBuffer: VkCommandBuffer; buffer: VkBuffer; offset: VkDeviceSize; drawCount: uint32_t; stride: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDrawIndexedIndirect: procedure ( commandBuffer: VkCommandBuffer; buffer: VkBuffer; offset: VkDeviceSize; drawCount: uint32_t; stride: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDispatch: procedure ( commandBuffer: VkCommandBuffer; groupCountX: uint32_t; groupCountY: uint32_t; groupCount: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDispatchIndirect: procedure ( commandBuffer: VkCommandBuffer; buffer: VkBuffer; offset: VkDeviceSize );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdCopyBuffer: procedure ( commandBuffer: VkCommandBuffer; srcBuffer: VkBuffer; dstBuffer: VkBuffer; regionCount: uint32_t; const pRegions: pTVkBufferCopy );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdCopyImage: procedure ( commandBuffer: VkCommandBuffer; srcImage: VkImage; srcImageLayout: VkImageLayout; dstImage: VkImage; dstImageLayout: VkImageLayout; regionCount: uint32_t; const pRegions: pTVkImageCopy );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdBlitImage: procedure ( commandBuffer: VkCommandBuffer; srcImage: VkImage; srcImageLayout: VkImageLayout; dstImage: VkImage; dstImageLayout: VkImageLayout; regionCount: uint32_t; const pRegions: pTVkImageBlit; filter: VkFilter );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdCopyBufferToImage: procedure ( commandBuffer: VkCommandBuffer; srcBuffer: VkBuffer; dstImage: VkImage; dstImageLayout: VkImageLayout; regionCount: uint32_t; const pRegions: pTVkBufferImageCopy );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdCopyImageToBuffer: procedure ( commandBuffer: VkCommandBuffer; srcImage: VkImage; srcImageLayout: VkImageLayout; dstBuffer: VkBuffer; regionCount: uint32_t; const pRegions: pTVkBufferImageCopy );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdUpdateBuffer: procedure ( commandBuffer: VkCommandBuffer; dstBuffer: VkBuffer; dstOffset: VkDeviceSize; dataSize: VkDeviceSize; const pData: pointer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdFillBuffer: procedure ( commandBuffer: VkCommandBuffer; dstBuffer: VkBuffer; dstOffset: VkDeviceSize; size: VkDeviceSize; data: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdClearColorImage: procedure ( commandBuffer: VkCommandBuffer; image: VkImage; imageLayout: VkImageLayout; const pColor: pTVkClearColorValue; rangeCount: uint32_t; const pRanges: pTVkImageSubresourceRange );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdClearDepthStencilImage: procedure ( commandBuffer: VkCommandBuffer; image: VkImage; imageLayout: VkImageLayout; const pDepthStencil: pTVkClearDepthStencilValue; rangeCount: uint32_t; const pRanges: pTVkImageSubresourceRange );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdClearAttachments: procedure ( commandBuffer: VkCommandBuffer; attachmentCount: uint32_t; const pAttachments: pTVkClearAttachment; rectCount: uint32_t; const pRects: pTVkClearRect );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdResolveImage: procedure ( commandBuffer: VkCommandBuffer; srcImage: VkImage; srcImageLayout: VkImageLayout; dstImage: VkImage; dstImageLayout: VkImageLayout; regionCount: uint32_t; const pRegions: pTVkImageResolve );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetEvent: procedure ( commandBuffer: VkCommandBuffer; event: VkEvent; stageMask: VkPipelineStageFlags );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdResetEvent: procedure ( commandBuffer: VkCommandBuffer; event: VkEvent; stageMask: VkPipelineStageFlags );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdWaitEvents: procedure ( commandBuffer: VkCommandBuffer; eventCount: uint32_t; const pEvents: pTVkEvent; srcStageMask: VkPipelineStageFlags; dstStageMask: VkPipelineStageFlags; memoryBarrierCount: uint32_t; const pMemoryBarriers: pTVkMemoryBarrier; bufferMemoryBarrierCount: uint32_t; const pBufferMemoryBarriers: pTVkBufferMemoryBarrier; imageMemoryBarrierCount: uint32_t; const pImageMemoryBarriers: pTVkImageMemoryBarrier );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdPipelineBarrier: procedure ( commandBuffer: VkCommandBuffer; srcStageMask: VkPipelineStageFlags; dstStageMask: VkPipelineStageFlags; dependencyFlags: VkDependencyFlags; memoryBarrierCount: uint32_t; const pMemoryBarriers: pTVkMemoryBarrier; bufferMemoryBarrierCount: uint32_t; const pBufferMemoryBarriers: pTVkBufferMemoryBarrier; imageMemoryBarrierCount: uint32_t; const pImageMemoryBarriers: pTVkImageMemoryBarrier );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdBeginQuery: procedure ( commandBuffer: VkCommandBuffer; queryPool: VkQueryPool; query: uint32_t; flags: VkQueryControlFlags );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdEndQuery: procedure ( commandBuffer: VkCommandBuffer; queryPool: VkQueryPool; query: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdBeginConditionalRenderingEXT: procedure ( commandBuffer: VkCommandBuffer; const pConditionalRenderingBegin: pTVkConditionalRenderingBeginInfoEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdEndConditionalRenderingEXT: procedure ( commandBuffer: VkCommandBuffer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdResetQueryPool: procedure ( commandBuffer: VkCommandBuffer; queryPool: VkQueryPool; firstQuery: uint32_t; queryCount: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdWriteTimestamp: procedure ( commandBuffer: VkCommandBuffer; pipelineStage: VkPipelineStageFlagBits; queryPool: VkQueryPool; query: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdCopyQueryPoolResults: procedure ( commandBuffer: VkCommandBuffer; queryPool: VkQueryPool; firstQuery: uint32_t; queryCount: uint32_t; dstBuffer: VkBuffer; dstOffset: VkDeviceSize; stride: VkDeviceSize; flags: VkQueryResultFlags );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdPushConstants: procedure ( commandBuffer: VkCommandBuffer; layout: VkPipelineLayout; stageFlags: VkShaderStageFlags; offset: uint32_t; size: uint32_t; const pValues: pointer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdBeginRenderPass: procedure ( commandBuffer: VkCommandBuffer; const pRenderPassBegin: pTVkRenderPassBeginInfo; contents: VkSubpassContents );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdNextSubpass: procedure ( commandBuffer: VkCommandBuffer; contents: VkSubpassContents );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdEndRenderPass: procedure ( commandBuffer: VkCommandBuffer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdExecuteCommands: procedure ( commandBuffer: VkCommandBuffer; commandBufferCount: uint32_t; const pCommandBuffers: pTVkCommandBuffer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  vkCreateAndroidSurfaceKHR: function ( instance: VkInstance; const pCreateInfo: pTVkAndroidSurfaceCreateInfoKHR; const pAllocator: pTVkAllocationCallbacks; pSurface: pTVkSurfaceKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkGetPhysicalDeviceDisplayPropertiesKHR: function ( physicalDevice: VkPhysicalDevice; pPropertyCount: pTuint32_t; pProperties: pTVkDisplayPropertiesKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceDisplayPlanePropertiesKHR: function ( physicalDevice: VkPhysicalDevice; pPropertyCount: pTuint32_t; pProperties: pTVkDisplayPlanePropertiesKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDisplayPlaneSupportedDisplaysKHR: function ( physicalDevice: VkPhysicalDevice; planeIndex: uint32_t; pDisplayCount: pTuint32_t; pDisplays: pTVkDisplayKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDisplayModePropertiesKHR: function ( physicalDevice: VkPhysicalDevice; display: VkDisplayKHR; pPropertyCount: pTuint32_t; pProperties: pTVkDisplayModePropertiesKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateDisplayModeKHR: function ( physicalDevice: VkPhysicalDevice; display: VkDisplayKHR; const pCreateInfo: pTVkDisplayModeCreateInfoKHR; const pAllocator: pTVkAllocationCallbacks; pMode: pTVkDisplayModeKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDisplayPlaneCapabilitiesKHR: function ( physicalDevice: VkPhysicalDevice; mode: VkDisplayModeKHR; planeIndex: uint32_t; pCapabilities: pTVkDisplayPlaneCapabilitiesKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateDisplayPlaneSurfaceKHR: function ( instance: VkInstance; const pCreateInfo: pTVkDisplaySurfaceCreateInfoKHR; const pAllocator: pTVkAllocationCallbacks; pSurface: pTVkSurfaceKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateSharedSwapchainsKHR: function ( device: VkDevice; swapchainCount: uint32_t; const pCreateInfos: pTVkSwapchainCreateInfoKHR; const pAllocator: pTVkAllocationCallbacks; pSwapchains: pTVkSwapchainKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_MIR_KHR}  vkCreateMirSurfaceKHR: function ( instance: VkInstance; const pCreateInfo: pTVkMirSurfaceCreateInfoKHR; const pAllocator: pTVkAllocationCallbacks; pSurface: pTVkSurfaceKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_MIR_KHR}  vkGetPhysicalDeviceMirPresentationSupportKHR: function ( physicalDevice: VkPhysicalDevice; queueFamilyIndex: uint32_t; connection: pTMirConnection ): VkBool32;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkDestroySurfaceKHR: procedure ( instance: VkInstance; surface: VkSurfaceKHR; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceSurfaceSupportKHR: function ( physicalDevice: VkPhysicalDevice; queueFamilyIndex: uint32_t; surface: VkSurfaceKHR; pSupported: pTVkBool32 ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceSurfaceCapabilitiesKHR: function ( physicalDevice: VkPhysicalDevice; surface: VkSurfaceKHR; pSurfaceCapabilities: pTVkSurfaceCapabilitiesKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceSurfaceFormatsKHR: function ( physicalDevice: VkPhysicalDevice; surface: VkSurfaceKHR; pSurfaceFormatCount: pTuint32_t; pSurfaceFormats: pTVkSurfaceFormatKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceSurfacePresentModesKHR: function ( physicalDevice: VkPhysicalDevice; surface: VkSurfaceKHR; pPresentModeCount: pTuint32_t; pPresentModes: pTVkPresentModeKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateSwapchainKHR: function ( device: VkDevice; const pCreateInfo: pTVkSwapchainCreateInfoKHR; const pAllocator: pTVkAllocationCallbacks; pSwapchain: pTVkSwapchainKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroySwapchainKHR: procedure ( device: VkDevice; swapchain: VkSwapchainKHR; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetSwapchainImagesKHR: function ( device: VkDevice; swapchain: VkSwapchainKHR; pSwapchainImageCount: pTuint32_t; pSwapchainImages: pTVkImage ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkAcquireNextImageKHR: function ( device: VkDevice; swapchain: VkSwapchainKHR; timeout: uint64_t; semaphore: VkSemaphore; fence: VkFence; pImageIndex: pTuint32_t ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkQueuePresentKHR: function ( queue: VkQueue; const pPresentInfo: pTVkPresentInfoKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_VI_NN}  vkCreateViSurfaceNN: function ( instance: VkInstance; const pCreateInfo: pTVkViSurfaceCreateInfoNN; const pAllocator: pTVkAllocationCallbacks; pSurface: pTVkSurfaceKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_WAYLAND_KHR}  vkCreateWaylandSurfaceKHR: function ( instance: VkInstance; const pCreateInfo: pTVkWaylandSurfaceCreateInfoKHR; const pAllocator: pTVkAllocationCallbacks; pSurface: pTVkSurfaceKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_WAYLAND_KHR}  vkGetPhysicalDeviceWaylandPresentationSupportKHR: function ( physicalDevice: VkPhysicalDevice; queueFamilyIndex: uint32_t; structdisplay: pTwl_display ): VkBool32;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  vkCreateWin32SurfaceKHR: function ( instance: VkInstance; const pCreateInfo: pTVkWin32SurfaceCreateInfoKHR; const pAllocator: pTVkAllocationCallbacks; pSurface: pTVkSurfaceKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  vkGetPhysicalDeviceWin32PresentationSupportKHR: function ( physicalDevice: VkPhysicalDevice; queueFamilyIndex: uint32_t ): VkBool32;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}  vkCreateXlibSurfaceKHR: function ( instance: VkInstance; const pCreateInfo: pTVkXlibSurfaceCreateInfoKHR; const pAllocator: pTVkAllocationCallbacks; pSurface: pTVkSurfaceKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}  vkGetPhysicalDeviceXlibPresentationSupportKHR: function ( physicalDevice: VkPhysicalDevice; queueFamilyIndex: uint32_t; dpy: pTDisplay; visualID: VisualID ): VkBool32;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_XCB_KHR}  vkCreateXcbSurfaceKHR: function ( instance: VkInstance; const pCreateInfo: pTVkXcbSurfaceCreateInfoKHR; const pAllocator: pTVkAllocationCallbacks; pSurface: pTVkSurfaceKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_XCB_KHR}  vkGetPhysicalDeviceXcbPresentationSupportKHR: function ( physicalDevice: VkPhysicalDevice; queueFamilyIndex: uint32_t; connection: pTxcb_connection_t; visual_id: xcb_visualid_t ): VkBool32;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkCreateDebugReportCallbackEXT: function ( instance: VkInstance; const pCreateInfo: pTVkDebugReportCallbackCreateInfoEXT; const pAllocator: pTVkAllocationCallbacks; pCallback: pTVkDebugReportCallbackEXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyDebugReportCallbackEXT: procedure ( instance: VkInstance; callback: VkDebugReportCallbackEXT; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDebugReportMessageEXT: procedure ( instance: VkInstance; flags: VkDebugReportFlagsEXT; objectType: VkDebugReportObjectTypeEXT; _object: uint64_t; location: size_t; messageCode: int32_t; const pLayerPrefix: pansichar; const pMessage: pansichar );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDebugMarkerSetObjectNameEXT: function ( device: VkDevice; const pNameInfo: pTVkDebugMarkerObjectNameInfoEXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDebugMarkerSetObjectTagEXT: function ( device: VkDevice; const pTagInfo: pTVkDebugMarkerObjectTagInfoEXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDebugMarkerBeginEXT: procedure ( commandBuffer: VkCommandBuffer; const pMarkerInfo: pTVkDebugMarkerMarkerInfoEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDebugMarkerEndEXT: procedure ( commandBuffer: VkCommandBuffer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDebugMarkerInsertEXT: procedure ( commandBuffer: VkCommandBuffer; const pMarkerInfo: pTVkDebugMarkerMarkerInfoEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceExternalImageFormatPropertiesNV: function ( physicalDevice: VkPhysicalDevice; format: VkFormat; _type: VkImageType; tiling: VkImageTiling; usage: VkImageUsageFlags; flags: VkImageCreateFlags; externalHandleType: VkExternalMemoryHandleTypeFlagsNV; pExternalImageFormatProperties: pTVkExternalImageFormatPropertiesNV ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  vkGetMemoryWin32HandleNV: function ( device: VkDevice; memory: VkDeviceMemory; handleType: VkExternalMemoryHandleTypeFlagsNV; pHandle: pTHANDLE ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkCmdDrawIndirectCountAMD: procedure ( commandBuffer: VkCommandBuffer; buffer: VkBuffer; offset: VkDeviceSize; countBuffer: VkBuffer; countBufferOffset: VkDeviceSize; maxDrawCount: uint32_t; stride: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDrawIndexedIndirectCountAMD: procedure ( commandBuffer: VkCommandBuffer; buffer: VkBuffer; offset: VkDeviceSize; countBuffer: VkBuffer; countBufferOffset: VkDeviceSize; maxDrawCount: uint32_t; stride: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdProcessCommandsNVX: procedure ( commandBuffer: VkCommandBuffer; const pProcessCommandsInfo: pTVkCmdProcessCommandsInfoNVX );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdReserveSpaceForCommandsNVX: procedure ( commandBuffer: VkCommandBuffer; const pReserveSpaceInfo: pTVkCmdReserveSpaceForCommandsInfoNVX );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateIndirectCommandsLayoutNVX: function ( device: VkDevice; const pCreateInfo: pTVkIndirectCommandsLayoutCreateInfoNVX; const pAllocator: pTVkAllocationCallbacks; pIndirectCommandsLayout: pTVkIndirectCommandsLayoutNVX ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyIndirectCommandsLayoutNVX: procedure ( device: VkDevice; indirectCommandsLayout: VkIndirectCommandsLayoutNVX; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateObjectTableNVX: function ( device: VkDevice; const pCreateInfo: pTVkObjectTableCreateInfoNVX; const pAllocator: pTVkAllocationCallbacks; pObjectTable: pTVkObjectTableNVX ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyObjectTableNVX: procedure ( device: VkDevice; objectTable: VkObjectTableNVX; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkRegisterObjectsNVX: function ( device: VkDevice; objectTable: VkObjectTableNVX; objectCount: uint32_t; const constppObjectTableEntries: pppTVkObjectTableEntryNVX; const pObjectIndices: pTuint32_t ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkUnregisterObjectsNVX: function ( device: VkDevice; objectTable: VkObjectTableNVX; objectCount: uint32_t; const pObjectEntryTypes: pTVkObjectEntryTypeNVX; const pObjectIndices: pTuint32_t ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX: procedure ( physicalDevice: VkPhysicalDevice; pFeatures: pTVkDeviceGeneratedCommandsFeaturesNVX; pLimits: pTVkDeviceGeneratedCommandsLimitsNVX );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceFeatures2: procedure ( physicalDevice: VkPhysicalDevice; pFeatures: pTVkPhysicalDeviceFeatures2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceFeatures2KHR: procedure ( physicalDevice: VkPhysicalDevice; pFeatures: pTVkPhysicalDeviceFeatures2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceProperties2: procedure ( physicalDevice: VkPhysicalDevice; pProperties: pTVkPhysicalDeviceProperties2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceProperties2KHR: procedure ( physicalDevice: VkPhysicalDevice; pProperties: pTVkPhysicalDeviceProperties2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceFormatProperties2: procedure ( physicalDevice: VkPhysicalDevice; format: VkFormat; pFormatProperties: pTVkFormatProperties2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceFormatProperties2KHR: procedure ( physicalDevice: VkPhysicalDevice; format: VkFormat; pFormatProperties: pTVkFormatProperties2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceImageFormatProperties2: function ( physicalDevice: VkPhysicalDevice; const pImageFormatInfo: pTVkPhysicalDeviceImageFormatInfo2; pImageFormatProperties: pTVkImageFormatProperties2 ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceImageFormatProperties2KHR: function ( physicalDevice: VkPhysicalDevice; const pImageFormatInfo: pTVkPhysicalDeviceImageFormatInfo2; pImageFormatProperties: pTVkImageFormatProperties2 ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceQueueFamilyProperties2: procedure ( physicalDevice: VkPhysicalDevice; pQueueFamilyPropertyCount: pTuint32_t; pQueueFamilyProperties: pTVkQueueFamilyProperties2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceQueueFamilyProperties2KHR: procedure ( physicalDevice: VkPhysicalDevice; pQueueFamilyPropertyCount: pTuint32_t; pQueueFamilyProperties: pTVkQueueFamilyProperties2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceMemoryProperties2: procedure ( physicalDevice: VkPhysicalDevice; pMemoryProperties: pTVkPhysicalDeviceMemoryProperties2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceMemoryProperties2KHR: procedure ( physicalDevice: VkPhysicalDevice; pMemoryProperties: pTVkPhysicalDeviceMemoryProperties2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceSparseImageFormatProperties2: procedure ( physicalDevice: VkPhysicalDevice; const pFormatInfo: pTVkPhysicalDeviceSparseImageFormatInfo2; pPropertyCount: pTuint32_t; pProperties: pTVkSparseImageFormatProperties2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceSparseImageFormatProperties2KHR: procedure ( physicalDevice: VkPhysicalDevice; const pFormatInfo: pTVkPhysicalDeviceSparseImageFormatInfo2; pPropertyCount: pTuint32_t; pProperties: pTVkSparseImageFormatProperties2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdPushDescriptorSetKHR: procedure ( commandBuffer: VkCommandBuffer; pipelineBindPoint: VkPipelineBindPoint; layout: VkPipelineLayout; _set: uint32_t; descriptorWriteCount: uint32_t; const pDescriptorWrites: pTVkWriteDescriptorSet );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkTrimCommandPool: procedure ( device: VkDevice; commandPool: VkCommandPool; flags: VkCommandPoolTrimFlags );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkTrimCommandPoolKHR: procedure ( device: VkDevice; commandPool: VkCommandPool; flags: VkCommandPoolTrimFlags );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceExternalBufferProperties: procedure ( physicalDevice: VkPhysicalDevice; const pExternalBufferInfo: pTVkPhysicalDeviceExternalBufferInfo; pExternalBufferProperties: pTVkExternalBufferProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceExternalBufferPropertiesKHR: procedure ( physicalDevice: VkPhysicalDevice; const pExternalBufferInfo: pTVkPhysicalDeviceExternalBufferInfo; pExternalBufferProperties: pTVkExternalBufferProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  vkGetMemoryWin32HandleKHR: function ( device: VkDevice; const pGetWin32HandleInfo: pTVkMemoryGetWin32HandleInfoKHR; pHandle: pTHANDLE ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  vkGetMemoryWin32HandlePropertiesKHR: function ( device: VkDevice; handleType: VkExternalMemoryHandleTypeFlagBits; handle: THandle; pMemoryWin32HandleProperties: pTVkMemoryWin32HandlePropertiesKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkGetMemoryFdKHR: function ( device: VkDevice; const pGetFdInfo: pTVkMemoryGetFdInfoKHR; pFd: pTint ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetMemoryFdPropertiesKHR: function ( device: VkDevice; handleType: VkExternalMemoryHandleTypeFlagBits; fd: integer; pMemoryFdProperties: pTVkMemoryFdPropertiesKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceExternalSemaphoreProperties: procedure ( physicalDevice: VkPhysicalDevice; const pExternalSemaphoreInfo: pTVkPhysicalDeviceExternalSemaphoreInfo; pExternalSemaphoreProperties: pTVkExternalSemaphoreProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceExternalSemaphorePropertiesKHR: procedure ( physicalDevice: VkPhysicalDevice; const pExternalSemaphoreInfo: pTVkPhysicalDeviceExternalSemaphoreInfo; pExternalSemaphoreProperties: pTVkExternalSemaphoreProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  vkGetSemaphoreWin32HandleKHR: function ( device: VkDevice; const pGetWin32HandleInfo: pTVkSemaphoreGetWin32HandleInfoKHR; pHandle: pTHANDLE ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  vkImportSemaphoreWin32HandleKHR: function ( device: VkDevice; const pImportSemaphoreWin32HandleInfo: pTVkImportSemaphoreWin32HandleInfoKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkGetSemaphoreFdKHR: function ( device: VkDevice; const pGetFdInfo: pTVkSemaphoreGetFdInfoKHR; pFd: pTint ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkImportSemaphoreFdKHR: function ( device: VkDevice; const pImportSemaphoreFdInfo: pTVkImportSemaphoreFdInfoKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceExternalFenceProperties: procedure ( physicalDevice: VkPhysicalDevice; const pExternalFenceInfo: pTVkPhysicalDeviceExternalFenceInfo; pExternalFenceProperties: pTVkExternalFenceProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceExternalFencePropertiesKHR: procedure ( physicalDevice: VkPhysicalDevice; const pExternalFenceInfo: pTVkPhysicalDeviceExternalFenceInfo; pExternalFenceProperties: pTVkExternalFenceProperties );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  vkGetFenceWin32HandleKHR: function ( device: VkDevice; const pGetWin32HandleInfo: pTVkFenceGetWin32HandleInfoKHR; pHandle: pTHANDLE ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}  vkImportFenceWin32HandleKHR: function ( device: VkDevice; const pImportFenceWin32HandleInfo: pTVkImportFenceWin32HandleInfoKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkGetFenceFdKHR: function ( device: VkDevice; const pGetFdInfo: pTVkFenceGetFdInfoKHR; pFd: pTint ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkImportFenceFdKHR: function ( device: VkDevice; const pImportFenceFdInfo: pTVkImportFenceFdInfoKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkReleaseDisplayEXT: function ( physicalDevice: VkPhysicalDevice; display: VkDisplayKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT}  vkAcquireXlibDisplayEXT: function ( physicalDevice: VkPhysicalDevice; dpy: pTDisplay; display: VkDisplayKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT}  vkGetRandROutputDisplayEXT: function ( physicalDevice: VkPhysicalDevice; dpy: pTDisplay; rrOutput: RROutput; pDisplay: pTVkDisplayKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkDisplayPowerControlEXT: function ( device: VkDevice; display: VkDisplayKHR; const pDisplayPowerInfo: pTVkDisplayPowerInfoEXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkRegisterDeviceEventEXT: function ( device: VkDevice; const pDeviceEventInfo: pTVkDeviceEventInfoEXT; const pAllocator: pTVkAllocationCallbacks; pFence: pTVkFence ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkRegisterDisplayEventEXT: function ( device: VkDevice; display: VkDisplayKHR; const pDisplayEventInfo: pTVkDisplayEventInfoEXT; const pAllocator: pTVkAllocationCallbacks; pFence: pTVkFence ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetSwapchainCounterEXT: function ( device: VkDevice; swapchain: VkSwapchainKHR; counter: VkSurfaceCounterFlagBitsEXT; pCounterValue: pTuint64_t ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceSurfaceCapabilities2EXT: function ( physicalDevice: VkPhysicalDevice; surface: VkSurfaceKHR; pSurfaceCapabilities: pTVkSurfaceCapabilities2EXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkEnumeratePhysicalDeviceGroups: function ( instance: VkInstance; pPhysicalDeviceGroupCount: pTuint32_t; pPhysicalDeviceGroupProperties: pTVkPhysicalDeviceGroupProperties ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkEnumeratePhysicalDeviceGroupsKHR: function ( instance: VkInstance; pPhysicalDeviceGroupCount: pTuint32_t; pPhysicalDeviceGroupProperties: pTVkPhysicalDeviceGroupProperties ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDeviceGroupPeerMemoryFeatures: procedure ( device: VkDevice; heapIndex: uint32_t; localDeviceIndex: uint32_t; remoteDeviceIndex: uint32_t; pPeerMemoryFeatures: pTVkPeerMemoryFeatureFlags );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDeviceGroupPeerMemoryFeaturesKHR: procedure ( device: VkDevice; heapIndex: uint32_t; localDeviceIndex: uint32_t; remoteDeviceIndex: uint32_t; pPeerMemoryFeatures: pTVkPeerMemoryFeatureFlags );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkBindBufferMemory2: function ( device: VkDevice; bindInfoCount: uint32_t; const pBindInfos: pTVkBindBufferMemoryInfo ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkBindBufferMemory2KHR: function ( device: VkDevice; bindInfoCount: uint32_t; const pBindInfos: pTVkBindBufferMemoryInfo ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkBindImageMemory2: function ( device: VkDevice; bindInfoCount: uint32_t; const pBindInfos: pTVkBindImageMemoryInfo ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkBindImageMemory2KHR: function ( device: VkDevice; bindInfoCount: uint32_t; const pBindInfos: pTVkBindImageMemoryInfo ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetDeviceMask: procedure ( commandBuffer: VkCommandBuffer; deviceMask: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetDeviceMaskKHR: procedure ( commandBuffer: VkCommandBuffer; deviceMask: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDeviceGroupPresentCapabilitiesKHR: function ( device: VkDevice; pDeviceGroupPresentCapabilities: pTVkDeviceGroupPresentCapabilitiesKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDeviceGroupSurfacePresentModesKHR: function ( device: VkDevice; surface: VkSurfaceKHR; pModes: pTVkDeviceGroupPresentModeFlagsKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkAcquireNextImage2KHR: function ( device: VkDevice; const pAcquireInfo: pTVkAcquireNextImageInfoKHR; pImageIndex: pTuint32_t ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDispatchBase: procedure ( commandBuffer: VkCommandBuffer; baseGroupX: uint32_t; baseGroupY: uint32_t; baseGroup: uint32_t; groupCountX: uint32_t; groupCountY: uint32_t; groupCount: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDispatchBaseKHR: procedure ( commandBuffer: VkCommandBuffer; baseGroupX: uint32_t; baseGroupY: uint32_t; baseGroup: uint32_t; groupCountX: uint32_t; groupCountY: uint32_t; groupCount: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDevicePresentRectanglesKHR: function ( physicalDevice: VkPhysicalDevice; surface: VkSurfaceKHR; pRectCount: pTuint32_t; pRects: pTVkRect2D ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateDescriptorUpdateTemplate: function ( device: VkDevice; const pCreateInfo: pTVkDescriptorUpdateTemplateCreateInfo; const pAllocator: pTVkAllocationCallbacks; pDescriptorUpdateTemplate: pTVkDescriptorUpdateTemplate ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateDescriptorUpdateTemplateKHR: function ( device: VkDevice; const pCreateInfo: pTVkDescriptorUpdateTemplateCreateInfo; const pAllocator: pTVkAllocationCallbacks; pDescriptorUpdateTemplate: pTVkDescriptorUpdateTemplate ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyDescriptorUpdateTemplate: procedure ( device: VkDevice; descriptorUpdateTemplate: VkDescriptorUpdateTemplate; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyDescriptorUpdateTemplateKHR: procedure ( device: VkDevice; descriptorUpdateTemplate: VkDescriptorUpdateTemplate; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkUpdateDescriptorSetWithTemplate: procedure ( device: VkDevice; descriptorSet: VkDescriptorSet; descriptorUpdateTemplate: VkDescriptorUpdateTemplate; const pData: pointer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkUpdateDescriptorSetWithTemplateKHR: procedure ( device: VkDevice; descriptorSet: VkDescriptorSet; descriptorUpdateTemplate: VkDescriptorUpdateTemplate; const pData: pointer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdPushDescriptorSetWithTemplateKHR: procedure ( commandBuffer: VkCommandBuffer; descriptorUpdateTemplate: VkDescriptorUpdateTemplate; layout: VkPipelineLayout; _set: uint32_t; const pData: pointer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkSetHdrMetadataEXT: procedure ( device: VkDevice; swapchainCount: uint32_t; const pSwapchains: pTVkSwapchainKHR; const pMetadata: pTVkHdrMetadataEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetSwapchainStatusKHR: function ( device: VkDevice; swapchain: VkSwapchainKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetRefreshCycleDurationGOOGLE: function ( device: VkDevice; swapchain: VkSwapchainKHR; pDisplayTimingProperties: pTVkRefreshCycleDurationGOOGLE ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPastPresentationTimingGOOGLE: function ( device: VkDevice; swapchain: VkSwapchainKHR; pPresentationTimingCount: pTuint32_t; pPresentationTimings: pTVkPastPresentationTimingGOOGLE ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_IOS_MVK}  vkCreateIOSSurfaceMVK: function ( instance: VkInstance; const pCreateInfo: pTVkIOSSurfaceCreateInfoMVK; const pAllocator: pTVkAllocationCallbacks; pSurface: pTVkSurfaceKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_MACOS_MVK}  vkCreateMacOSSurfaceMVK: function ( instance: VkInstance; const pCreateInfo: pTVkMacOSSurfaceCreateInfoMVK; const pAllocator: pTVkAllocationCallbacks; pSurface: pTVkSurfaceKHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkCmdSetViewportWScalingNV: procedure ( commandBuffer: VkCommandBuffer; firstViewport: uint32_t; viewportCount: uint32_t; const pViewportWScalings: pTVkViewportWScalingNV );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetDiscardRectangleEXT: procedure ( commandBuffer: VkCommandBuffer; firstDiscardRectangle: uint32_t; discardRectangleCount: uint32_t; const pDiscardRectangles: pTVkRect2D );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetSampleLocationsEXT: procedure ( commandBuffer: VkCommandBuffer; const pSampleLocationsInfo: pTVkSampleLocationsInfoEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceMultisamplePropertiesEXT: procedure ( physicalDevice: VkPhysicalDevice; samples: VkSampleCountFlagBits; pMultisampleProperties: pTVkMultisamplePropertiesEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceSurfaceCapabilities2KHR: function ( physicalDevice: VkPhysicalDevice; const pSurfaceInfo: pTVkPhysicalDeviceSurfaceInfo2KHR; pSurfaceCapabilities: pTVkSurfaceCapabilities2KHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceSurfaceFormats2KHR: function ( physicalDevice: VkPhysicalDevice; const pSurfaceInfo: pTVkPhysicalDeviceSurfaceInfo2KHR; pSurfaceFormatCount: pTuint32_t; pSurfaceFormats: pTVkSurfaceFormat2KHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceDisplayProperties2KHR: function ( physicalDevice: VkPhysicalDevice; pPropertyCount: pTuint32_t; pProperties: pTVkDisplayProperties2KHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetPhysicalDeviceDisplayPlaneProperties2KHR: function ( physicalDevice: VkPhysicalDevice; pPropertyCount: pTuint32_t; pProperties: pTVkDisplayPlaneProperties2KHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDisplayModeProperties2KHR: function ( physicalDevice: VkPhysicalDevice; display: VkDisplayKHR; pPropertyCount: pTuint32_t; pProperties: pTVkDisplayModeProperties2KHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDisplayPlaneCapabilities2KHR: function ( physicalDevice: VkPhysicalDevice; const pDisplayPlaneInfo: pTVkDisplayPlaneInfo2KHR; pCapabilities: pTVkDisplayPlaneCapabilities2KHR ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetBufferMemoryRequirements2: procedure ( device: VkDevice; const pInfo: pTVkBufferMemoryRequirementsInfo2; pMemoryRequirements: pTVkMemoryRequirements2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetBufferMemoryRequirements2KHR: procedure ( device: VkDevice; const pInfo: pTVkBufferMemoryRequirementsInfo2; pMemoryRequirements: pTVkMemoryRequirements2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetImageMemoryRequirements2: procedure ( device: VkDevice; const pInfo: pTVkImageMemoryRequirementsInfo2; pMemoryRequirements: pTVkMemoryRequirements2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetImageMemoryRequirements2KHR: procedure ( device: VkDevice; const pInfo: pTVkImageMemoryRequirementsInfo2; pMemoryRequirements: pTVkMemoryRequirements2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetImageSparseMemoryRequirements2: procedure ( device: VkDevice; const pInfo: pTVkImageSparseMemoryRequirementsInfo2; pSparseMemoryRequirementCount: pTuint32_t; pSparseMemoryRequirements: pTVkSparseImageMemoryRequirements2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetImageSparseMemoryRequirements2KHR: procedure ( device: VkDevice; const pInfo: pTVkImageSparseMemoryRequirementsInfo2; pSparseMemoryRequirementCount: pTuint32_t; pSparseMemoryRequirements: pTVkSparseImageMemoryRequirements2 );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateSamplerYcbcrConversion: function ( device: VkDevice; const pCreateInfo: pTVkSamplerYcbcrConversionCreateInfo; const pAllocator: pTVkAllocationCallbacks; pYcbcrConversion: pTVkSamplerYcbcrConversion ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateSamplerYcbcrConversionKHR: function ( device: VkDevice; const pCreateInfo: pTVkSamplerYcbcrConversionCreateInfo; const pAllocator: pTVkAllocationCallbacks; pYcbcrConversion: pTVkSamplerYcbcrConversion ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroySamplerYcbcrConversion: procedure ( device: VkDevice; ycbcrConversion: VkSamplerYcbcrConversion; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroySamplerYcbcrConversionKHR: procedure ( device: VkDevice; ycbcrConversion: VkSamplerYcbcrConversion; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDeviceQueue2: procedure ( device: VkDevice; const pQueueInfo: pTVkDeviceQueueInfo2; pQueue: pTVkQueue );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateValidationCacheEXT: function ( device: VkDevice; const pCreateInfo: pTVkValidationCacheCreateInfoEXT; const pAllocator: pTVkAllocationCallbacks; pValidationCache: pTVkValidationCacheEXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyValidationCacheEXT: procedure ( device: VkDevice; validationCache: VkValidationCacheEXT; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetValidationCacheDataEXT: function ( device: VkDevice; validationCache: VkValidationCacheEXT; pDataSize: pTsize_t; pData: pointer ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkMergeValidationCachesEXT: function ( device: VkDevice; dstCache: VkValidationCacheEXT; srcCacheCount: uint32_t; const pSrcCaches: pTVkValidationCacheEXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDescriptorSetLayoutSupport: procedure ( device: VkDevice; const pCreateInfo: pTVkDescriptorSetLayoutCreateInfo; pSupport: pTVkDescriptorSetLayoutSupport );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetDescriptorSetLayoutSupportKHR: procedure ( device: VkDevice; const pCreateInfo: pTVkDescriptorSetLayoutCreateInfo; pSupport: pTVkDescriptorSetLayoutSupport );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  vkGetSwapchainGrallocUsageANDROID: function ( device: VkDevice; format: VkFormat; imageUsage: VkImageUsageFlags; grallocUsage: pTint ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  vkAcquireImageANDROID: function ( device: VkDevice; image: VkImage; nativeFenceFd: integer; semaphore: VkSemaphore; fence: VkFence ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  vkQueueSignalReleaseImageANDROID: function ( queue: VkQueue; waitSemaphoreCount: uint32_t; const pWaitSemaphores: pTVkSemaphore; image: VkImage; pNativeFenceFd: pTint ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkGetShaderInfoAMD: function ( device: VkDevice; pipeline: VkPipeline; shaderStage: VkShaderStageFlagBits; infoType: VkShaderInfoTypeAMD; pInfoSize: pTsize_t; pInfo: pointer ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkSetDebugUtilsObjectNameEXT: function ( device: VkDevice; const pNameInfo: pTVkDebugUtilsObjectNameInfoEXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkSetDebugUtilsObjectTagEXT: function ( device: VkDevice; const pTagInfo: pTVkDebugUtilsObjectTagInfoEXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkQueueBeginDebugUtilsLabelEXT: procedure ( queue: VkQueue; const pLabelInfo: pTVkDebugUtilsLabelEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkQueueEndDebugUtilsLabelEXT: procedure ( queue: VkQueue );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkQueueInsertDebugUtilsLabelEXT: procedure ( queue: VkQueue; const pLabelInfo: pTVkDebugUtilsLabelEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdBeginDebugUtilsLabelEXT: procedure ( commandBuffer: VkCommandBuffer; const pLabelInfo: pTVkDebugUtilsLabelEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdEndDebugUtilsLabelEXT: procedure ( commandBuffer: VkCommandBuffer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdInsertDebugUtilsLabelEXT: procedure ( commandBuffer: VkCommandBuffer; const pLabelInfo: pTVkDebugUtilsLabelEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateDebugUtilsMessengerEXT: function ( instance: VkInstance; const pCreateInfo: pTVkDebugUtilsMessengerCreateInfoEXT; const pAllocator: pTVkAllocationCallbacks; pMessenger: pTVkDebugUtilsMessengerEXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkDestroyDebugUtilsMessengerEXT: procedure ( instance: VkInstance; messenger: VkDebugUtilsMessengerEXT; const pAllocator: pTVkAllocationCallbacks );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkSubmitDebugUtilsMessageEXT: procedure ( instance: VkInstance; messageSeverity: VkDebugUtilsMessageSeverityFlagBitsEXT; messageTypes: VkDebugUtilsMessageTypeFlagsEXT; const pCallbackData: pTVkDebugUtilsMessengerCallbackDataEXT );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetMemoryHostPointerPropertiesEXT: function ( device: VkDevice; handleType: VkExternalMemoryHandleTypeFlagBits; const pHostPointer: pointer; pMemoryHostPointerProperties: pTVkMemoryHostPointerPropertiesEXT ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdWriteBufferMarkerAMD: procedure ( commandBuffer: VkCommandBuffer; pipelineStage: VkPipelineStageFlagBits; dstBuffer: VkBuffer; dstOffset: VkDeviceSize; marker: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCreateRenderPass2KHR: function ( device: VkDevice; const pCreateInfo: pTVkRenderPassCreateInfo2KHR; const pAllocator: pTVkAllocationCallbacks; pRenderPass: pTVkRenderPass ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdBeginRenderPass2KHR: procedure ( commandBuffer: VkCommandBuffer; const pRenderPassBegin: pTVkRenderPassBeginInfo; const pSubpassBeginInfo: pTVkSubpassBeginInfoKHR );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdNextSubpass2KHR: procedure ( commandBuffer: VkCommandBuffer; const pSubpassBeginInfo: pTVkSubpassBeginInfoKHR; const pSubpassEndInfo: pTVkSubpassEndInfoKHR );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdEndRenderPass2KHR: procedure ( commandBuffer: VkCommandBuffer; const pSubpassEndInfo: pTVkSubpassEndInfoKHR );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  vkGetAndroidHardwareBufferPropertiesANDROID: function ( device: VkDevice; conststructbuffer: pTAHardwareBuffer; pProperties: pTVkAndroidHardwareBufferPropertiesANDROID ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}  vkGetMemoryAndroidHardwareBufferANDROID: function ( device: VkDevice; const pInfo: pTVkMemoryGetAndroidHardwareBufferInfoANDROID; structpBuffer: pppTAHardwareBuffer ): VkResult;  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}  {$endif}
  vkCmdDrawIndirectCountKHR: procedure ( commandBuffer: VkCommandBuffer; buffer: VkBuffer; offset: VkDeviceSize; countBuffer: VkBuffer; countBufferOffset: VkDeviceSize; maxDrawCount: uint32_t; stride: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdDrawIndexedIndirectCountKHR: procedure ( commandBuffer: VkCommandBuffer; buffer: VkBuffer; offset: VkDeviceSize; countBuffer: VkBuffer; countBufferOffset: VkDeviceSize; maxDrawCount: uint32_t; stride: uint32_t );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkCmdSetCheckpointNV: procedure ( commandBuffer: VkCommandBuffer; const pCheckpointMarker: pointer );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}
  vkGetQueueCheckpointDataNV: procedure ( queue: VkQueue; pCheckpointDataCount: pTuint32_t; pCheckpointData: pTVkCheckpointDataNV );  {$ifdef MSWINDOWS}stdcall;{$else}cdecl;{$endif}

  public
    constructor Create; reintroduce;
  end;

const
  VK_KHR_SURFACE_SPEC_VERSION = 25;
  VK_KHR_SURFACE_EXTENSION_NAME = 'VK_KHR_surface';
  VK_KHR_SWAPCHAIN_SPEC_VERSION = 70;
  VK_KHR_SWAPCHAIN_EXTENSION_NAME = 'VK_KHR_swapchain';
  VK_KHR_DISPLAY_SPEC_VERSION = 21;
  VK_KHR_DISPLAY_EXTENSION_NAME = 'VK_KHR_display';
  VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION = 9;
  VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME = 'VK_KHR_display_swapchain';
  VK_KHR_XLIB_SURFACE_SPEC_VERSION = 6;
  VK_KHR_XLIB_SURFACE_EXTENSION_NAME = 'VK_KHR_xlib_surface';
  VK_KHR_XCB_SURFACE_SPEC_VERSION = 6;
  VK_KHR_XCB_SURFACE_EXTENSION_NAME = 'VK_KHR_xcb_surface';
  VK_KHR_WAYLAND_SURFACE_SPEC_VERSION = 6;
  VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME = 'VK_KHR_wayland_surface';
  VK_KHR_MIR_SURFACE_SPEC_VERSION = 4;
  VK_KHR_MIR_SURFACE_EXTENSION_NAME = 'VK_KHR_mir_surface';
  VK_KHR_ANDROID_SURFACE_SPEC_VERSION = 6;
  VK_KHR_ANDROID_SURFACE_EXTENSION_NAME = 'VK_KHR_android_surface';
  VK_KHR_WIN32_SURFACE_SPEC_VERSION = 6;
  VK_KHR_WIN32_SURFACE_EXTENSION_NAME = 'VK_KHR_win32_surface';
  VK_ANDROID_NATIVE_BUFFER_SPEC_VERSION = 5;
  VK_ANDROID_NATIVE_BUFFER_NUMBER = 11;
  VK_ANDROID_NATIVE_BUFFER_NAME = 'VK_ANDROID_native_buffer';
  VK_EXT_DEBUG_REPORT_SPEC_VERSION = 9;
  VK_EXT_DEBUG_REPORT_EXTENSION_NAME = 'VK_EXT_debug_report';
  VK_NV_GLSL_SHADER_SPEC_VERSION = 1;
  VK_NV_GLSL_SHADER_EXTENSION_NAME = 'VK_NV_glsl_shader';
  VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION = 1;
  VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME = 'VK_EXT_depth_range_unrestricted';
  VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION = 1;
  VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME = 'VK_KHR_sampler_mirror_clamp_to_edge';
  VK_IMG_FILTER_CUBIC_SPEC_VERSION = 1;
  VK_IMG_FILTER_CUBIC_EXTENSION_NAME = 'VK_IMG_filter_cubic';
  VK_AMD_EXTENSION_17_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_17_EXTENSION_NAME = 'VK_AMD_extension_17';
  VK_AMD_EXTENSION_18_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_18_EXTENSION_NAME = 'VK_AMD_extension_18';
  VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION = 1;
  VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME = 'VK_AMD_rasterization_order';
  VK_AMD_EXTENSION_20_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_20_EXTENSION_NAME = 'VK_AMD_extension_20';
  VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION = 1;
  VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME = 'VK_AMD_shader_trinary_minmax';
  VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION = 1;
  VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME = 'VK_AMD_shader_explicit_vertex_parameter';
  VK_EXT_DEBUG_MARKER_SPEC_VERSION = 4;
  VK_EXT_DEBUG_MARKER_EXTENSION_NAME = 'VK_EXT_debug_marker';
  VK_AMD_EXTENSION_24_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_24_EXTENSION_NAME = 'VK_AMD_extension_24';
  VK_AMD_EXTENSION_25_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_25_EXTENSION_NAME = 'VK_AMD_extension_25';
  VK_AMD_GCN_SHADER_SPEC_VERSION = 1;
  VK_AMD_GCN_SHADER_EXTENSION_NAME = 'VK_AMD_gcn_shader';
  VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION = 1;
  VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME = 'VK_NV_dedicated_allocation';
  VK_EXT_EXTENSION_28_SPEC_VERSION = 0;
  VK_EXT_EXTENSION_28_EXTENSION_NAME = 'VK_NV_extension_28';
  VK_NVX_EXTENSION_29_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_29_EXTENSION_NAME = 'VK_NVX_extension_29';
  VK_NVX_EXTENSION_30_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_30_EXTENSION_NAME = 'VK_NVX_extension_30';
  VK_NVX_EXTENSION_31_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_31_EXTENSION_NAME = 'VK_NVX_extension_31';
  VK_AMD_EXTENSION_32_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_32_EXTENSION_NAME = 'VK_AMD_extension_32';
  VK_AMD_EXTENSION_33_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_33_EXTENSION_NAME = 'VK_AMD_extension_33';
  VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION = 1;
  VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME = 'VK_AMD_draw_indirect_count';
  VK_AMD_EXTENSION_35_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_35_EXTENSION_NAME = 'VK_AMD_extension_35';
  VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION = 1;
  VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME = 'VK_AMD_negative_viewport_height';
  VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION = 1;
  VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME = 'VK_AMD_gpu_shader_half_float';
  VK_AMD_SHADER_BALLOT_SPEC_VERSION = 1;
  VK_AMD_SHADER_BALLOT_EXTENSION_NAME = 'VK_AMD_shader_ballot';
  VK_AMD_EXTENSION_39_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_39_EXTENSION_NAME = 'VK_AMD_extension_39';
  VK_AMD_EXTENSION_40_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_40_EXTENSION_NAME = 'VK_AMD_extension_40';
  VK_AMD_EXTENSION_41_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_41_EXTENSION_NAME = 'VK_AMD_extension_41';
  VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION = 1;
  VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME = 'VK_AMD_texture_gather_bias_lod';
  VK_AMD_SHADER_INFO_SPEC_VERSION = 1;
  VK_AMD_SHADER_INFO_EXTENSION_NAME = 'VK_AMD_shader_info';
  VK_AMD_EXTENSION_44_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_44_EXTENSION_NAME = 'VK_AMD_extension_44';
  VK_AMD_EXTENSION_45_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_45_EXTENSION_NAME = 'VK_AMD_extension_45';
  VK_AMD_EXTENSION_46_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_46_EXTENSION_NAME = 'VK_AMD_extension_46';
  VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_SPEC_VERSION = 1;
  VK_AMD_SHADER_IMAGE_LOAD_STORE_LOD_EXTENSION_NAME = 'VK_AMD_shader_image_load_store_lod';
  VK_NVX_EXTENSION_48_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_48_EXTENSION_NAME = 'VK_NVX_extension_48';
  VK_GOOGLE_EXTENSION_49_SPEC_VERSION = 0;
  VK_GOOGLE_EXTENSION_49_EXTENSION_NAME = 'VK_GOOGLE_extension_49';
  VK_GOOGLE_EXTENSION_50_SPEC_VERSION = 0;
  VK_GOOGLE_EXTENSION_50_EXTENSION_NAME = 'VK_GOOGLE_extension_50';
  VK_NVX_EXTENSION_51_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_51_EXTENSION_NAME = 'VK_NVX_extension_51';
  VK_NVX_EXTENSION_52_SPEC_VERSION = 0;
  VK_NVX_EXTENSION_52_EXTENSION_NAME = 'VK_NVX_extension_52';
  VK_NV_EXTENSION_53_SPEC_VERSION = 0;
  VK_NV_EXTENSION_53_EXTENSION_NAME = 'VK_NV_extension_53';
  VK_KHR_MULTIVIEW_SPEC_VERSION = 1;
  VK_KHR_MULTIVIEW_EXTENSION_NAME = 'VK_KHR_multiview';
  VK_IMG_FORMAT_PVRTC_SPEC_VERSION = 1;
  VK_IMG_FORMAT_PVRTC_EXTENSION_NAME = 'VK_IMG_format_pvrtc';
  VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1;
  VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = 'VK_NV_external_memory_capabilities';
  VK_NV_EXTERNAL_MEMORY_SPEC_VERSION = 1;
  VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME = 'VK_NV_external_memory';
  VK_NV_EXTERNAL_MEMORY_WIN32_SPEC_VERSION = 1;
  VK_NV_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = 'VK_NV_external_memory_win32';
  VK_NV_WIN32_KEYED_MUTEX_SPEC_VERSION = 1;
  VK_NV_WIN32_KEYED_MUTEX_EXTENSION_NAME = 'VK_NV_win32_keyed_mutex';
  VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION = 1;
  VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME = 'VK_KHR_get_physical_device_properties2';
  VK_KHR_DEVICE_GROUP_SPEC_VERSION = 3;
  VK_KHR_DEVICE_GROUP_EXTENSION_NAME = 'VK_KHR_device_group';
  VK_EXT_VALIDATION_FLAGS_SPEC_VERSION = 1;
  VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME = 'VK_EXT_validation_flags';
  VK_NN_VI_SURFACE_SPEC_VERSION = 1;
  VK_NN_VI_SURFACE_EXTENSION_NAME = 'VK_NN_vi_surface';
  VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION = 1;
  VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME = 'VK_KHR_shader_draw_parameters';
  VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION = 1;
  VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME = 'VK_EXT_shader_subgroup_ballot';
  VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION = 1;
  VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME = 'VK_EXT_shader_subgroup_vote';
  VK_ARM_EXTENSION_01_SPEC_VERSION = 0;
  VK_ARM_EXTENSION_01_EXTENSION_NAME = 'VK_ARM_extension_01';
  VK_ARM_EXTENSION_02_SPEC_VERSION = 0;
  VK_ARM_EXTENSION_02_EXTENSION_NAME = 'VK_ARM_extension_02';
  VK_IMG_EXTENSION_69_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_69_EXTENSION_NAME = 'VK_IMG_extension_69';
  VK_KHR_MAINTENANCE1_SPEC_VERSION = 2;
  VK_KHR_MAINTENANCE1_EXTENSION_NAME = 'VK_KHR_maintenance1';
  VK_KHR_DEVICE_GROUP_CREATION_SPEC_VERSION = 1;
  VK_KHR_DEVICE_GROUP_CREATION_EXTENSION_NAME = 'VK_KHR_device_group_creation';
  VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME = 'VK_KHR_external_memory_capabilities';
  VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME = 'VK_KHR_external_memory';
  VK_KHR_EXTERNAL_MEMORY_WIN32_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_MEMORY_WIN32_EXTENSION_NAME = 'VK_KHR_external_memory_win32';
  VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME = 'VK_KHR_external_memory_fd';
  VK_KHR_WIN32_KEYED_MUTEX_SPEC_VERSION = 1;
  VK_KHR_WIN32_KEYED_MUTEX_EXTENSION_NAME = 'VK_KHR_win32_keyed_mutex';
  VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME = 'VK_KHR_external_semaphore_capabilities';
  VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME = 'VK_KHR_external_semaphore';
  VK_KHR_EXTERNAL_SEMAPHORE_WIN32_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_SEMAPHORE_WIN32_EXTENSION_NAME = 'VK_KHR_external_semaphore_win32';
  VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME = 'VK_KHR_external_semaphore_fd';
  VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION = 2;
  VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME = 'VK_KHR_push_descriptor';
  VK_EXT_CONDITIONAL_RENDERING_SPEC_VERSION = 1;
  VK_EXT_CONDITIONAL_RENDERING_EXTENSION_NAME = 'VK_EXT_conditional_rendering';
  VK_KHR_EXTENSION_83_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_83_EXTENSION_NAME = 'VK_KHR_extension_83';
  VK_KHR_16BIT_STORAGE_SPEC_VERSION = 1;
  VK_KHR_16BIT_STORAGE_EXTENSION_NAME = 'VK_KHR_16bit_storage';
  VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION = 1;
  VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME = 'VK_KHR_incremental_present';
  VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION = 1;
  VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME = 'VK_KHR_descriptor_update_template';
  VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION = 3;
  VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME = 'VK_NVX_device_generated_commands';
  VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION = 1;
  VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME = 'VK_NV_clip_space_w_scaling';
  VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION = 1;
  VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME = 'VK_EXT_direct_mode_display';
  VK_EXT_ACQUIRE_XLIB_DISPLAY_SPEC_VERSION = 1;
  VK_EXT_ACQUIRE_XLIB_DISPLAY_EXTENSION_NAME = 'VK_EXT_acquire_xlib_display';
  VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION = 1;
  VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME = 'VK_EXT_display_surface_counter';
  VK_EXT_DISPLAY_CONTROL_SPEC_VERSION = 1;
  VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME = 'VK_EXT_display_control';
  VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION = 1;
  VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME = 'VK_GOOGLE_display_timing';
  VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION = 1;
  VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME = 'VK_NV_sample_mask_override_coverage';
  VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION = 1;
  VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME = 'VK_NV_geometry_shader_passthrough';
  VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION = 1;
  VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME = 'VK_NV_viewport_array2';
  VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION = 1;
  VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME = 'VK_NVX_multiview_per_view_attributes';
  VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION = 1;
  VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME = 'VK_NV_viewport_swizzle';
  VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION = 1;
  VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME = 'VK_EXT_discard_rectangles';
  VK_NV_EXTENSION_101_SPEC_VERSION = 0;
  VK_NV_EXTENSION_101_EXTENSION_NAME = 'VK_NV_extension_101';
  VK_EXT_CONSERVATIVE_RASTERIZATION_SPEC_VERSION = 1;
  VK_EXT_CONSERVATIVE_RASTERIZATION_EXTENSION_NAME = 'VK_EXT_conservative_rasterization';
  VK_NV_EXTENSION_103_SPEC_VERSION = 0;
  VK_NV_EXTENSION_103_EXTENSION_NAME = 'VK_NV_extension_103';
  VK_NV_EXTENSION_104_SPEC_VERSION = 0;
  VK_NV_EXTENSION_104_EXTENSION_NAME = 'VK_NV_extension_104';
  VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION = 3;
  VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME = 'VK_EXT_swapchain_colorspace';
  VK_EXT_HDR_METADATA_SPEC_VERSION = 1;
  VK_EXT_HDR_METADATA_EXTENSION_NAME = 'VK_EXT_hdr_metadata';
  VK_IMG_EXTENSION_107_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_107_EXTENSION_NAME = 'VK_IMG_extension_107';
  VK_IMG_EXTENSION_108_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_108_EXTENSION_NAME = 'VK_IMG_extension_108';
  VK_IMG_EXTENSION_109_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_109_EXTENSION_NAME = 'VK_IMG_extension_109';
  VK_KHR_CREATE_RENDERPASS_2_SPEC_VERSION = 1;
  VK_KHR_CREATE_RENDERPASS_2_EXTENSION_NAME = 'VK_KHR_create_renderpass2';
  VK_IMG_EXTENSION_111_SPEC_VERSION = 0;
  VK_IMG_EXTENSION_111_EXTENSION_NAME = 'VK_IMG_extension_111';
  VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION = 1;
  VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME = 'VK_KHR_shared_presentable_image';
  VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME = 'VK_KHR_external_fence_capabilities';
  VK_KHR_EXTERNAL_FENCE_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME = 'VK_KHR_external_fence';
  VK_KHR_EXTERNAL_FENCE_WIN32_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_FENCE_WIN32_EXTENSION_NAME = 'VK_KHR_external_fence_win32';
  VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION = 1;
  VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME = 'VK_KHR_external_fence_fd';
  VK_KHR_EXTENSION_117_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_117_EXTENSION_NAME = 'VK_KHR_extension_117';
  VK_KHR_MAINTENANCE2_SPEC_VERSION = 1;
  VK_KHR_MAINTENANCE2_EXTENSION_NAME = 'VK_KHR_maintenance2';
  VK_KHR_EXTENSION_119_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_119_EXTENSION_NAME = 'VK_KHR_extension_119';
  VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION = 1;
  VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME = 'VK_KHR_get_surface_capabilities2';
  VK_KHR_VARIABLE_POINTERS_SPEC_VERSION = 1;
  VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME = 'VK_KHR_variable_pointers';
  VK_KHR_GET_DISPLAY_PROPERTIES_2_SPEC_VERSION = 1;
  VK_KHR_GET_DISPLAY_PROPERTIES_2_EXTENSION_NAME = 'VK_KHR_get_display_properties2';
  VK_MVK_IOS_SURFACE_SPEC_VERSION = 2;
  VK_MVK_IOS_SURFACE_EXTENSION_NAME = 'VK_MVK_ios_surface';
  VK_MVK_MACOS_SURFACE_SPEC_VERSION = 2;
  VK_MVK_MACOS_SURFACE_EXTENSION_NAME = 'VK_MVK_macos_surface';
  VK_MVK_MOLTENVK_SPEC_VERSION = 0;
  VK_MVK_MOLTENVK_EXTENSION_NAME = 'VK_MVK_moltenvk';
  VK_EXT_EXTERNAL_MEMORY_DMA_BUF_SPEC_VERSION = 1;
  VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME = 'VK_EXT_external_memory_dma_buf';
  VK_EXT_QUEUE_FAMILY_FOREIGN_SPEC_VERSION = 1;
  VK_EXT_QUEUE_FAMILY_FOREIGN_EXTENSION_NAME = 'VK_EXT_queue_family_foreign';
  VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION = 3;
  VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME = 'VK_KHR_dedicated_allocation';
  VK_EXT_DEBUG_UTILS_SPEC_VERSION = 1;
  VK_EXT_DEBUG_UTILS_EXTENSION_NAME = 'VK_EXT_debug_utils';
  VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_SPEC_VERSION = 3;
  VK_ANDROID_EXTERNAL_MEMORY_ANDROID_HARDWARE_BUFFER_EXTENSION_NAME = 'VK_ANDROID_external_memory_android_hardware_buffer';
  VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION = 1;
  VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME = 'VK_EXT_sampler_filter_minmax';
  VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION = 1;
  VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME = 'VK_KHR_storage_buffer_storage_class';
  VK_AMD_GPU_SHADER_INT16_SPEC_VERSION = 1;
  VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME = 'VK_AMD_gpu_shader_int16';
  VK_AMD_EXTENSION_134_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_134_EXTENSION_NAME = 'VK_AMD_extension_134';
  VK_AMD_EXTENSION_135_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_135_EXTENSION_NAME = 'VK_AMD_extension_135';
  VK_AMD_EXTENSION_136_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_136_EXTENSION_NAME = 'VK_AMD_extension_136';
  VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION = 1;
  VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME = 'VK_AMD_mixed_attachment_samples';
  VK_AMD_SHADER_FRAGMENT_MASK_SPEC_VERSION = 1;
  VK_AMD_SHADER_FRAGMENT_MASK_EXTENSION_NAME = 'VK_AMD_shader_fragment_mask';
  VK_AMD_EXTENSION_139_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_139_EXTENSION_NAME = 'VK_AMD_extension_139';
  VK_AMD_EXTENSION_140_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_140_EXTENSION_NAME = 'VK_AMD_extension_140';
  VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION = 1;
  VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME = 'VK_EXT_shader_stencil_export';
  VK_AMD_EXTENSION_142_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_142_EXTENSION_NAME = 'VK_AMD_extension_142';
  VK_AMD_EXTENSION_143_SPEC_VERSION = 0;
  VK_AMD_EXTENSION_143_EXTENSION_NAME = 'VK_AMD_extension_143';
  VK_EXT_SAMPLE_LOCATIONS_SPEC_VERSION = 1;
  VK_EXT_SAMPLE_LOCATIONS_EXTENSION_NAME = 'VK_EXT_sample_locations';
  VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION = 1;
  VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME = 'VK_KHR_relaxed_block_layout';
  VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION = 1;
  VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME = 'VK_KHR_get_memory_requirements2';
  VK_KHR_IMAGE_FORMAT_LIST_SPEC_VERSION = 1;
  VK_KHR_IMAGE_FORMAT_LIST_EXTENSION_NAME = 'VK_KHR_image_format_list';
  VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION = 2;
  VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME = 'VK_EXT_blend_operation_advanced';
  VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION = 1;
  VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME = 'VK_NV_fragment_coverage_to_color';
  VK_NV_EXTENSION_151_SPEC_VERSION = 0;
  VK_NV_EXTENSION_151_EXTENSION_NAME = 'VK_NV_extension_151';
  VK_NV_EXTENSION_152_SPEC_VERSION = 0;
  VK_NV_EXTENSION_152_EXTENSION_NAME = 'VK_NV_extension_152';
  VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION = 1;
  VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME = 'VK_NV_framebuffer_mixed_samples';
  VK_NV_FILL_RECTANGLE_SPEC_VERSION = 1;
  VK_NV_FILL_RECTANGLE_EXTENSION_NAME = 'VK_NV_fill_rectangle';
  VK_NV_EXTENSION_155_SPEC_VERSION = 0;
  VK_NV_EXTENSION_155_EXTENSION_NAME = 'VK_NV_extension_155';
  VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION = 1;
  VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME = 'VK_EXT_post_depth_coverage';
  VK_KHR_SAMPLER_YCBCR_CONVERSION_SPEC_VERSION = 1;
  VK_KHR_SAMPLER_YCBCR_CONVERSION_EXTENSION_NAME = 'VK_KHR_sampler_ycbcr_conversion';
  VK_KHR_BIND_MEMORY_2_SPEC_VERSION = 1;
  VK_KHR_BIND_MEMORY_2_EXTENSION_NAME = 'VK_KHR_bind_memory2';
  VK_EXT_EXTENSION_159_SPEC_VERSION = 0;
  VK_EXT_EXTENSION_159_EXTENSION_NAME = 'VK_EXT_extension_159';
  VK_EXT_EXTENSION_160_SPEC_VERSION = 0;
  VK_EXT_EXTENSION_160_EXTENSION_NAME = 'VK_EXT_extension_160';
  VK_EXT_VALIDATION_CACHE_SPEC_VERSION = 1;
  VK_EXT_VALIDATION_CACHE_EXTENSION_NAME = 'VK_EXT_validation_cache';
  VK_EXT_DESCRIPTOR_INDEXING_SPEC_VERSION = 2;
  VK_EXT_DESCRIPTOR_INDEXING_EXTENSION_NAME = 'VK_EXT_descriptor_indexing';
  VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION = 1;
  VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME = 'VK_EXT_shader_viewport_index_layer';
  VK_EXT_EXTENSION_164_SPEC_VERSION = 0;
  VK_EXT_EXTENSION_164_EXTENSION_NAME = 'VK_NV_extension_164';
  VK_EXT_EXTENSION_165_SPEC_VERSION = 0;
  VK_EXT_EXTENSION_165_EXTENSION_NAME = 'VK_NV_extension_165';
  VK_EXT_EXTENSION_166_SPEC_VERSION = 0;
  VK_EXT_EXTENSION_166_EXTENSION_NAME = 'VK_NV_extension_166';
  VK_EXT_EXTENSION_167_SPEC_VERSION = 0;
  VK_EXT_EXTENSION_167_EXTENSION_NAME = 'VK_NV_extension_167';
  VK_EXT_EXTENSION_168_SPEC_VERSION = 0;
  VK_EXT_EXTENSION_168_EXTENSION_NAME = 'VK_NV_extension_168';
  VK_KHR_MAINTENANCE3_SPEC_VERSION = 1;
  VK_KHR_MAINTENANCE3_EXTENSION_NAME = 'VK_KHR_maintenance3';
  VK_KHR_DRAW_INDIRECT_COUNT_SPEC_VERSION = 1;
  VK_KHR_DRAW_INDIRECT_COUNT_EXTENSION_NAME = 'VK_KHR_draw_indirect_count';
  VK_QCOM_extension_171_SPEC_VERSION = 0;
  VK_QCOM_extension_171_EXTENSION_NAME = 'VK_QCOM_extension_171';
  VK_QCOM_extension_172_SPEC_VERSION = 0;
  VK_QCOM_extension_172_EXTENSION_NAME = 'VK_QCOM_extension_172';
  VK_QCOM_extension_173_SPEC_VERSION = 0;
  VK_QCOM_extension_173_EXTENSION_NAME = 'VK_QCOM_extension_173';
  VK_QCOM_extension_174_SPEC_VERSION = 0;
  VK_QCOM_extension_174_EXTENSION_NAME = 'VK_QCOM_extension_174';
  VK_EXT_GLOBAL_PRIORITY_SPEC_VERSION = 2;
  VK_EXT_GLOBAL_PRIORITY_EXTENSION_NAME = 'VK_EXT_global_priority';
  VK_KHR_EXTENSION_176_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_176_EXTENSION_NAME = 'VK_KHR_extension_176';
  VK_KHR_EXTENSION_177_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_177_EXTENSION_NAME = 'VK_KHR_extension_177';
  VK_KHR_8BIT_STORAGE_SPEC_VERSION = 1;
  VK_KHR_8BIT_STORAGE_EXTENSION_NAME = 'VK_KHR_8bit_storage';
  VK_EXT_EXTERNAL_MEMORY_HOST_SPEC_VERSION = 1;
  VK_EXT_EXTERNAL_MEMORY_HOST_EXTENSION_NAME = 'VK_EXT_external_memory_host';
  VK_AMD_BUFFER_MARKER_SPEC_VERSION = 1;
  VK_AMD_BUFFER_MARKER_EXTENSION_NAME = 'VK_AMD_buffer_marker';
  VK_KHR_EXTENSION_181_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_181_EXTENSION_NAME = 'VK_AMD_extension_181';
  VK_KHR_EXTENSION_182_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_182_EXTENSION_NAME = 'VK_AMD_extension_182';
  VK_KHR_EXTENSION_183_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_183_EXTENSION_NAME = 'VK_AMD_extension_183';
  VK_KHR_EXTENSION_184_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_184_EXTENSION_NAME = 'VK_AMD_extension_184';
  VK_KHR_EXTENSION_185_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_185_EXTENSION_NAME = 'VK_AMD_extension_185';
  VK_AMD_SHADER_CORE_PROPERTIES_SPEC_VERSION = 1;
  VK_AMD_SHADER_CORE_PROPERTIES_EXTENSION_NAME = 'VK_AMD_shader_core_properties';
  VK_KHR_EXTENSION_187_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_187_EXTENSION_NAME = 'VK_AMD_extension_187';
  VK_KHR_EXTENSION_188_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_188_EXTENSION_NAME = 'VK_AMD_extension_188';
  VK_KHR_EXTENSION_189_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_189_EXTENSION_NAME = 'VK_AMD_extension_189';
  VK_KHR_EXTENSION_190_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_190_EXTENSION_NAME = 'VK_AMD_extension_190';
  VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_SPEC_VERSION = 2;
  VK_EXT_VERTEX_ATTRIBUTE_DIVISOR_EXTENSION_NAME = 'VK_EXT_vertex_attribute_divisor';
  VK_GOOGLE_EXTENSION_192_SPEC_VERSION = 0;
  VK_GOOGLE_EXTENSION_192_EXTENSION_NAME = 'VK_GOOGLE_extension_192';
  VK_GOOGLE_EXTENSION_193_SPEC_VERSION = 0;
  VK_GOOGLE_EXTENSION_193_EXTENSION_NAME = 'VK_GOOGLE_extension_193';
  VK_GOOGLE_EXTENSION_194_SPEC_VERSION = 0;
  VK_GOOGLE_EXTENSION_194_EXTENSION_NAME = 'VK_GOOGLE_extension_194';
  VK_GOOGLE_EXTENSION_195_SPEC_VERSION = 0;
  VK_GOOGLE_EXTENSION_195_EXTENSION_NAME = 'VK_GOOGLE_extension_195';
  VK_GOOGLE_EXTENSION_196_SPEC_VERSION = 0;
  VK_GOOGLE_EXTENSION_196_EXTENSION_NAME = 'VK_GOOGLE_extension_196';
  VK_EXT_EXTENSION_197_SPEC_VERSION = 0;
  VK_EXT_EXTENSION_197_EXTENSION_NAME = 'VK_EXT_extension_197';
  VK_ARM_EXTENSION_198_SPEC_VERSION = 0;
  VK_ARM_EXTENSION_198_EXTENSION_NAME = 'VK_EXT_extension_198';
  VK_NV_SHADER_SUBGROUP_PARTITIONED_SPEC_VERSION = 1;
  VK_NV_SHADER_SUBGROUP_PARTITIONED_EXTENSION_NAME = 'VK_NV_shader_subgroup_partitioned';
  VK_KHR_EXTENSION_200_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_200_EXTENSION_NAME = 'VK_KHR_extension_200';
  VK_KHR_EXTENSION_201_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_201_EXTENSION_NAME = 'VK_KHR_extension_201';
  VK_NV_EXTENSION_202_SPEC_VERSION = 0;
  VK_NV_EXTENSION_202_EXTENSION_NAME = 'VK_NV_extension_202';
  VK_NV_EXTENSION_203_SPEC_VERSION = 0;
  VK_NV_EXTENSION_203_EXTENSION_NAME = 'VK_NV_extension_203';
  VK_NV_EXTENSION_204_SPEC_VERSION = 0;
  VK_NV_EXTENSION_204_EXTENSION_NAME = 'VK_NV_extension_204';
  VK_NV_EXTENSION_205_SPEC_VERSION = 0;
  VK_NV_EXTENSION_205_EXTENSION_NAME = 'VK_NV_extension_205';
  VK_NV_EXTENSION_206_SPEC_VERSION = 0;
  VK_NV_EXTENSION_206_EXTENSION_NAME = 'VK_NV_extension_206';
  VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_SPEC_VERSION = 2;
  VK_NV_DEVICE_DIAGNOSTIC_CHECKPOINTS_EXTENSION_NAME = 'VK_NV_device_diagnostic_checkpoints';
  VK_KHR_EXTENSION_208_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_208_EXTENSION_NAME = 'VK_KHR_extension_208';
  VK_KHR_EXTENSION_209_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_209_EXTENSION_NAME = 'VK_KHR_extension_209';
  VK_KHR_EXTENSION_210_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_210_EXTENSION_NAME = 'VK_KHR_extension_210';
  VK_KHR_EXTENSION_211_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_211_EXTENSION_NAME = 'VK_KHR_extension_211';
  VK_KHR_EXTENSION_212_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_212_EXTENSION_NAME = 'VK_KHR_extension_212';
  VK_KHR_EXTENSION_213_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_213_EXTENSION_NAME = 'VK_KHR_extension_213';
  VK_KHR_EXTENSION_214_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_214_EXTENSION_NAME = 'VK_KHR_extension_214';
  VK_KHR_EXTENSION_215_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_215_EXTENSION_NAME = 'VK_KHR_extension_215';
  VK_KHR_EXTENSION_216_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_216_EXTENSION_NAME = 'VK_KHR_extension_216';
  VK_KHR_EXTENSION_217_SPEC_VERSION = 0;
  VK_KHR_EXTENSION_217_EXTENSION_NAME = 'VK_KHR_extension_217';

function VulkanAvailable: boolean;

implementation

function VK_MAKE_VERSION( VersionMajor: int32; VersionMinor: int32; VersionPatch: int32 ): int32;
begin
  Result := ((VersionMajor shl 22) or (VersionMinor shl 12)) or VersionPatch;
end;

function VK_VERSION_MAJOR( Version: int32 ): int32;
begin
  Result := Version shr 22;
end;

function VK_VERSION_MINOR( Version: int32 ): int32;
begin
  Result := (Version shr 12) and $3ff;
end;

function VK_VERSION_PATCH( Version: int32 ): int32;
begin
  Result := $fff;
end;

const
  cLibName = {$ifdef MSWINDOWS}'vulkan-1.dll'{$else}'libvulkan.so'{$endif};




var
  dynlib: IDynLib = nil;

procedure Tvk.LoadPointers( const Instance: vkInstance; UseInstance: boolean = true );
begin
  if not assigned(dynLib) then begin
    dynLib := TDynLib.Create;
    if not dynLib.LoadLibrary(cLibName) then begin
      dynLib := nil;
      exit;
    end;
  end;
  if UseInstance then vkCreateInstance := vkGetInstanceProcAddr( Instance, 'vkCreateInstance' ) else vkCreateInstance := dynLib.GetProcAddress('vkCreateInstance');
  if UseInstance then vkDestroyInstance := vkGetInstanceProcAddr( Instance, 'vkDestroyInstance' ) else vkDestroyInstance := dynLib.GetProcAddress('vkDestroyInstance');
  if UseInstance then vkEnumeratePhysicalDevices := vkGetInstanceProcAddr( Instance, 'vkEnumeratePhysicalDevices' ) else vkEnumeratePhysicalDevices := dynLib.GetProcAddress('vkEnumeratePhysicalDevices');
  if UseInstance then vkGetDeviceProcAddr := vkGetInstanceProcAddr( Instance, 'vkGetDeviceProcAddr' ) else vkGetDeviceProcAddr := dynLib.GetProcAddress('vkGetDeviceProcAddr');
  if UseInstance then vkGetInstanceProcAddr := vkGetInstanceProcAddr( Instance, 'vkGetInstanceProcAddr' ) else vkGetInstanceProcAddr := dynLib.GetProcAddress('vkGetInstanceProcAddr');
  if UseInstance then vkGetPhysicalDeviceProperties := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceProperties' ) else vkGetPhysicalDeviceProperties := dynLib.GetProcAddress('vkGetPhysicalDeviceProperties');
  if UseInstance then vkGetPhysicalDeviceQueueFamilyProperties := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceQueueFamilyProperties' ) else vkGetPhysicalDeviceQueueFamilyProperties := dynLib.GetProcAddress('vkGetPhysicalDeviceQueueFamilyProperties');
  if UseInstance then vkGetPhysicalDeviceMemoryProperties := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceMemoryProperties' ) else vkGetPhysicalDeviceMemoryProperties := dynLib.GetProcAddress('vkGetPhysicalDeviceMemoryProperties');
  if UseInstance then vkGetPhysicalDeviceFeatures := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceFeatures' ) else vkGetPhysicalDeviceFeatures := dynLib.GetProcAddress('vkGetPhysicalDeviceFeatures');
  if UseInstance then vkGetPhysicalDeviceFormatProperties := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceFormatProperties' ) else vkGetPhysicalDeviceFormatProperties := dynLib.GetProcAddress('vkGetPhysicalDeviceFormatProperties');
  if UseInstance then vkGetPhysicalDeviceImageFormatProperties := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceImageFormatProperties' ) else vkGetPhysicalDeviceImageFormatProperties := dynLib.GetProcAddress('vkGetPhysicalDeviceImageFormatProperties');
  if UseInstance then vkCreateDevice := vkGetInstanceProcAddr( Instance, 'vkCreateDevice' ) else vkCreateDevice := dynLib.GetProcAddress('vkCreateDevice');
  if UseInstance then vkDestroyDevice := vkGetInstanceProcAddr( Instance, 'vkDestroyDevice' ) else vkDestroyDevice := dynLib.GetProcAddress('vkDestroyDevice');
  if UseInstance then vkEnumerateInstanceVersion := vkGetInstanceProcAddr( Instance, 'vkEnumerateInstanceVersion' ) else vkEnumerateInstanceVersion := dynLib.GetProcAddress('vkEnumerateInstanceVersion');
  if UseInstance then vkEnumerateInstanceLayerProperties := vkGetInstanceProcAddr( Instance, 'vkEnumerateInstanceLayerProperties' ) else vkEnumerateInstanceLayerProperties := dynLib.GetProcAddress('vkEnumerateInstanceLayerProperties');
  if UseInstance then vkEnumerateInstanceExtensionProperties := vkGetInstanceProcAddr( Instance, 'vkEnumerateInstanceExtensionProperties' ) else vkEnumerateInstanceExtensionProperties := dynLib.GetProcAddress('vkEnumerateInstanceExtensionProperties');
  if UseInstance then vkEnumerateDeviceLayerProperties := vkGetInstanceProcAddr( Instance, 'vkEnumerateDeviceLayerProperties' ) else vkEnumerateDeviceLayerProperties := dynLib.GetProcAddress('vkEnumerateDeviceLayerProperties');
  if UseInstance then vkEnumerateDeviceExtensionProperties := vkGetInstanceProcAddr( Instance, 'vkEnumerateDeviceExtensionProperties' ) else vkEnumerateDeviceExtensionProperties := dynLib.GetProcAddress('vkEnumerateDeviceExtensionProperties');
  if UseInstance then vkGetDeviceQueue := vkGetInstanceProcAddr( Instance, 'vkGetDeviceQueue' ) else vkGetDeviceQueue := dynLib.GetProcAddress('vkGetDeviceQueue');
  if UseInstance then vkQueueSubmit := vkGetInstanceProcAddr( Instance, 'vkQueueSubmit' ) else vkQueueSubmit := dynLib.GetProcAddress('vkQueueSubmit');
  if UseInstance then vkQueueWaitIdle := vkGetInstanceProcAddr( Instance, 'vkQueueWaitIdle' ) else vkQueueWaitIdle := dynLib.GetProcAddress('vkQueueWaitIdle');
  if UseInstance then vkDeviceWaitIdle := vkGetInstanceProcAddr( Instance, 'vkDeviceWaitIdle' ) else vkDeviceWaitIdle := dynLib.GetProcAddress('vkDeviceWaitIdle');
  if UseInstance then vkAllocateMemory := vkGetInstanceProcAddr( Instance, 'vkAllocateMemory' ) else vkAllocateMemory := dynLib.GetProcAddress('vkAllocateMemory');
  if UseInstance then vkFreeMemory := vkGetInstanceProcAddr( Instance, 'vkFreeMemory' ) else vkFreeMemory := dynLib.GetProcAddress('vkFreeMemory');
  if UseInstance then vkMapMemory := vkGetInstanceProcAddr( Instance, 'vkMapMemory' ) else vkMapMemory := dynLib.GetProcAddress('vkMapMemory');
  if UseInstance then vkUnmapMemory := vkGetInstanceProcAddr( Instance, 'vkUnmapMemory' ) else vkUnmapMemory := dynLib.GetProcAddress('vkUnmapMemory');
  if UseInstance then vkFlushMappedMemoryRanges := vkGetInstanceProcAddr( Instance, 'vkFlushMappedMemoryRanges' ) else vkFlushMappedMemoryRanges := dynLib.GetProcAddress('vkFlushMappedMemoryRanges');
  if UseInstance then vkInvalidateMappedMemoryRanges := vkGetInstanceProcAddr( Instance, 'vkInvalidateMappedMemoryRanges' ) else vkInvalidateMappedMemoryRanges := dynLib.GetProcAddress('vkInvalidateMappedMemoryRanges');
  if UseInstance then vkGetDeviceMemoryCommitment := vkGetInstanceProcAddr( Instance, 'vkGetDeviceMemoryCommitment' ) else vkGetDeviceMemoryCommitment := dynLib.GetProcAddress('vkGetDeviceMemoryCommitment');
  if UseInstance then vkGetBufferMemoryRequirements := vkGetInstanceProcAddr( Instance, 'vkGetBufferMemoryRequirements' ) else vkGetBufferMemoryRequirements := dynLib.GetProcAddress('vkGetBufferMemoryRequirements');
  if UseInstance then vkBindBufferMemory := vkGetInstanceProcAddr( Instance, 'vkBindBufferMemory' ) else vkBindBufferMemory := dynLib.GetProcAddress('vkBindBufferMemory');
  if UseInstance then vkGetImageMemoryRequirements := vkGetInstanceProcAddr( Instance, 'vkGetImageMemoryRequirements' ) else vkGetImageMemoryRequirements := dynLib.GetProcAddress('vkGetImageMemoryRequirements');
  if UseInstance then vkBindImageMemory := vkGetInstanceProcAddr( Instance, 'vkBindImageMemory' ) else vkBindImageMemory := dynLib.GetProcAddress('vkBindImageMemory');
  if UseInstance then vkGetImageSparseMemoryRequirements := vkGetInstanceProcAddr( Instance, 'vkGetImageSparseMemoryRequirements' ) else vkGetImageSparseMemoryRequirements := dynLib.GetProcAddress('vkGetImageSparseMemoryRequirements');
  if UseInstance then vkGetPhysicalDeviceSparseImageFormatProperties := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceSparseImageFormatProperties' ) else vkGetPhysicalDeviceSparseImageFormatProperties := dynLib.GetProcAddress('vkGetPhysicalDeviceSparseImageFormatProperties');
  if UseInstance then vkQueueBindSparse := vkGetInstanceProcAddr( Instance, 'vkQueueBindSparse' ) else vkQueueBindSparse := dynLib.GetProcAddress('vkQueueBindSparse');
  if UseInstance then vkCreateFence := vkGetInstanceProcAddr( Instance, 'vkCreateFence' ) else vkCreateFence := dynLib.GetProcAddress('vkCreateFence');
  if UseInstance then vkDestroyFence := vkGetInstanceProcAddr( Instance, 'vkDestroyFence' ) else vkDestroyFence := dynLib.GetProcAddress('vkDestroyFence');
  if UseInstance then vkResetFences := vkGetInstanceProcAddr( Instance, 'vkResetFences' ) else vkResetFences := dynLib.GetProcAddress('vkResetFences');
  if UseInstance then vkGetFenceStatus := vkGetInstanceProcAddr( Instance, 'vkGetFenceStatus' ) else vkGetFenceStatus := dynLib.GetProcAddress('vkGetFenceStatus');
  if UseInstance then vkWaitForFences := vkGetInstanceProcAddr( Instance, 'vkWaitForFences' ) else vkWaitForFences := dynLib.GetProcAddress('vkWaitForFences');
  if UseInstance then vkCreateSemaphore := vkGetInstanceProcAddr( Instance, 'vkCreateSemaphore' ) else vkCreateSemaphore := dynLib.GetProcAddress('vkCreateSemaphore');
  if UseInstance then vkDestroySemaphore := vkGetInstanceProcAddr( Instance, 'vkDestroySemaphore' ) else vkDestroySemaphore := dynLib.GetProcAddress('vkDestroySemaphore');
  if UseInstance then vkCreateEvent := vkGetInstanceProcAddr( Instance, 'vkCreateEvent' ) else vkCreateEvent := dynLib.GetProcAddress('vkCreateEvent');
  if UseInstance then vkDestroyEvent := vkGetInstanceProcAddr( Instance, 'vkDestroyEvent' ) else vkDestroyEvent := dynLib.GetProcAddress('vkDestroyEvent');
  if UseInstance then vkGetEventStatus := vkGetInstanceProcAddr( Instance, 'vkGetEventStatus' ) else vkGetEventStatus := dynLib.GetProcAddress('vkGetEventStatus');
  if UseInstance then vkSetEvent := vkGetInstanceProcAddr( Instance, 'vkSetEvent' ) else vkSetEvent := dynLib.GetProcAddress('vkSetEvent');
  if UseInstance then vkResetEvent := vkGetInstanceProcAddr( Instance, 'vkResetEvent' ) else vkResetEvent := dynLib.GetProcAddress('vkResetEvent');
  if UseInstance then vkCreateQueryPool := vkGetInstanceProcAddr( Instance, 'vkCreateQueryPool' ) else vkCreateQueryPool := dynLib.GetProcAddress('vkCreateQueryPool');
  if UseInstance then vkDestroyQueryPool := vkGetInstanceProcAddr( Instance, 'vkDestroyQueryPool' ) else vkDestroyQueryPool := dynLib.GetProcAddress('vkDestroyQueryPool');
  if UseInstance then vkGetQueryPoolResults := vkGetInstanceProcAddr( Instance, 'vkGetQueryPoolResults' ) else vkGetQueryPoolResults := dynLib.GetProcAddress('vkGetQueryPoolResults');
  if UseInstance then vkCreateBuffer := vkGetInstanceProcAddr( Instance, 'vkCreateBuffer' ) else vkCreateBuffer := dynLib.GetProcAddress('vkCreateBuffer');
  if UseInstance then vkDestroyBuffer := vkGetInstanceProcAddr( Instance, 'vkDestroyBuffer' ) else vkDestroyBuffer := dynLib.GetProcAddress('vkDestroyBuffer');
  if UseInstance then vkCreateBufferView := vkGetInstanceProcAddr( Instance, 'vkCreateBufferView' ) else vkCreateBufferView := dynLib.GetProcAddress('vkCreateBufferView');
  if UseInstance then vkDestroyBufferView := vkGetInstanceProcAddr( Instance, 'vkDestroyBufferView' ) else vkDestroyBufferView := dynLib.GetProcAddress('vkDestroyBufferView');
  if UseInstance then vkCreateImage := vkGetInstanceProcAddr( Instance, 'vkCreateImage' ) else vkCreateImage := dynLib.GetProcAddress('vkCreateImage');
  if UseInstance then vkDestroyImage := vkGetInstanceProcAddr( Instance, 'vkDestroyImage' ) else vkDestroyImage := dynLib.GetProcAddress('vkDestroyImage');
  if UseInstance then vkGetImageSubresourceLayout := vkGetInstanceProcAddr( Instance, 'vkGetImageSubresourceLayout' ) else vkGetImageSubresourceLayout := dynLib.GetProcAddress('vkGetImageSubresourceLayout');
  if UseInstance then vkCreateImageView := vkGetInstanceProcAddr( Instance, 'vkCreateImageView' ) else vkCreateImageView := dynLib.GetProcAddress('vkCreateImageView');
  if UseInstance then vkDestroyImageView := vkGetInstanceProcAddr( Instance, 'vkDestroyImageView' ) else vkDestroyImageView := dynLib.GetProcAddress('vkDestroyImageView');
  if UseInstance then vkCreateShaderModule := vkGetInstanceProcAddr( Instance, 'vkCreateShaderModule' ) else vkCreateShaderModule := dynLib.GetProcAddress('vkCreateShaderModule');
  if UseInstance then vkDestroyShaderModule := vkGetInstanceProcAddr( Instance, 'vkDestroyShaderModule' ) else vkDestroyShaderModule := dynLib.GetProcAddress('vkDestroyShaderModule');
  if UseInstance then vkCreatePipelineCache := vkGetInstanceProcAddr( Instance, 'vkCreatePipelineCache' ) else vkCreatePipelineCache := dynLib.GetProcAddress('vkCreatePipelineCache');
  if UseInstance then vkDestroyPipelineCache := vkGetInstanceProcAddr( Instance, 'vkDestroyPipelineCache' ) else vkDestroyPipelineCache := dynLib.GetProcAddress('vkDestroyPipelineCache');
  if UseInstance then vkGetPipelineCacheData := vkGetInstanceProcAddr( Instance, 'vkGetPipelineCacheData' ) else vkGetPipelineCacheData := dynLib.GetProcAddress('vkGetPipelineCacheData');
  if UseInstance then vkMergePipelineCaches := vkGetInstanceProcAddr( Instance, 'vkMergePipelineCaches' ) else vkMergePipelineCaches := dynLib.GetProcAddress('vkMergePipelineCaches');
  if UseInstance then vkCreateGraphicsPipelines := vkGetInstanceProcAddr( Instance, 'vkCreateGraphicsPipelines' ) else vkCreateGraphicsPipelines := dynLib.GetProcAddress('vkCreateGraphicsPipelines');
  if UseInstance then vkCreateComputePipelines := vkGetInstanceProcAddr( Instance, 'vkCreateComputePipelines' ) else vkCreateComputePipelines := dynLib.GetProcAddress('vkCreateComputePipelines');
  if UseInstance then vkDestroyPipeline := vkGetInstanceProcAddr( Instance, 'vkDestroyPipeline' ) else vkDestroyPipeline := dynLib.GetProcAddress('vkDestroyPipeline');
  if UseInstance then vkCreatePipelineLayout := vkGetInstanceProcAddr( Instance, 'vkCreatePipelineLayout' ) else vkCreatePipelineLayout := dynLib.GetProcAddress('vkCreatePipelineLayout');
  if UseInstance then vkDestroyPipelineLayout := vkGetInstanceProcAddr( Instance, 'vkDestroyPipelineLayout' ) else vkDestroyPipelineLayout := dynLib.GetProcAddress('vkDestroyPipelineLayout');
  if UseInstance then vkCreateSampler := vkGetInstanceProcAddr( Instance, 'vkCreateSampler' ) else vkCreateSampler := dynLib.GetProcAddress('vkCreateSampler');
  if UseInstance then vkDestroySampler := vkGetInstanceProcAddr( Instance, 'vkDestroySampler' ) else vkDestroySampler := dynLib.GetProcAddress('vkDestroySampler');
  if UseInstance then vkCreateDescriptorSetLayout := vkGetInstanceProcAddr( Instance, 'vkCreateDescriptorSetLayout' ) else vkCreateDescriptorSetLayout := dynLib.GetProcAddress('vkCreateDescriptorSetLayout');
  if UseInstance then vkDestroyDescriptorSetLayout := vkGetInstanceProcAddr( Instance, 'vkDestroyDescriptorSetLayout' ) else vkDestroyDescriptorSetLayout := dynLib.GetProcAddress('vkDestroyDescriptorSetLayout');
  if UseInstance then vkCreateDescriptorPool := vkGetInstanceProcAddr( Instance, 'vkCreateDescriptorPool' ) else vkCreateDescriptorPool := dynLib.GetProcAddress('vkCreateDescriptorPool');
  if UseInstance then vkDestroyDescriptorPool := vkGetInstanceProcAddr( Instance, 'vkDestroyDescriptorPool' ) else vkDestroyDescriptorPool := dynLib.GetProcAddress('vkDestroyDescriptorPool');
  if UseInstance then vkResetDescriptorPool := vkGetInstanceProcAddr( Instance, 'vkResetDescriptorPool' ) else vkResetDescriptorPool := dynLib.GetProcAddress('vkResetDescriptorPool');
  if UseInstance then vkAllocateDescriptorSets := vkGetInstanceProcAddr( Instance, 'vkAllocateDescriptorSets' ) else vkAllocateDescriptorSets := dynLib.GetProcAddress('vkAllocateDescriptorSets');
  if UseInstance then vkFreeDescriptorSets := vkGetInstanceProcAddr( Instance, 'vkFreeDescriptorSets' ) else vkFreeDescriptorSets := dynLib.GetProcAddress('vkFreeDescriptorSets');
  if UseInstance then vkUpdateDescriptorSets := vkGetInstanceProcAddr( Instance, 'vkUpdateDescriptorSets' ) else vkUpdateDescriptorSets := dynLib.GetProcAddress('vkUpdateDescriptorSets');
  if UseInstance then vkCreateFramebuffer := vkGetInstanceProcAddr( Instance, 'vkCreateFramebuffer' ) else vkCreateFramebuffer := dynLib.GetProcAddress('vkCreateFramebuffer');
  if UseInstance then vkDestroyFramebuffer := vkGetInstanceProcAddr( Instance, 'vkDestroyFramebuffer' ) else vkDestroyFramebuffer := dynLib.GetProcAddress('vkDestroyFramebuffer');
  if UseInstance then vkCreateRenderPass := vkGetInstanceProcAddr( Instance, 'vkCreateRenderPass' ) else vkCreateRenderPass := dynLib.GetProcAddress('vkCreateRenderPass');
  if UseInstance then vkDestroyRenderPass := vkGetInstanceProcAddr( Instance, 'vkDestroyRenderPass' ) else vkDestroyRenderPass := dynLib.GetProcAddress('vkDestroyRenderPass');
  if UseInstance then vkGetRenderAreaGranularity := vkGetInstanceProcAddr( Instance, 'vkGetRenderAreaGranularity' ) else vkGetRenderAreaGranularity := dynLib.GetProcAddress('vkGetRenderAreaGranularity');
  if UseInstance then vkCreateCommandPool := vkGetInstanceProcAddr( Instance, 'vkCreateCommandPool' ) else vkCreateCommandPool := dynLib.GetProcAddress('vkCreateCommandPool');
  if UseInstance then vkDestroyCommandPool := vkGetInstanceProcAddr( Instance, 'vkDestroyCommandPool' ) else vkDestroyCommandPool := dynLib.GetProcAddress('vkDestroyCommandPool');
  if UseInstance then vkResetCommandPool := vkGetInstanceProcAddr( Instance, 'vkResetCommandPool' ) else vkResetCommandPool := dynLib.GetProcAddress('vkResetCommandPool');
  if UseInstance then vkAllocateCommandBuffers := vkGetInstanceProcAddr( Instance, 'vkAllocateCommandBuffers' ) else vkAllocateCommandBuffers := dynLib.GetProcAddress('vkAllocateCommandBuffers');
  if UseInstance then vkFreeCommandBuffers := vkGetInstanceProcAddr( Instance, 'vkFreeCommandBuffers' ) else vkFreeCommandBuffers := dynLib.GetProcAddress('vkFreeCommandBuffers');
  if UseInstance then vkBeginCommandBuffer := vkGetInstanceProcAddr( Instance, 'vkBeginCommandBuffer' ) else vkBeginCommandBuffer := dynLib.GetProcAddress('vkBeginCommandBuffer');
  if UseInstance then vkEndCommandBuffer := vkGetInstanceProcAddr( Instance, 'vkEndCommandBuffer' ) else vkEndCommandBuffer := dynLib.GetProcAddress('vkEndCommandBuffer');
  if UseInstance then vkResetCommandBuffer := vkGetInstanceProcAddr( Instance, 'vkResetCommandBuffer' ) else vkResetCommandBuffer := dynLib.GetProcAddress('vkResetCommandBuffer');
  if UseInstance then vkCmdBindPipeline := vkGetInstanceProcAddr( Instance, 'vkCmdBindPipeline' ) else vkCmdBindPipeline := dynLib.GetProcAddress('vkCmdBindPipeline');
  if UseInstance then vkCmdSetViewport := vkGetInstanceProcAddr( Instance, 'vkCmdSetViewport' ) else vkCmdSetViewport := dynLib.GetProcAddress('vkCmdSetViewport');
  if UseInstance then vkCmdSetScissor := vkGetInstanceProcAddr( Instance, 'vkCmdSetScissor' ) else vkCmdSetScissor := dynLib.GetProcAddress('vkCmdSetScissor');
  if UseInstance then vkCmdSetLineWidth := vkGetInstanceProcAddr( Instance, 'vkCmdSetLineWidth' ) else vkCmdSetLineWidth := dynLib.GetProcAddress('vkCmdSetLineWidth');
  if UseInstance then vkCmdSetDepthBias := vkGetInstanceProcAddr( Instance, 'vkCmdSetDepthBias' ) else vkCmdSetDepthBias := dynLib.GetProcAddress('vkCmdSetDepthBias');
  if UseInstance then vkCmdSetBlendConstants := vkGetInstanceProcAddr( Instance, 'vkCmdSetBlendConstants' ) else vkCmdSetBlendConstants := dynLib.GetProcAddress('vkCmdSetBlendConstants');
  if UseInstance then vkCmdSetDepthBounds := vkGetInstanceProcAddr( Instance, 'vkCmdSetDepthBounds' ) else vkCmdSetDepthBounds := dynLib.GetProcAddress('vkCmdSetDepthBounds');
  if UseInstance then vkCmdSetStencilCompareMask := vkGetInstanceProcAddr( Instance, 'vkCmdSetStencilCompareMask' ) else vkCmdSetStencilCompareMask := dynLib.GetProcAddress('vkCmdSetStencilCompareMask');
  if UseInstance then vkCmdSetStencilWriteMask := vkGetInstanceProcAddr( Instance, 'vkCmdSetStencilWriteMask' ) else vkCmdSetStencilWriteMask := dynLib.GetProcAddress('vkCmdSetStencilWriteMask');
  if UseInstance then vkCmdSetStencilReference := vkGetInstanceProcAddr( Instance, 'vkCmdSetStencilReference' ) else vkCmdSetStencilReference := dynLib.GetProcAddress('vkCmdSetStencilReference');
  if UseInstance then vkCmdBindDescriptorSets := vkGetInstanceProcAddr( Instance, 'vkCmdBindDescriptorSets' ) else vkCmdBindDescriptorSets := dynLib.GetProcAddress('vkCmdBindDescriptorSets');
  if UseInstance then vkCmdBindIndexBuffer := vkGetInstanceProcAddr( Instance, 'vkCmdBindIndexBuffer' ) else vkCmdBindIndexBuffer := dynLib.GetProcAddress('vkCmdBindIndexBuffer');
  if UseInstance then vkCmdBindVertexBuffers := vkGetInstanceProcAddr( Instance, 'vkCmdBindVertexBuffers' ) else vkCmdBindVertexBuffers := dynLib.GetProcAddress('vkCmdBindVertexBuffers');
  if UseInstance then vkCmdDraw := vkGetInstanceProcAddr( Instance, 'vkCmdDraw' ) else vkCmdDraw := dynLib.GetProcAddress('vkCmdDraw');
  if UseInstance then vkCmdDrawIndexed := vkGetInstanceProcAddr( Instance, 'vkCmdDrawIndexed' ) else vkCmdDrawIndexed := dynLib.GetProcAddress('vkCmdDrawIndexed');
  if UseInstance then vkCmdDrawIndirect := vkGetInstanceProcAddr( Instance, 'vkCmdDrawIndirect' ) else vkCmdDrawIndirect := dynLib.GetProcAddress('vkCmdDrawIndirect');
  if UseInstance then vkCmdDrawIndexedIndirect := vkGetInstanceProcAddr( Instance, 'vkCmdDrawIndexedIndirect' ) else vkCmdDrawIndexedIndirect := dynLib.GetProcAddress('vkCmdDrawIndexedIndirect');
  if UseInstance then vkCmdDispatch := vkGetInstanceProcAddr( Instance, 'vkCmdDispatch' ) else vkCmdDispatch := dynLib.GetProcAddress('vkCmdDispatch');
  if UseInstance then vkCmdDispatchIndirect := vkGetInstanceProcAddr( Instance, 'vkCmdDispatchIndirect' ) else vkCmdDispatchIndirect := dynLib.GetProcAddress('vkCmdDispatchIndirect');
  if UseInstance then vkCmdCopyBuffer := vkGetInstanceProcAddr( Instance, 'vkCmdCopyBuffer' ) else vkCmdCopyBuffer := dynLib.GetProcAddress('vkCmdCopyBuffer');
  if UseInstance then vkCmdCopyImage := vkGetInstanceProcAddr( Instance, 'vkCmdCopyImage' ) else vkCmdCopyImage := dynLib.GetProcAddress('vkCmdCopyImage');
  if UseInstance then vkCmdBlitImage := vkGetInstanceProcAddr( Instance, 'vkCmdBlitImage' ) else vkCmdBlitImage := dynLib.GetProcAddress('vkCmdBlitImage');
  if UseInstance then vkCmdCopyBufferToImage := vkGetInstanceProcAddr( Instance, 'vkCmdCopyBufferToImage' ) else vkCmdCopyBufferToImage := dynLib.GetProcAddress('vkCmdCopyBufferToImage');
  if UseInstance then vkCmdCopyImageToBuffer := vkGetInstanceProcAddr( Instance, 'vkCmdCopyImageToBuffer' ) else vkCmdCopyImageToBuffer := dynLib.GetProcAddress('vkCmdCopyImageToBuffer');
  if UseInstance then vkCmdUpdateBuffer := vkGetInstanceProcAddr( Instance, 'vkCmdUpdateBuffer' ) else vkCmdUpdateBuffer := dynLib.GetProcAddress('vkCmdUpdateBuffer');
  if UseInstance then vkCmdFillBuffer := vkGetInstanceProcAddr( Instance, 'vkCmdFillBuffer' ) else vkCmdFillBuffer := dynLib.GetProcAddress('vkCmdFillBuffer');
  if UseInstance then vkCmdClearColorImage := vkGetInstanceProcAddr( Instance, 'vkCmdClearColorImage' ) else vkCmdClearColorImage := dynLib.GetProcAddress('vkCmdClearColorImage');
  if UseInstance then vkCmdClearDepthStencilImage := vkGetInstanceProcAddr( Instance, 'vkCmdClearDepthStencilImage' ) else vkCmdClearDepthStencilImage := dynLib.GetProcAddress('vkCmdClearDepthStencilImage');
  if UseInstance then vkCmdClearAttachments := vkGetInstanceProcAddr( Instance, 'vkCmdClearAttachments' ) else vkCmdClearAttachments := dynLib.GetProcAddress('vkCmdClearAttachments');
  if UseInstance then vkCmdResolveImage := vkGetInstanceProcAddr( Instance, 'vkCmdResolveImage' ) else vkCmdResolveImage := dynLib.GetProcAddress('vkCmdResolveImage');
  if UseInstance then vkCmdSetEvent := vkGetInstanceProcAddr( Instance, 'vkCmdSetEvent' ) else vkCmdSetEvent := dynLib.GetProcAddress('vkCmdSetEvent');
  if UseInstance then vkCmdResetEvent := vkGetInstanceProcAddr( Instance, 'vkCmdResetEvent' ) else vkCmdResetEvent := dynLib.GetProcAddress('vkCmdResetEvent');
  if UseInstance then vkCmdWaitEvents := vkGetInstanceProcAddr( Instance, 'vkCmdWaitEvents' ) else vkCmdWaitEvents := dynLib.GetProcAddress('vkCmdWaitEvents');
  if UseInstance then vkCmdPipelineBarrier := vkGetInstanceProcAddr( Instance, 'vkCmdPipelineBarrier' ) else vkCmdPipelineBarrier := dynLib.GetProcAddress('vkCmdPipelineBarrier');
  if UseInstance then vkCmdBeginQuery := vkGetInstanceProcAddr( Instance, 'vkCmdBeginQuery' ) else vkCmdBeginQuery := dynLib.GetProcAddress('vkCmdBeginQuery');
  if UseInstance then vkCmdEndQuery := vkGetInstanceProcAddr( Instance, 'vkCmdEndQuery' ) else vkCmdEndQuery := dynLib.GetProcAddress('vkCmdEndQuery');
  if UseInstance then vkCmdBeginConditionalRenderingEXT := vkGetInstanceProcAddr( Instance, 'vkCmdBeginConditionalRenderingEXT' ) else vkCmdBeginConditionalRenderingEXT := dynLib.GetProcAddress('vkCmdBeginConditionalRenderingEXT');
  if UseInstance then vkCmdEndConditionalRenderingEXT := vkGetInstanceProcAddr( Instance, 'vkCmdEndConditionalRenderingEXT' ) else vkCmdEndConditionalRenderingEXT := dynLib.GetProcAddress('vkCmdEndConditionalRenderingEXT');
  if UseInstance then vkCmdResetQueryPool := vkGetInstanceProcAddr( Instance, 'vkCmdResetQueryPool' ) else vkCmdResetQueryPool := dynLib.GetProcAddress('vkCmdResetQueryPool');
  if UseInstance then vkCmdWriteTimestamp := vkGetInstanceProcAddr( Instance, 'vkCmdWriteTimestamp' ) else vkCmdWriteTimestamp := dynLib.GetProcAddress('vkCmdWriteTimestamp');
  if UseInstance then vkCmdCopyQueryPoolResults := vkGetInstanceProcAddr( Instance, 'vkCmdCopyQueryPoolResults' ) else vkCmdCopyQueryPoolResults := dynLib.GetProcAddress('vkCmdCopyQueryPoolResults');
  if UseInstance then vkCmdPushConstants := vkGetInstanceProcAddr( Instance, 'vkCmdPushConstants' ) else vkCmdPushConstants := dynLib.GetProcAddress('vkCmdPushConstants');
  if UseInstance then vkCmdBeginRenderPass := vkGetInstanceProcAddr( Instance, 'vkCmdBeginRenderPass' ) else vkCmdBeginRenderPass := dynLib.GetProcAddress('vkCmdBeginRenderPass');
  if UseInstance then vkCmdNextSubpass := vkGetInstanceProcAddr( Instance, 'vkCmdNextSubpass' ) else vkCmdNextSubpass := dynLib.GetProcAddress('vkCmdNextSubpass');
  if UseInstance then vkCmdEndRenderPass := vkGetInstanceProcAddr( Instance, 'vkCmdEndRenderPass' ) else vkCmdEndRenderPass := dynLib.GetProcAddress('vkCmdEndRenderPass');
  if UseInstance then vkCmdExecuteCommands := vkGetInstanceProcAddr( Instance, 'vkCmdExecuteCommands' ) else vkCmdExecuteCommands := dynLib.GetProcAddress('vkCmdExecuteCommands');
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}if UseInstance then vkCreateAndroidSurfaceKHR := vkGetInstanceProcAddr( Instance, 'vkCreateAndroidSurfaceKHR' ) else vkCreateAndroidSurfaceKHR := dynLib.GetProcAddress('vkCreateAndroidSurfaceKHR');{$endif}
  if UseInstance then vkGetPhysicalDeviceDisplayPropertiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceDisplayPropertiesKHR' ) else vkGetPhysicalDeviceDisplayPropertiesKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceDisplayPropertiesKHR');
  if UseInstance then vkGetPhysicalDeviceDisplayPlanePropertiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceDisplayPlanePropertiesKHR' ) else vkGetPhysicalDeviceDisplayPlanePropertiesKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceDisplayPlanePropertiesKHR');
  if UseInstance then vkGetDisplayPlaneSupportedDisplaysKHR := vkGetInstanceProcAddr( Instance, 'vkGetDisplayPlaneSupportedDisplaysKHR' ) else vkGetDisplayPlaneSupportedDisplaysKHR := dynLib.GetProcAddress('vkGetDisplayPlaneSupportedDisplaysKHR');
  if UseInstance then vkGetDisplayModePropertiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetDisplayModePropertiesKHR' ) else vkGetDisplayModePropertiesKHR := dynLib.GetProcAddress('vkGetDisplayModePropertiesKHR');
  if UseInstance then vkCreateDisplayModeKHR := vkGetInstanceProcAddr( Instance, 'vkCreateDisplayModeKHR' ) else vkCreateDisplayModeKHR := dynLib.GetProcAddress('vkCreateDisplayModeKHR');
  if UseInstance then vkGetDisplayPlaneCapabilitiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetDisplayPlaneCapabilitiesKHR' ) else vkGetDisplayPlaneCapabilitiesKHR := dynLib.GetProcAddress('vkGetDisplayPlaneCapabilitiesKHR');
  if UseInstance then vkCreateDisplayPlaneSurfaceKHR := vkGetInstanceProcAddr( Instance, 'vkCreateDisplayPlaneSurfaceKHR' ) else vkCreateDisplayPlaneSurfaceKHR := dynLib.GetProcAddress('vkCreateDisplayPlaneSurfaceKHR');
  if UseInstance then vkCreateSharedSwapchainsKHR := vkGetInstanceProcAddr( Instance, 'vkCreateSharedSwapchainsKHR' ) else vkCreateSharedSwapchainsKHR := dynLib.GetProcAddress('vkCreateSharedSwapchainsKHR');
  {$ifdef VK_USE_PLATFORM_MIR_KHR}if UseInstance then vkCreateMirSurfaceKHR := vkGetInstanceProcAddr( Instance, 'vkCreateMirSurfaceKHR' ) else vkCreateMirSurfaceKHR := dynLib.GetProcAddress('vkCreateMirSurfaceKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_MIR_KHR}if UseInstance then vkGetPhysicalDeviceMirPresentationSupportKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceMirPresentationSupportKHR' ) else vkGetPhysicalDeviceMirPresentationSupportKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceMirPresentationSupportKHR');{$endif}
  if UseInstance then vkDestroySurfaceKHR := vkGetInstanceProcAddr( Instance, 'vkDestroySurfaceKHR' ) else vkDestroySurfaceKHR := dynLib.GetProcAddress('vkDestroySurfaceKHR');
  if UseInstance then vkGetPhysicalDeviceSurfaceSupportKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceSurfaceSupportKHR' ) else vkGetPhysicalDeviceSurfaceSupportKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceSurfaceSupportKHR');
  if UseInstance then vkGetPhysicalDeviceSurfaceCapabilitiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceSurfaceCapabilitiesKHR' ) else vkGetPhysicalDeviceSurfaceCapabilitiesKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceSurfaceCapabilitiesKHR');
  if UseInstance then vkGetPhysicalDeviceSurfaceFormatsKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceSurfaceFormatsKHR' ) else vkGetPhysicalDeviceSurfaceFormatsKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceSurfaceFormatsKHR');
  if UseInstance then vkGetPhysicalDeviceSurfacePresentModesKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceSurfacePresentModesKHR' ) else vkGetPhysicalDeviceSurfacePresentModesKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceSurfacePresentModesKHR');
  if UseInstance then vkCreateSwapchainKHR := vkGetInstanceProcAddr( Instance, 'vkCreateSwapchainKHR' ) else vkCreateSwapchainKHR := dynLib.GetProcAddress('vkCreateSwapchainKHR');
  if UseInstance then vkDestroySwapchainKHR := vkGetInstanceProcAddr( Instance, 'vkDestroySwapchainKHR' ) else vkDestroySwapchainKHR := dynLib.GetProcAddress('vkDestroySwapchainKHR');
  if UseInstance then vkGetSwapchainImagesKHR := vkGetInstanceProcAddr( Instance, 'vkGetSwapchainImagesKHR' ) else vkGetSwapchainImagesKHR := dynLib.GetProcAddress('vkGetSwapchainImagesKHR');
  if UseInstance then vkAcquireNextImageKHR := vkGetInstanceProcAddr( Instance, 'vkAcquireNextImageKHR' ) else vkAcquireNextImageKHR := dynLib.GetProcAddress('vkAcquireNextImageKHR');
  if UseInstance then vkQueuePresentKHR := vkGetInstanceProcAddr( Instance, 'vkQueuePresentKHR' ) else vkQueuePresentKHR := dynLib.GetProcAddress('vkQueuePresentKHR');
  {$ifdef VK_USE_PLATFORM_VI_NN}if UseInstance then vkCreateViSurfaceNN := vkGetInstanceProcAddr( Instance, 'vkCreateViSurfaceNN' ) else vkCreateViSurfaceNN := dynLib.GetProcAddress('vkCreateViSurfaceNN');{$endif}
  {$ifdef VK_USE_PLATFORM_WAYLAND_KHR}if UseInstance then vkCreateWaylandSurfaceKHR := vkGetInstanceProcAddr( Instance, 'vkCreateWaylandSurfaceKHR' ) else vkCreateWaylandSurfaceKHR := dynLib.GetProcAddress('vkCreateWaylandSurfaceKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_WAYLAND_KHR}if UseInstance then vkGetPhysicalDeviceWaylandPresentationSupportKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceWaylandPresentationSupportKHR' ) else vkGetPhysicalDeviceWaylandPresentationSupportKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceWaylandPresentationSupportKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}if UseInstance then vkCreateWin32SurfaceKHR := vkGetInstanceProcAddr( Instance, 'vkCreateWin32SurfaceKHR' ) else vkCreateWin32SurfaceKHR := dynLib.GetProcAddress('vkCreateWin32SurfaceKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}if UseInstance then vkGetPhysicalDeviceWin32PresentationSupportKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceWin32PresentationSupportKHR' ) else vkGetPhysicalDeviceWin32PresentationSupportKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceWin32PresentationSupportKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}if UseInstance then vkCreateXlibSurfaceKHR := vkGetInstanceProcAddr( Instance, 'vkCreateXlibSurfaceKHR' ) else vkCreateXlibSurfaceKHR := dynLib.GetProcAddress('vkCreateXlibSurfaceKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_KHR}if UseInstance then vkGetPhysicalDeviceXlibPresentationSupportKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceXlibPresentationSupportKHR' ) else vkGetPhysicalDeviceXlibPresentationSupportKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceXlibPresentationSupportKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_XCB_KHR}if UseInstance then vkCreateXcbSurfaceKHR := vkGetInstanceProcAddr( Instance, 'vkCreateXcbSurfaceKHR' ) else vkCreateXcbSurfaceKHR := dynLib.GetProcAddress('vkCreateXcbSurfaceKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_XCB_KHR}if UseInstance then vkGetPhysicalDeviceXcbPresentationSupportKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceXcbPresentationSupportKHR' ) else vkGetPhysicalDeviceXcbPresentationSupportKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceXcbPresentationSupportKHR');{$endif}
  if UseInstance then vkCreateDebugReportCallbackEXT := vkGetInstanceProcAddr( Instance, 'vkCreateDebugReportCallbackEXT' ) else vkCreateDebugReportCallbackEXT := dynLib.GetProcAddress('vkCreateDebugReportCallbackEXT');
  if UseInstance then vkDestroyDebugReportCallbackEXT := vkGetInstanceProcAddr( Instance, 'vkDestroyDebugReportCallbackEXT' ) else vkDestroyDebugReportCallbackEXT := dynLib.GetProcAddress('vkDestroyDebugReportCallbackEXT');
  if UseInstance then vkDebugReportMessageEXT := vkGetInstanceProcAddr( Instance, 'vkDebugReportMessageEXT' ) else vkDebugReportMessageEXT := dynLib.GetProcAddress('vkDebugReportMessageEXT');
  if UseInstance then vkDebugMarkerSetObjectNameEXT := vkGetInstanceProcAddr( Instance, 'vkDebugMarkerSetObjectNameEXT' ) else vkDebugMarkerSetObjectNameEXT := dynLib.GetProcAddress('vkDebugMarkerSetObjectNameEXT');
  if UseInstance then vkDebugMarkerSetObjectTagEXT := vkGetInstanceProcAddr( Instance, 'vkDebugMarkerSetObjectTagEXT' ) else vkDebugMarkerSetObjectTagEXT := dynLib.GetProcAddress('vkDebugMarkerSetObjectTagEXT');
  if UseInstance then vkCmdDebugMarkerBeginEXT := vkGetInstanceProcAddr( Instance, 'vkCmdDebugMarkerBeginEXT' ) else vkCmdDebugMarkerBeginEXT := dynLib.GetProcAddress('vkCmdDebugMarkerBeginEXT');
  if UseInstance then vkCmdDebugMarkerEndEXT := vkGetInstanceProcAddr( Instance, 'vkCmdDebugMarkerEndEXT' ) else vkCmdDebugMarkerEndEXT := dynLib.GetProcAddress('vkCmdDebugMarkerEndEXT');
  if UseInstance then vkCmdDebugMarkerInsertEXT := vkGetInstanceProcAddr( Instance, 'vkCmdDebugMarkerInsertEXT' ) else vkCmdDebugMarkerInsertEXT := dynLib.GetProcAddress('vkCmdDebugMarkerInsertEXT');
  if UseInstance then vkGetPhysicalDeviceExternalImageFormatPropertiesNV := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceExternalImageFormatPropertiesNV' ) else vkGetPhysicalDeviceExternalImageFormatPropertiesNV := dynLib.GetProcAddress('vkGetPhysicalDeviceExternalImageFormatPropertiesNV');
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}if UseInstance then vkGetMemoryWin32HandleNV := vkGetInstanceProcAddr( Instance, 'vkGetMemoryWin32HandleNV' ) else vkGetMemoryWin32HandleNV := dynLib.GetProcAddress('vkGetMemoryWin32HandleNV');{$endif}
  if UseInstance then vkCmdDrawIndirectCountAMD := vkGetInstanceProcAddr( Instance, 'vkCmdDrawIndirectCountAMD' ) else vkCmdDrawIndirectCountAMD := dynLib.GetProcAddress('vkCmdDrawIndirectCountAMD');
  if UseInstance then vkCmdDrawIndexedIndirectCountAMD := vkGetInstanceProcAddr( Instance, 'vkCmdDrawIndexedIndirectCountAMD' ) else vkCmdDrawIndexedIndirectCountAMD := dynLib.GetProcAddress('vkCmdDrawIndexedIndirectCountAMD');
  if UseInstance then vkCmdProcessCommandsNVX := vkGetInstanceProcAddr( Instance, 'vkCmdProcessCommandsNVX' ) else vkCmdProcessCommandsNVX := dynLib.GetProcAddress('vkCmdProcessCommandsNVX');
  if UseInstance then vkCmdReserveSpaceForCommandsNVX := vkGetInstanceProcAddr( Instance, 'vkCmdReserveSpaceForCommandsNVX' ) else vkCmdReserveSpaceForCommandsNVX := dynLib.GetProcAddress('vkCmdReserveSpaceForCommandsNVX');
  if UseInstance then vkCreateIndirectCommandsLayoutNVX := vkGetInstanceProcAddr( Instance, 'vkCreateIndirectCommandsLayoutNVX' ) else vkCreateIndirectCommandsLayoutNVX := dynLib.GetProcAddress('vkCreateIndirectCommandsLayoutNVX');
  if UseInstance then vkDestroyIndirectCommandsLayoutNVX := vkGetInstanceProcAddr( Instance, 'vkDestroyIndirectCommandsLayoutNVX' ) else vkDestroyIndirectCommandsLayoutNVX := dynLib.GetProcAddress('vkDestroyIndirectCommandsLayoutNVX');
  if UseInstance then vkCreateObjectTableNVX := vkGetInstanceProcAddr( Instance, 'vkCreateObjectTableNVX' ) else vkCreateObjectTableNVX := dynLib.GetProcAddress('vkCreateObjectTableNVX');
  if UseInstance then vkDestroyObjectTableNVX := vkGetInstanceProcAddr( Instance, 'vkDestroyObjectTableNVX' ) else vkDestroyObjectTableNVX := dynLib.GetProcAddress('vkDestroyObjectTableNVX');
  if UseInstance then vkRegisterObjectsNVX := vkGetInstanceProcAddr( Instance, 'vkRegisterObjectsNVX' ) else vkRegisterObjectsNVX := dynLib.GetProcAddress('vkRegisterObjectsNVX');
  if UseInstance then vkUnregisterObjectsNVX := vkGetInstanceProcAddr( Instance, 'vkUnregisterObjectsNVX' ) else vkUnregisterObjectsNVX := dynLib.GetProcAddress('vkUnregisterObjectsNVX');
  if UseInstance then vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX' ) else vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX := dynLib.GetProcAddress('vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX');
  if UseInstance then vkGetPhysicalDeviceFeatures2 := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceFeatures2' ) else vkGetPhysicalDeviceFeatures2 := dynLib.GetProcAddress('vkGetPhysicalDeviceFeatures2');
  if UseInstance then vkGetPhysicalDeviceFeatures2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceFeatures2KHR' ) else vkGetPhysicalDeviceFeatures2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceFeatures2KHR');
  if UseInstance then vkGetPhysicalDeviceProperties2 := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceProperties2' ) else vkGetPhysicalDeviceProperties2 := dynLib.GetProcAddress('vkGetPhysicalDeviceProperties2');
  if UseInstance then vkGetPhysicalDeviceProperties2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceProperties2KHR' ) else vkGetPhysicalDeviceProperties2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceProperties2KHR');
  if UseInstance then vkGetPhysicalDeviceFormatProperties2 := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceFormatProperties2' ) else vkGetPhysicalDeviceFormatProperties2 := dynLib.GetProcAddress('vkGetPhysicalDeviceFormatProperties2');
  if UseInstance then vkGetPhysicalDeviceFormatProperties2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceFormatProperties2KHR' ) else vkGetPhysicalDeviceFormatProperties2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceFormatProperties2KHR');
  if UseInstance then vkGetPhysicalDeviceImageFormatProperties2 := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceImageFormatProperties2' ) else vkGetPhysicalDeviceImageFormatProperties2 := dynLib.GetProcAddress('vkGetPhysicalDeviceImageFormatProperties2');
  if UseInstance then vkGetPhysicalDeviceImageFormatProperties2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceImageFormatProperties2KHR' ) else vkGetPhysicalDeviceImageFormatProperties2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceImageFormatProperties2KHR');
  if UseInstance then vkGetPhysicalDeviceQueueFamilyProperties2 := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceQueueFamilyProperties2' ) else vkGetPhysicalDeviceQueueFamilyProperties2 := dynLib.GetProcAddress('vkGetPhysicalDeviceQueueFamilyProperties2');
  if UseInstance then vkGetPhysicalDeviceQueueFamilyProperties2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceQueueFamilyProperties2KHR' ) else vkGetPhysicalDeviceQueueFamilyProperties2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceQueueFamilyProperties2KHR');
  if UseInstance then vkGetPhysicalDeviceMemoryProperties2 := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceMemoryProperties2' ) else vkGetPhysicalDeviceMemoryProperties2 := dynLib.GetProcAddress('vkGetPhysicalDeviceMemoryProperties2');
  if UseInstance then vkGetPhysicalDeviceMemoryProperties2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceMemoryProperties2KHR' ) else vkGetPhysicalDeviceMemoryProperties2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceMemoryProperties2KHR');
  if UseInstance then vkGetPhysicalDeviceSparseImageFormatProperties2 := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceSparseImageFormatProperties2' ) else vkGetPhysicalDeviceSparseImageFormatProperties2 := dynLib.GetProcAddress('vkGetPhysicalDeviceSparseImageFormatProperties2');
  if UseInstance then vkGetPhysicalDeviceSparseImageFormatProperties2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceSparseImageFormatProperties2KHR' ) else vkGetPhysicalDeviceSparseImageFormatProperties2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceSparseImageFormatProperties2KHR');
  if UseInstance then vkCmdPushDescriptorSetKHR := vkGetInstanceProcAddr( Instance, 'vkCmdPushDescriptorSetKHR' ) else vkCmdPushDescriptorSetKHR := dynLib.GetProcAddress('vkCmdPushDescriptorSetKHR');
  if UseInstance then vkTrimCommandPool := vkGetInstanceProcAddr( Instance, 'vkTrimCommandPool' ) else vkTrimCommandPool := dynLib.GetProcAddress('vkTrimCommandPool');
  if UseInstance then vkTrimCommandPoolKHR := vkGetInstanceProcAddr( Instance, 'vkTrimCommandPoolKHR' ) else vkTrimCommandPoolKHR := dynLib.GetProcAddress('vkTrimCommandPoolKHR');
  if UseInstance then vkGetPhysicalDeviceExternalBufferProperties := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceExternalBufferProperties' ) else vkGetPhysicalDeviceExternalBufferProperties := dynLib.GetProcAddress('vkGetPhysicalDeviceExternalBufferProperties');
  if UseInstance then vkGetPhysicalDeviceExternalBufferPropertiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceExternalBufferPropertiesKHR' ) else vkGetPhysicalDeviceExternalBufferPropertiesKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceExternalBufferPropertiesKHR');
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}if UseInstance then vkGetMemoryWin32HandleKHR := vkGetInstanceProcAddr( Instance, 'vkGetMemoryWin32HandleKHR' ) else vkGetMemoryWin32HandleKHR := dynLib.GetProcAddress('vkGetMemoryWin32HandleKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}if UseInstance then vkGetMemoryWin32HandlePropertiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetMemoryWin32HandlePropertiesKHR' ) else vkGetMemoryWin32HandlePropertiesKHR := dynLib.GetProcAddress('vkGetMemoryWin32HandlePropertiesKHR');{$endif}
  if UseInstance then vkGetMemoryFdKHR := vkGetInstanceProcAddr( Instance, 'vkGetMemoryFdKHR' ) else vkGetMemoryFdKHR := dynLib.GetProcAddress('vkGetMemoryFdKHR');
  if UseInstance then vkGetMemoryFdPropertiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetMemoryFdPropertiesKHR' ) else vkGetMemoryFdPropertiesKHR := dynLib.GetProcAddress('vkGetMemoryFdPropertiesKHR');
  if UseInstance then vkGetPhysicalDeviceExternalSemaphoreProperties := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceExternalSemaphoreProperties' ) else vkGetPhysicalDeviceExternalSemaphoreProperties := dynLib.GetProcAddress('vkGetPhysicalDeviceExternalSemaphoreProperties');
  if UseInstance then vkGetPhysicalDeviceExternalSemaphorePropertiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceExternalSemaphorePropertiesKHR' ) else vkGetPhysicalDeviceExternalSemaphorePropertiesKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceExternalSemaphorePropertiesKHR');
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}if UseInstance then vkGetSemaphoreWin32HandleKHR := vkGetInstanceProcAddr( Instance, 'vkGetSemaphoreWin32HandleKHR' ) else vkGetSemaphoreWin32HandleKHR := dynLib.GetProcAddress('vkGetSemaphoreWin32HandleKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}if UseInstance then vkImportSemaphoreWin32HandleKHR := vkGetInstanceProcAddr( Instance, 'vkImportSemaphoreWin32HandleKHR' ) else vkImportSemaphoreWin32HandleKHR := dynLib.GetProcAddress('vkImportSemaphoreWin32HandleKHR');{$endif}
  if UseInstance then vkGetSemaphoreFdKHR := vkGetInstanceProcAddr( Instance, 'vkGetSemaphoreFdKHR' ) else vkGetSemaphoreFdKHR := dynLib.GetProcAddress('vkGetSemaphoreFdKHR');
  if UseInstance then vkImportSemaphoreFdKHR := vkGetInstanceProcAddr( Instance, 'vkImportSemaphoreFdKHR' ) else vkImportSemaphoreFdKHR := dynLib.GetProcAddress('vkImportSemaphoreFdKHR');
  if UseInstance then vkGetPhysicalDeviceExternalFenceProperties := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceExternalFenceProperties' ) else vkGetPhysicalDeviceExternalFenceProperties := dynLib.GetProcAddress('vkGetPhysicalDeviceExternalFenceProperties');
  if UseInstance then vkGetPhysicalDeviceExternalFencePropertiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceExternalFencePropertiesKHR' ) else vkGetPhysicalDeviceExternalFencePropertiesKHR := dynLib.GetProcAddress('vkGetPhysicalDeviceExternalFencePropertiesKHR');
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}if UseInstance then vkGetFenceWin32HandleKHR := vkGetInstanceProcAddr( Instance, 'vkGetFenceWin32HandleKHR' ) else vkGetFenceWin32HandleKHR := dynLib.GetProcAddress('vkGetFenceWin32HandleKHR');{$endif}
  {$ifdef VK_USE_PLATFORM_WIN32_KHR}if UseInstance then vkImportFenceWin32HandleKHR := vkGetInstanceProcAddr( Instance, 'vkImportFenceWin32HandleKHR' ) else vkImportFenceWin32HandleKHR := dynLib.GetProcAddress('vkImportFenceWin32HandleKHR');{$endif}
  if UseInstance then vkGetFenceFdKHR := vkGetInstanceProcAddr( Instance, 'vkGetFenceFdKHR' ) else vkGetFenceFdKHR := dynLib.GetProcAddress('vkGetFenceFdKHR');
  if UseInstance then vkImportFenceFdKHR := vkGetInstanceProcAddr( Instance, 'vkImportFenceFdKHR' ) else vkImportFenceFdKHR := dynLib.GetProcAddress('vkImportFenceFdKHR');
  if UseInstance then vkReleaseDisplayEXT := vkGetInstanceProcAddr( Instance, 'vkReleaseDisplayEXT' ) else vkReleaseDisplayEXT := dynLib.GetProcAddress('vkReleaseDisplayEXT');
  {$ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT}if UseInstance then vkAcquireXlibDisplayEXT := vkGetInstanceProcAddr( Instance, 'vkAcquireXlibDisplayEXT' ) else vkAcquireXlibDisplayEXT := dynLib.GetProcAddress('vkAcquireXlibDisplayEXT');{$endif}
  {$ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT}if UseInstance then vkGetRandROutputDisplayEXT := vkGetInstanceProcAddr( Instance, 'vkGetRandROutputDisplayEXT' ) else vkGetRandROutputDisplayEXT := dynLib.GetProcAddress('vkGetRandROutputDisplayEXT');{$endif}
  if UseInstance then vkDisplayPowerControlEXT := vkGetInstanceProcAddr( Instance, 'vkDisplayPowerControlEXT' ) else vkDisplayPowerControlEXT := dynLib.GetProcAddress('vkDisplayPowerControlEXT');
  if UseInstance then vkRegisterDeviceEventEXT := vkGetInstanceProcAddr( Instance, 'vkRegisterDeviceEventEXT' ) else vkRegisterDeviceEventEXT := dynLib.GetProcAddress('vkRegisterDeviceEventEXT');
  if UseInstance then vkRegisterDisplayEventEXT := vkGetInstanceProcAddr( Instance, 'vkRegisterDisplayEventEXT' ) else vkRegisterDisplayEventEXT := dynLib.GetProcAddress('vkRegisterDisplayEventEXT');
  if UseInstance then vkGetSwapchainCounterEXT := vkGetInstanceProcAddr( Instance, 'vkGetSwapchainCounterEXT' ) else vkGetSwapchainCounterEXT := dynLib.GetProcAddress('vkGetSwapchainCounterEXT');
  if UseInstance then vkGetPhysicalDeviceSurfaceCapabilities2EXT := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceSurfaceCapabilities2EXT' ) else vkGetPhysicalDeviceSurfaceCapabilities2EXT := dynLib.GetProcAddress('vkGetPhysicalDeviceSurfaceCapabilities2EXT');
  if UseInstance then vkEnumeratePhysicalDeviceGroups := vkGetInstanceProcAddr( Instance, 'vkEnumeratePhysicalDeviceGroups' ) else vkEnumeratePhysicalDeviceGroups := dynLib.GetProcAddress('vkEnumeratePhysicalDeviceGroups');
  if UseInstance then vkEnumeratePhysicalDeviceGroupsKHR := vkGetInstanceProcAddr( Instance, 'vkEnumeratePhysicalDeviceGroupsKHR' ) else vkEnumeratePhysicalDeviceGroupsKHR := dynLib.GetProcAddress('vkEnumeratePhysicalDeviceGroupsKHR');
  if UseInstance then vkGetDeviceGroupPeerMemoryFeatures := vkGetInstanceProcAddr( Instance, 'vkGetDeviceGroupPeerMemoryFeatures' ) else vkGetDeviceGroupPeerMemoryFeatures := dynLib.GetProcAddress('vkGetDeviceGroupPeerMemoryFeatures');
  if UseInstance then vkGetDeviceGroupPeerMemoryFeaturesKHR := vkGetInstanceProcAddr( Instance, 'vkGetDeviceGroupPeerMemoryFeaturesKHR' ) else vkGetDeviceGroupPeerMemoryFeaturesKHR := dynLib.GetProcAddress('vkGetDeviceGroupPeerMemoryFeaturesKHR');
  if UseInstance then vkBindBufferMemory2 := vkGetInstanceProcAddr( Instance, 'vkBindBufferMemory2' ) else vkBindBufferMemory2 := dynLib.GetProcAddress('vkBindBufferMemory2');
  if UseInstance then vkBindBufferMemory2KHR := vkGetInstanceProcAddr( Instance, 'vkBindBufferMemory2KHR' ) else vkBindBufferMemory2KHR := dynLib.GetProcAddress('vkBindBufferMemory2KHR');
  if UseInstance then vkBindImageMemory2 := vkGetInstanceProcAddr( Instance, 'vkBindImageMemory2' ) else vkBindImageMemory2 := dynLib.GetProcAddress('vkBindImageMemory2');
  if UseInstance then vkBindImageMemory2KHR := vkGetInstanceProcAddr( Instance, 'vkBindImageMemory2KHR' ) else vkBindImageMemory2KHR := dynLib.GetProcAddress('vkBindImageMemory2KHR');
  if UseInstance then vkCmdSetDeviceMask := vkGetInstanceProcAddr( Instance, 'vkCmdSetDeviceMask' ) else vkCmdSetDeviceMask := dynLib.GetProcAddress('vkCmdSetDeviceMask');
  if UseInstance then vkCmdSetDeviceMaskKHR := vkGetInstanceProcAddr( Instance, 'vkCmdSetDeviceMaskKHR' ) else vkCmdSetDeviceMaskKHR := dynLib.GetProcAddress('vkCmdSetDeviceMaskKHR');
  if UseInstance then vkGetDeviceGroupPresentCapabilitiesKHR := vkGetInstanceProcAddr( Instance, 'vkGetDeviceGroupPresentCapabilitiesKHR' ) else vkGetDeviceGroupPresentCapabilitiesKHR := dynLib.GetProcAddress('vkGetDeviceGroupPresentCapabilitiesKHR');
  if UseInstance then vkGetDeviceGroupSurfacePresentModesKHR := vkGetInstanceProcAddr( Instance, 'vkGetDeviceGroupSurfacePresentModesKHR' ) else vkGetDeviceGroupSurfacePresentModesKHR := dynLib.GetProcAddress('vkGetDeviceGroupSurfacePresentModesKHR');
  if UseInstance then vkAcquireNextImage2KHR := vkGetInstanceProcAddr( Instance, 'vkAcquireNextImage2KHR' ) else vkAcquireNextImage2KHR := dynLib.GetProcAddress('vkAcquireNextImage2KHR');
  if UseInstance then vkCmdDispatchBase := vkGetInstanceProcAddr( Instance, 'vkCmdDispatchBase' ) else vkCmdDispatchBase := dynLib.GetProcAddress('vkCmdDispatchBase');
  if UseInstance then vkCmdDispatchBaseKHR := vkGetInstanceProcAddr( Instance, 'vkCmdDispatchBaseKHR' ) else vkCmdDispatchBaseKHR := dynLib.GetProcAddress('vkCmdDispatchBaseKHR');
  if UseInstance then vkGetPhysicalDevicePresentRectanglesKHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDevicePresentRectanglesKHR' ) else vkGetPhysicalDevicePresentRectanglesKHR := dynLib.GetProcAddress('vkGetPhysicalDevicePresentRectanglesKHR');
  if UseInstance then vkCreateDescriptorUpdateTemplate := vkGetInstanceProcAddr( Instance, 'vkCreateDescriptorUpdateTemplate' ) else vkCreateDescriptorUpdateTemplate := dynLib.GetProcAddress('vkCreateDescriptorUpdateTemplate');
  if UseInstance then vkCreateDescriptorUpdateTemplateKHR := vkGetInstanceProcAddr( Instance, 'vkCreateDescriptorUpdateTemplateKHR' ) else vkCreateDescriptorUpdateTemplateKHR := dynLib.GetProcAddress('vkCreateDescriptorUpdateTemplateKHR');
  if UseInstance then vkDestroyDescriptorUpdateTemplate := vkGetInstanceProcAddr( Instance, 'vkDestroyDescriptorUpdateTemplate' ) else vkDestroyDescriptorUpdateTemplate := dynLib.GetProcAddress('vkDestroyDescriptorUpdateTemplate');
  if UseInstance then vkDestroyDescriptorUpdateTemplateKHR := vkGetInstanceProcAddr( Instance, 'vkDestroyDescriptorUpdateTemplateKHR' ) else vkDestroyDescriptorUpdateTemplateKHR := dynLib.GetProcAddress('vkDestroyDescriptorUpdateTemplateKHR');
  if UseInstance then vkUpdateDescriptorSetWithTemplate := vkGetInstanceProcAddr( Instance, 'vkUpdateDescriptorSetWithTemplate' ) else vkUpdateDescriptorSetWithTemplate := dynLib.GetProcAddress('vkUpdateDescriptorSetWithTemplate');
  if UseInstance then vkUpdateDescriptorSetWithTemplateKHR := vkGetInstanceProcAddr( Instance, 'vkUpdateDescriptorSetWithTemplateKHR' ) else vkUpdateDescriptorSetWithTemplateKHR := dynLib.GetProcAddress('vkUpdateDescriptorSetWithTemplateKHR');
  if UseInstance then vkCmdPushDescriptorSetWithTemplateKHR := vkGetInstanceProcAddr( Instance, 'vkCmdPushDescriptorSetWithTemplateKHR' ) else vkCmdPushDescriptorSetWithTemplateKHR := dynLib.GetProcAddress('vkCmdPushDescriptorSetWithTemplateKHR');
  if UseInstance then vkSetHdrMetadataEXT := vkGetInstanceProcAddr( Instance, 'vkSetHdrMetadataEXT' ) else vkSetHdrMetadataEXT := dynLib.GetProcAddress('vkSetHdrMetadataEXT');
  if UseInstance then vkGetSwapchainStatusKHR := vkGetInstanceProcAddr( Instance, 'vkGetSwapchainStatusKHR' ) else vkGetSwapchainStatusKHR := dynLib.GetProcAddress('vkGetSwapchainStatusKHR');
  if UseInstance then vkGetRefreshCycleDurationGOOGLE := vkGetInstanceProcAddr( Instance, 'vkGetRefreshCycleDurationGOOGLE' ) else vkGetRefreshCycleDurationGOOGLE := dynLib.GetProcAddress('vkGetRefreshCycleDurationGOOGLE');
  if UseInstance then vkGetPastPresentationTimingGOOGLE := vkGetInstanceProcAddr( Instance, 'vkGetPastPresentationTimingGOOGLE' ) else vkGetPastPresentationTimingGOOGLE := dynLib.GetProcAddress('vkGetPastPresentationTimingGOOGLE');
  {$ifdef VK_USE_PLATFORM_IOS_MVK}if UseInstance then vkCreateIOSSurfaceMVK := vkGetInstanceProcAddr( Instance, 'vkCreateIOSSurfaceMVK' ) else vkCreateIOSSurfaceMVK := dynLib.GetProcAddress('vkCreateIOSSurfaceMVK');{$endif}
  {$ifdef VK_USE_PLATFORM_MACOS_MVK}if UseInstance then vkCreateMacOSSurfaceMVK := vkGetInstanceProcAddr( Instance, 'vkCreateMacOSSurfaceMVK' ) else vkCreateMacOSSurfaceMVK := dynLib.GetProcAddress('vkCreateMacOSSurfaceMVK');{$endif}
  if UseInstance then vkCmdSetViewportWScalingNV := vkGetInstanceProcAddr( Instance, 'vkCmdSetViewportWScalingNV' ) else vkCmdSetViewportWScalingNV := dynLib.GetProcAddress('vkCmdSetViewportWScalingNV');
  if UseInstance then vkCmdSetDiscardRectangleEXT := vkGetInstanceProcAddr( Instance, 'vkCmdSetDiscardRectangleEXT' ) else vkCmdSetDiscardRectangleEXT := dynLib.GetProcAddress('vkCmdSetDiscardRectangleEXT');
  if UseInstance then vkCmdSetSampleLocationsEXT := vkGetInstanceProcAddr( Instance, 'vkCmdSetSampleLocationsEXT' ) else vkCmdSetSampleLocationsEXT := dynLib.GetProcAddress('vkCmdSetSampleLocationsEXT');
  if UseInstance then vkGetPhysicalDeviceMultisamplePropertiesEXT := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceMultisamplePropertiesEXT' ) else vkGetPhysicalDeviceMultisamplePropertiesEXT := dynLib.GetProcAddress('vkGetPhysicalDeviceMultisamplePropertiesEXT');
  if UseInstance then vkGetPhysicalDeviceSurfaceCapabilities2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceSurfaceCapabilities2KHR' ) else vkGetPhysicalDeviceSurfaceCapabilities2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceSurfaceCapabilities2KHR');
  if UseInstance then vkGetPhysicalDeviceSurfaceFormats2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceSurfaceFormats2KHR' ) else vkGetPhysicalDeviceSurfaceFormats2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceSurfaceFormats2KHR');
  if UseInstance then vkGetPhysicalDeviceDisplayProperties2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceDisplayProperties2KHR' ) else vkGetPhysicalDeviceDisplayProperties2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceDisplayProperties2KHR');
  if UseInstance then vkGetPhysicalDeviceDisplayPlaneProperties2KHR := vkGetInstanceProcAddr( Instance, 'vkGetPhysicalDeviceDisplayPlaneProperties2KHR' ) else vkGetPhysicalDeviceDisplayPlaneProperties2KHR := dynLib.GetProcAddress('vkGetPhysicalDeviceDisplayPlaneProperties2KHR');
  if UseInstance then vkGetDisplayModeProperties2KHR := vkGetInstanceProcAddr( Instance, 'vkGetDisplayModeProperties2KHR' ) else vkGetDisplayModeProperties2KHR := dynLib.GetProcAddress('vkGetDisplayModeProperties2KHR');
  if UseInstance then vkGetDisplayPlaneCapabilities2KHR := vkGetInstanceProcAddr( Instance, 'vkGetDisplayPlaneCapabilities2KHR' ) else vkGetDisplayPlaneCapabilities2KHR := dynLib.GetProcAddress('vkGetDisplayPlaneCapabilities2KHR');
  if UseInstance then vkGetBufferMemoryRequirements2 := vkGetInstanceProcAddr( Instance, 'vkGetBufferMemoryRequirements2' ) else vkGetBufferMemoryRequirements2 := dynLib.GetProcAddress('vkGetBufferMemoryRequirements2');
  if UseInstance then vkGetBufferMemoryRequirements2KHR := vkGetInstanceProcAddr( Instance, 'vkGetBufferMemoryRequirements2KHR' ) else vkGetBufferMemoryRequirements2KHR := dynLib.GetProcAddress('vkGetBufferMemoryRequirements2KHR');
  if UseInstance then vkGetImageMemoryRequirements2 := vkGetInstanceProcAddr( Instance, 'vkGetImageMemoryRequirements2' ) else vkGetImageMemoryRequirements2 := dynLib.GetProcAddress('vkGetImageMemoryRequirements2');
  if UseInstance then vkGetImageMemoryRequirements2KHR := vkGetInstanceProcAddr( Instance, 'vkGetImageMemoryRequirements2KHR' ) else vkGetImageMemoryRequirements2KHR := dynLib.GetProcAddress('vkGetImageMemoryRequirements2KHR');
  if UseInstance then vkGetImageSparseMemoryRequirements2 := vkGetInstanceProcAddr( Instance, 'vkGetImageSparseMemoryRequirements2' ) else vkGetImageSparseMemoryRequirements2 := dynLib.GetProcAddress('vkGetImageSparseMemoryRequirements2');
  if UseInstance then vkGetImageSparseMemoryRequirements2KHR := vkGetInstanceProcAddr( Instance, 'vkGetImageSparseMemoryRequirements2KHR' ) else vkGetImageSparseMemoryRequirements2KHR := dynLib.GetProcAddress('vkGetImageSparseMemoryRequirements2KHR');
  if UseInstance then vkCreateSamplerYcbcrConversion := vkGetInstanceProcAddr( Instance, 'vkCreateSamplerYcbcrConversion' ) else vkCreateSamplerYcbcrConversion := dynLib.GetProcAddress('vkCreateSamplerYcbcrConversion');
  if UseInstance then vkCreateSamplerYcbcrConversionKHR := vkGetInstanceProcAddr( Instance, 'vkCreateSamplerYcbcrConversionKHR' ) else vkCreateSamplerYcbcrConversionKHR := dynLib.GetProcAddress('vkCreateSamplerYcbcrConversionKHR');
  if UseInstance then vkDestroySamplerYcbcrConversion := vkGetInstanceProcAddr( Instance, 'vkDestroySamplerYcbcrConversion' ) else vkDestroySamplerYcbcrConversion := dynLib.GetProcAddress('vkDestroySamplerYcbcrConversion');
  if UseInstance then vkDestroySamplerYcbcrConversionKHR := vkGetInstanceProcAddr( Instance, 'vkDestroySamplerYcbcrConversionKHR' ) else vkDestroySamplerYcbcrConversionKHR := dynLib.GetProcAddress('vkDestroySamplerYcbcrConversionKHR');
  if UseInstance then vkGetDeviceQueue2 := vkGetInstanceProcAddr( Instance, 'vkGetDeviceQueue2' ) else vkGetDeviceQueue2 := dynLib.GetProcAddress('vkGetDeviceQueue2');
  if UseInstance then vkCreateValidationCacheEXT := vkGetInstanceProcAddr( Instance, 'vkCreateValidationCacheEXT' ) else vkCreateValidationCacheEXT := dynLib.GetProcAddress('vkCreateValidationCacheEXT');
  if UseInstance then vkDestroyValidationCacheEXT := vkGetInstanceProcAddr( Instance, 'vkDestroyValidationCacheEXT' ) else vkDestroyValidationCacheEXT := dynLib.GetProcAddress('vkDestroyValidationCacheEXT');
  if UseInstance then vkGetValidationCacheDataEXT := vkGetInstanceProcAddr( Instance, 'vkGetValidationCacheDataEXT' ) else vkGetValidationCacheDataEXT := dynLib.GetProcAddress('vkGetValidationCacheDataEXT');
  if UseInstance then vkMergeValidationCachesEXT := vkGetInstanceProcAddr( Instance, 'vkMergeValidationCachesEXT' ) else vkMergeValidationCachesEXT := dynLib.GetProcAddress('vkMergeValidationCachesEXT');
  if UseInstance then vkGetDescriptorSetLayoutSupport := vkGetInstanceProcAddr( Instance, 'vkGetDescriptorSetLayoutSupport' ) else vkGetDescriptorSetLayoutSupport := dynLib.GetProcAddress('vkGetDescriptorSetLayoutSupport');
  if UseInstance then vkGetDescriptorSetLayoutSupportKHR := vkGetInstanceProcAddr( Instance, 'vkGetDescriptorSetLayoutSupportKHR' ) else vkGetDescriptorSetLayoutSupportKHR := dynLib.GetProcAddress('vkGetDescriptorSetLayoutSupportKHR');
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}if UseInstance then vkGetSwapchainGrallocUsageANDROID := vkGetInstanceProcAddr( Instance, 'vkGetSwapchainGrallocUsageANDROID' ) else vkGetSwapchainGrallocUsageANDROID := dynLib.GetProcAddress('vkGetSwapchainGrallocUsageANDROID');{$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}if UseInstance then vkAcquireImageANDROID := vkGetInstanceProcAddr( Instance, 'vkAcquireImageANDROID' ) else vkAcquireImageANDROID := dynLib.GetProcAddress('vkAcquireImageANDROID');{$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}if UseInstance then vkQueueSignalReleaseImageANDROID := vkGetInstanceProcAddr( Instance, 'vkQueueSignalReleaseImageANDROID' ) else vkQueueSignalReleaseImageANDROID := dynLib.GetProcAddress('vkQueueSignalReleaseImageANDROID');{$endif}
  if UseInstance then vkGetShaderInfoAMD := vkGetInstanceProcAddr( Instance, 'vkGetShaderInfoAMD' ) else vkGetShaderInfoAMD := dynLib.GetProcAddress('vkGetShaderInfoAMD');
  if UseInstance then vkSetDebugUtilsObjectNameEXT := vkGetInstanceProcAddr( Instance, 'vkSetDebugUtilsObjectNameEXT' ) else vkSetDebugUtilsObjectNameEXT := dynLib.GetProcAddress('vkSetDebugUtilsObjectNameEXT');
  if UseInstance then vkSetDebugUtilsObjectTagEXT := vkGetInstanceProcAddr( Instance, 'vkSetDebugUtilsObjectTagEXT' ) else vkSetDebugUtilsObjectTagEXT := dynLib.GetProcAddress('vkSetDebugUtilsObjectTagEXT');
  if UseInstance then vkQueueBeginDebugUtilsLabelEXT := vkGetInstanceProcAddr( Instance, 'vkQueueBeginDebugUtilsLabelEXT' ) else vkQueueBeginDebugUtilsLabelEXT := dynLib.GetProcAddress('vkQueueBeginDebugUtilsLabelEXT');
  if UseInstance then vkQueueEndDebugUtilsLabelEXT := vkGetInstanceProcAddr( Instance, 'vkQueueEndDebugUtilsLabelEXT' ) else vkQueueEndDebugUtilsLabelEXT := dynLib.GetProcAddress('vkQueueEndDebugUtilsLabelEXT');
  if UseInstance then vkQueueInsertDebugUtilsLabelEXT := vkGetInstanceProcAddr( Instance, 'vkQueueInsertDebugUtilsLabelEXT' ) else vkQueueInsertDebugUtilsLabelEXT := dynLib.GetProcAddress('vkQueueInsertDebugUtilsLabelEXT');
  if UseInstance then vkCmdBeginDebugUtilsLabelEXT := vkGetInstanceProcAddr( Instance, 'vkCmdBeginDebugUtilsLabelEXT' ) else vkCmdBeginDebugUtilsLabelEXT := dynLib.GetProcAddress('vkCmdBeginDebugUtilsLabelEXT');
  if UseInstance then vkCmdEndDebugUtilsLabelEXT := vkGetInstanceProcAddr( Instance, 'vkCmdEndDebugUtilsLabelEXT' ) else vkCmdEndDebugUtilsLabelEXT := dynLib.GetProcAddress('vkCmdEndDebugUtilsLabelEXT');
  if UseInstance then vkCmdInsertDebugUtilsLabelEXT := vkGetInstanceProcAddr( Instance, 'vkCmdInsertDebugUtilsLabelEXT' ) else vkCmdInsertDebugUtilsLabelEXT := dynLib.GetProcAddress('vkCmdInsertDebugUtilsLabelEXT');
  if UseInstance then vkCreateDebugUtilsMessengerEXT := vkGetInstanceProcAddr( Instance, 'vkCreateDebugUtilsMessengerEXT' ) else vkCreateDebugUtilsMessengerEXT := dynLib.GetProcAddress('vkCreateDebugUtilsMessengerEXT');
  if UseInstance then vkDestroyDebugUtilsMessengerEXT := vkGetInstanceProcAddr( Instance, 'vkDestroyDebugUtilsMessengerEXT' ) else vkDestroyDebugUtilsMessengerEXT := dynLib.GetProcAddress('vkDestroyDebugUtilsMessengerEXT');
  if UseInstance then vkSubmitDebugUtilsMessageEXT := vkGetInstanceProcAddr( Instance, 'vkSubmitDebugUtilsMessageEXT' ) else vkSubmitDebugUtilsMessageEXT := dynLib.GetProcAddress('vkSubmitDebugUtilsMessageEXT');
  if UseInstance then vkGetMemoryHostPointerPropertiesEXT := vkGetInstanceProcAddr( Instance, 'vkGetMemoryHostPointerPropertiesEXT' ) else vkGetMemoryHostPointerPropertiesEXT := dynLib.GetProcAddress('vkGetMemoryHostPointerPropertiesEXT');
  if UseInstance then vkCmdWriteBufferMarkerAMD := vkGetInstanceProcAddr( Instance, 'vkCmdWriteBufferMarkerAMD' ) else vkCmdWriteBufferMarkerAMD := dynLib.GetProcAddress('vkCmdWriteBufferMarkerAMD');
  if UseInstance then vkCreateRenderPass2KHR := vkGetInstanceProcAddr( Instance, 'vkCreateRenderPass2KHR' ) else vkCreateRenderPass2KHR := dynLib.GetProcAddress('vkCreateRenderPass2KHR');
  if UseInstance then vkCmdBeginRenderPass2KHR := vkGetInstanceProcAddr( Instance, 'vkCmdBeginRenderPass2KHR' ) else vkCmdBeginRenderPass2KHR := dynLib.GetProcAddress('vkCmdBeginRenderPass2KHR');
  if UseInstance then vkCmdNextSubpass2KHR := vkGetInstanceProcAddr( Instance, 'vkCmdNextSubpass2KHR' ) else vkCmdNextSubpass2KHR := dynLib.GetProcAddress('vkCmdNextSubpass2KHR');
  if UseInstance then vkCmdEndRenderPass2KHR := vkGetInstanceProcAddr( Instance, 'vkCmdEndRenderPass2KHR' ) else vkCmdEndRenderPass2KHR := dynLib.GetProcAddress('vkCmdEndRenderPass2KHR');
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}if UseInstance then vkGetAndroidHardwareBufferPropertiesANDROID := vkGetInstanceProcAddr( Instance, 'vkGetAndroidHardwareBufferPropertiesANDROID' ) else vkGetAndroidHardwareBufferPropertiesANDROID := dynLib.GetProcAddress('vkGetAndroidHardwareBufferPropertiesANDROID');{$endif}
  {$ifdef VK_USE_PLATFORM_ANDROID_KHR}if UseInstance then vkGetMemoryAndroidHardwareBufferANDROID := vkGetInstanceProcAddr( Instance, 'vkGetMemoryAndroidHardwareBufferANDROID' ) else vkGetMemoryAndroidHardwareBufferANDROID := dynLib.GetProcAddress('vkGetMemoryAndroidHardwareBufferANDROID');{$endif}
  if UseInstance then vkCmdDrawIndirectCountKHR := vkGetInstanceProcAddr( Instance, 'vkCmdDrawIndirectCountKHR' ) else vkCmdDrawIndirectCountKHR := dynLib.GetProcAddress('vkCmdDrawIndirectCountKHR');
  if UseInstance then vkCmdDrawIndexedIndirectCountKHR := vkGetInstanceProcAddr( Instance, 'vkCmdDrawIndexedIndirectCountKHR' ) else vkCmdDrawIndexedIndirectCountKHR := dynLib.GetProcAddress('vkCmdDrawIndexedIndirectCountKHR');
  if UseInstance then vkCmdSetCheckpointNV := vkGetInstanceProcAddr( Instance, 'vkCmdSetCheckpointNV' ) else vkCmdSetCheckpointNV := dynLib.GetProcAddress('vkCmdSetCheckpointNV');
  if UseInstance then vkGetQueueCheckpointDataNV := vkGetInstanceProcAddr( Instance, 'vkGetQueueCheckpointDataNV' ) else vkGetQueueCheckpointDataNV := dynLib.GetProcAddress('vkGetQueueCheckpointDataNV');

end;

procedure Tvk.ReloadPointers( const Instance: vkInstance );
begin
  LoadPointers(Instance,TRUE);
end;

constructor Tvk.Create;
begin
  inherited;
  LoadPointers(0,FALSE);
end;

function VulkanAvailable: boolean;
begin
  Result := assigned(dynLib)
end;


initialization


finalization

  dynLib := nil;


end.
